// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ClientNamenode.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_ClientNamenode_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_ClientNamenode_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "dfs.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_ClientNamenode_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_ClientNamenode_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_ClientNamenode_2eproto;
namespace ClientNamenode {
class AddBlockRequest;
struct AddBlockRequestDefaultTypeInternal;
extern AddBlockRequestDefaultTypeInternal _AddBlockRequest_default_instance_;
class AddBlockResponse;
struct AddBlockResponseDefaultTypeInternal;
extern AddBlockResponseDefaultTypeInternal _AddBlockResponse_default_instance_;
class AppendRequest;
struct AppendRequestDefaultTypeInternal;
extern AppendRequestDefaultTypeInternal _AppendRequest_default_instance_;
class AppendResponse;
struct AppendResponseDefaultTypeInternal;
extern AppendResponseDefaultTypeInternal _AppendResponse_default_instance_;
class CreateRequest;
struct CreateRequestDefaultTypeInternal;
extern CreateRequestDefaultTypeInternal _CreateRequest_default_instance_;
class CreateResponse;
struct CreateResponseDefaultTypeInternal;
extern CreateResponseDefaultTypeInternal _CreateResponse_default_instance_;
class DeleteRequest;
struct DeleteRequestDefaultTypeInternal;
extern DeleteRequestDefaultTypeInternal _DeleteRequest_default_instance_;
class DeleteResponse;
struct DeleteResponseDefaultTypeInternal;
extern DeleteResponseDefaultTypeInternal _DeleteResponse_default_instance_;
class GetBlockLocationResponse;
struct GetBlockLocationResponseDefaultTypeInternal;
extern GetBlockLocationResponseDefaultTypeInternal _GetBlockLocationResponse_default_instance_;
class GetBlockLocationsRequest;
struct GetBlockLocationsRequestDefaultTypeInternal;
extern GetBlockLocationsRequestDefaultTypeInternal _GetBlockLocationsRequest_default_instance_;
class GetListingRequest;
struct GetListingRequestDefaultTypeInternal;
extern GetListingRequestDefaultTypeInternal _GetListingRequest_default_instance_;
class GetListingResponse;
struct GetListingResponseDefaultTypeInternal;
extern GetListingResponseDefaultTypeInternal _GetListingResponse_default_instance_;
class GetServerDefaultsRequest;
struct GetServerDefaultsRequestDefaultTypeInternal;
extern GetServerDefaultsRequestDefaultTypeInternal _GetServerDefaultsRequest_default_instance_;
class GetServerDefaultsResponse;
struct GetServerDefaultsResponseDefaultTypeInternal;
extern GetServerDefaultsResponseDefaultTypeInternal _GetServerDefaultsResponse_default_instance_;
class RenameRequest;
struct RenameRequestDefaultTypeInternal;
extern RenameRequestDefaultTypeInternal _RenameRequest_default_instance_;
class RenameResponse;
struct RenameResponseDefaultTypeInternal;
extern RenameResponseDefaultTypeInternal _RenameResponse_default_instance_;
class RenewLeaseRequest;
struct RenewLeaseRequestDefaultTypeInternal;
extern RenewLeaseRequestDefaultTypeInternal _RenewLeaseRequest_default_instance_;
class RenewLeaseResponse;
struct RenewLeaseResponseDefaultTypeInternal;
extern RenewLeaseResponseDefaultTypeInternal _RenewLeaseResponse_default_instance_;
class SetOwnerRequest;
struct SetOwnerRequestDefaultTypeInternal;
extern SetOwnerRequestDefaultTypeInternal _SetOwnerRequest_default_instance_;
class SetOwnerResponse;
struct SetOwnerResponseDefaultTypeInternal;
extern SetOwnerResponseDefaultTypeInternal _SetOwnerResponse_default_instance_;
class SetPermissionRequest;
struct SetPermissionRequestDefaultTypeInternal;
extern SetPermissionRequestDefaultTypeInternal _SetPermissionRequest_default_instance_;
class SetPermissionResponse;
struct SetPermissionResponseDefaultTypeInternal;
extern SetPermissionResponseDefaultTypeInternal _SetPermissionResponse_default_instance_;
class mkdirRequest;
struct mkdirRequestDefaultTypeInternal;
extern mkdirRequestDefaultTypeInternal _mkdirRequest_default_instance_;
class mkdirResponse;
struct mkdirResponseDefaultTypeInternal;
extern mkdirResponseDefaultTypeInternal _mkdirResponse_default_instance_;
}  // namespace ClientNamenode
PROTOBUF_NAMESPACE_OPEN
template<> ::ClientNamenode::AddBlockRequest* Arena::CreateMaybeMessage<::ClientNamenode::AddBlockRequest>(Arena*);
template<> ::ClientNamenode::AddBlockResponse* Arena::CreateMaybeMessage<::ClientNamenode::AddBlockResponse>(Arena*);
template<> ::ClientNamenode::AppendRequest* Arena::CreateMaybeMessage<::ClientNamenode::AppendRequest>(Arena*);
template<> ::ClientNamenode::AppendResponse* Arena::CreateMaybeMessage<::ClientNamenode::AppendResponse>(Arena*);
template<> ::ClientNamenode::CreateRequest* Arena::CreateMaybeMessage<::ClientNamenode::CreateRequest>(Arena*);
template<> ::ClientNamenode::CreateResponse* Arena::CreateMaybeMessage<::ClientNamenode::CreateResponse>(Arena*);
template<> ::ClientNamenode::DeleteRequest* Arena::CreateMaybeMessage<::ClientNamenode::DeleteRequest>(Arena*);
template<> ::ClientNamenode::DeleteResponse* Arena::CreateMaybeMessage<::ClientNamenode::DeleteResponse>(Arena*);
template<> ::ClientNamenode::GetBlockLocationResponse* Arena::CreateMaybeMessage<::ClientNamenode::GetBlockLocationResponse>(Arena*);
template<> ::ClientNamenode::GetBlockLocationsRequest* Arena::CreateMaybeMessage<::ClientNamenode::GetBlockLocationsRequest>(Arena*);
template<> ::ClientNamenode::GetListingRequest* Arena::CreateMaybeMessage<::ClientNamenode::GetListingRequest>(Arena*);
template<> ::ClientNamenode::GetListingResponse* Arena::CreateMaybeMessage<::ClientNamenode::GetListingResponse>(Arena*);
template<> ::ClientNamenode::GetServerDefaultsRequest* Arena::CreateMaybeMessage<::ClientNamenode::GetServerDefaultsRequest>(Arena*);
template<> ::ClientNamenode::GetServerDefaultsResponse* Arena::CreateMaybeMessage<::ClientNamenode::GetServerDefaultsResponse>(Arena*);
template<> ::ClientNamenode::RenameRequest* Arena::CreateMaybeMessage<::ClientNamenode::RenameRequest>(Arena*);
template<> ::ClientNamenode::RenameResponse* Arena::CreateMaybeMessage<::ClientNamenode::RenameResponse>(Arena*);
template<> ::ClientNamenode::RenewLeaseRequest* Arena::CreateMaybeMessage<::ClientNamenode::RenewLeaseRequest>(Arena*);
template<> ::ClientNamenode::RenewLeaseResponse* Arena::CreateMaybeMessage<::ClientNamenode::RenewLeaseResponse>(Arena*);
template<> ::ClientNamenode::SetOwnerRequest* Arena::CreateMaybeMessage<::ClientNamenode::SetOwnerRequest>(Arena*);
template<> ::ClientNamenode::SetOwnerResponse* Arena::CreateMaybeMessage<::ClientNamenode::SetOwnerResponse>(Arena*);
template<> ::ClientNamenode::SetPermissionRequest* Arena::CreateMaybeMessage<::ClientNamenode::SetPermissionRequest>(Arena*);
template<> ::ClientNamenode::SetPermissionResponse* Arena::CreateMaybeMessage<::ClientNamenode::SetPermissionResponse>(Arena*);
template<> ::ClientNamenode::mkdirRequest* Arena::CreateMaybeMessage<::ClientNamenode::mkdirRequest>(Arena*);
template<> ::ClientNamenode::mkdirResponse* Arena::CreateMaybeMessage<::ClientNamenode::mkdirResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace ClientNamenode {

enum CreateFlag : int {
  CREATE = 0,
  OVERWRITE = 1,
  APPEND = 2,
  CreateFlag_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CreateFlag_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CreateFlag_IsValid(int value);
constexpr CreateFlag CreateFlag_MIN = CREATE;
constexpr CreateFlag CreateFlag_MAX = APPEND;
constexpr int CreateFlag_ARRAYSIZE = CreateFlag_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CreateFlag_descriptor();
template<typename T>
inline const std::string& CreateFlag_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CreateFlag>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CreateFlag_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CreateFlag_descriptor(), enum_t_value);
}
inline bool CreateFlag_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CreateFlag* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CreateFlag>(
    CreateFlag_descriptor(), name, value);
}
// ===================================================================

class GetBlockLocationsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ClientNamenode.GetBlockLocationsRequest) */ {
 public:
  inline GetBlockLocationsRequest() : GetBlockLocationsRequest(nullptr) {}
  ~GetBlockLocationsRequest() override;
  explicit PROTOBUF_CONSTEXPR GetBlockLocationsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBlockLocationsRequest(const GetBlockLocationsRequest& from);
  GetBlockLocationsRequest(GetBlockLocationsRequest&& from) noexcept
    : GetBlockLocationsRequest() {
    *this = ::std::move(from);
  }

  inline GetBlockLocationsRequest& operator=(const GetBlockLocationsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBlockLocationsRequest& operator=(GetBlockLocationsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBlockLocationsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBlockLocationsRequest* internal_default_instance() {
    return reinterpret_cast<const GetBlockLocationsRequest*>(
               &_GetBlockLocationsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(GetBlockLocationsRequest& a, GetBlockLocationsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBlockLocationsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBlockLocationsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBlockLocationsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetBlockLocationsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetBlockLocationsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetBlockLocationsRequest& from) {
    GetBlockLocationsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBlockLocationsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ClientNamenode.GetBlockLocationsRequest";
  }
  protected:
  explicit GetBlockLocationsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrcFieldNumber = 1,
    kOffsetFieldNumber = 2,
    kLengthFieldNumber = 3,
  };
  // string src = 1;
  void clear_src();
  const std::string& src() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_src(ArgT0&& arg0, ArgT... args);
  std::string* mutable_src();
  PROTOBUF_NODISCARD std::string* release_src();
  void set_allocated_src(std::string* src);
  private:
  const std::string& _internal_src() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_src(const std::string& value);
  std::string* _internal_mutable_src();
  public:

  // uint64 offset = 2;
  void clear_offset();
  uint64_t offset() const;
  void set_offset(uint64_t value);
  private:
  uint64_t _internal_offset() const;
  void _internal_set_offset(uint64_t value);
  public:

  // uint64 length = 3;
  void clear_length();
  uint64_t length() const;
  void set_length(uint64_t value);
  private:
  uint64_t _internal_length() const;
  void _internal_set_length(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:ClientNamenode.GetBlockLocationsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_;
    uint64_t offset_;
    uint64_t length_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ClientNamenode_2eproto;
};
// -------------------------------------------------------------------

class GetBlockLocationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ClientNamenode.GetBlockLocationResponse) */ {
 public:
  inline GetBlockLocationResponse() : GetBlockLocationResponse(nullptr) {}
  ~GetBlockLocationResponse() override;
  explicit PROTOBUF_CONSTEXPR GetBlockLocationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBlockLocationResponse(const GetBlockLocationResponse& from);
  GetBlockLocationResponse(GetBlockLocationResponse&& from) noexcept
    : GetBlockLocationResponse() {
    *this = ::std::move(from);
  }

  inline GetBlockLocationResponse& operator=(const GetBlockLocationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBlockLocationResponse& operator=(GetBlockLocationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBlockLocationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBlockLocationResponse* internal_default_instance() {
    return reinterpret_cast<const GetBlockLocationResponse*>(
               &_GetBlockLocationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(GetBlockLocationResponse& a, GetBlockLocationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBlockLocationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBlockLocationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBlockLocationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetBlockLocationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetBlockLocationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetBlockLocationResponse& from) {
    GetBlockLocationResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBlockLocationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ClientNamenode.GetBlockLocationResponse";
  }
  protected:
  explicit GetBlockLocationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationFieldNumber = 1,
  };
  // optional .LocatedBlocks location = 1;
  bool has_location() const;
  private:
  bool _internal_has_location() const;
  public:
  void clear_location();
  const ::LocatedBlocks& location() const;
  PROTOBUF_NODISCARD ::LocatedBlocks* release_location();
  ::LocatedBlocks* mutable_location();
  void set_allocated_location(::LocatedBlocks* location);
  private:
  const ::LocatedBlocks& _internal_location() const;
  ::LocatedBlocks* _internal_mutable_location();
  public:
  void unsafe_arena_set_allocated_location(
      ::LocatedBlocks* location);
  ::LocatedBlocks* unsafe_arena_release_location();

  // @@protoc_insertion_point(class_scope:ClientNamenode.GetBlockLocationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::LocatedBlocks* location_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ClientNamenode_2eproto;
};
// -------------------------------------------------------------------

class GetServerDefaultsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:ClientNamenode.GetServerDefaultsRequest) */ {
 public:
  inline GetServerDefaultsRequest() : GetServerDefaultsRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetServerDefaultsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetServerDefaultsRequest(const GetServerDefaultsRequest& from);
  GetServerDefaultsRequest(GetServerDefaultsRequest&& from) noexcept
    : GetServerDefaultsRequest() {
    *this = ::std::move(from);
  }

  inline GetServerDefaultsRequest& operator=(const GetServerDefaultsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetServerDefaultsRequest& operator=(GetServerDefaultsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetServerDefaultsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetServerDefaultsRequest* internal_default_instance() {
    return reinterpret_cast<const GetServerDefaultsRequest*>(
               &_GetServerDefaultsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GetServerDefaultsRequest& a, GetServerDefaultsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetServerDefaultsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetServerDefaultsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetServerDefaultsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetServerDefaultsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetServerDefaultsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetServerDefaultsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ClientNamenode.GetServerDefaultsRequest";
  }
  protected:
  explicit GetServerDefaultsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ClientNamenode.GetServerDefaultsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_ClientNamenode_2eproto;
};
// -------------------------------------------------------------------

class GetServerDefaultsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ClientNamenode.GetServerDefaultsResponse) */ {
 public:
  inline GetServerDefaultsResponse() : GetServerDefaultsResponse(nullptr) {}
  ~GetServerDefaultsResponse() override;
  explicit PROTOBUF_CONSTEXPR GetServerDefaultsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetServerDefaultsResponse(const GetServerDefaultsResponse& from);
  GetServerDefaultsResponse(GetServerDefaultsResponse&& from) noexcept
    : GetServerDefaultsResponse() {
    *this = ::std::move(from);
  }

  inline GetServerDefaultsResponse& operator=(const GetServerDefaultsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetServerDefaultsResponse& operator=(GetServerDefaultsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetServerDefaultsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetServerDefaultsResponse* internal_default_instance() {
    return reinterpret_cast<const GetServerDefaultsResponse*>(
               &_GetServerDefaultsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GetServerDefaultsResponse& a, GetServerDefaultsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetServerDefaultsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetServerDefaultsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetServerDefaultsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetServerDefaultsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetServerDefaultsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetServerDefaultsResponse& from) {
    GetServerDefaultsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetServerDefaultsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ClientNamenode.GetServerDefaultsResponse";
  }
  protected:
  explicit GetServerDefaultsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErverDefaultsFieldNumber = 1,
  };
  // .ServerDefaults erverDefaults = 1;
  bool has_erverdefaults() const;
  private:
  bool _internal_has_erverdefaults() const;
  public:
  void clear_erverdefaults();
  const ::ServerDefaults& erverdefaults() const;
  PROTOBUF_NODISCARD ::ServerDefaults* release_erverdefaults();
  ::ServerDefaults* mutable_erverdefaults();
  void set_allocated_erverdefaults(::ServerDefaults* erverdefaults);
  private:
  const ::ServerDefaults& _internal_erverdefaults() const;
  ::ServerDefaults* _internal_mutable_erverdefaults();
  public:
  void unsafe_arena_set_allocated_erverdefaults(
      ::ServerDefaults* erverdefaults);
  ::ServerDefaults* unsafe_arena_release_erverdefaults();

  // @@protoc_insertion_point(class_scope:ClientNamenode.GetServerDefaultsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::ServerDefaults* erverdefaults_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ClientNamenode_2eproto;
};
// -------------------------------------------------------------------

class CreateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ClientNamenode.CreateRequest) */ {
 public:
  inline CreateRequest() : CreateRequest(nullptr) {}
  ~CreateRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateRequest(const CreateRequest& from);
  CreateRequest(CreateRequest&& from) noexcept
    : CreateRequest() {
    *this = ::std::move(from);
  }

  inline CreateRequest& operator=(const CreateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateRequest& operator=(CreateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateRequest* internal_default_instance() {
    return reinterpret_cast<const CreateRequest*>(
               &_CreateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CreateRequest& a, CreateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateRequest& from) {
    CreateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ClientNamenode.CreateRequest";
  }
  protected:
  explicit CreateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrcFieldNumber = 1,
    kClientNameFieldNumber = 2,
    kPermissionFieldNumber = 4,
    kFlagFieldNumber = 3,
    kCreateParentFieldNumber = 5,
    kBlockSizeFieldNumber = 6,
  };
  // string src = 1;
  void clear_src();
  const std::string& src() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_src(ArgT0&& arg0, ArgT... args);
  std::string* mutable_src();
  PROTOBUF_NODISCARD std::string* release_src();
  void set_allocated_src(std::string* src);
  private:
  const std::string& _internal_src() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_src(const std::string& value);
  std::string* _internal_mutable_src();
  public:

  // string clientName = 2;
  void clear_clientname();
  const std::string& clientname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clientname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clientname();
  PROTOBUF_NODISCARD std::string* release_clientname();
  void set_allocated_clientname(std::string* clientname);
  private:
  const std::string& _internal_clientname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientname(const std::string& value);
  std::string* _internal_mutable_clientname();
  public:

  // .Permission permission = 4;
  bool has_permission() const;
  private:
  bool _internal_has_permission() const;
  public:
  void clear_permission();
  const ::Permission& permission() const;
  PROTOBUF_NODISCARD ::Permission* release_permission();
  ::Permission* mutable_permission();
  void set_allocated_permission(::Permission* permission);
  private:
  const ::Permission& _internal_permission() const;
  ::Permission* _internal_mutable_permission();
  public:
  void unsafe_arena_set_allocated_permission(
      ::Permission* permission);
  ::Permission* unsafe_arena_release_permission();

  // .ClientNamenode.CreateFlag flag = 3;
  void clear_flag();
  ::ClientNamenode::CreateFlag flag() const;
  void set_flag(::ClientNamenode::CreateFlag value);
  private:
  ::ClientNamenode::CreateFlag _internal_flag() const;
  void _internal_set_flag(::ClientNamenode::CreateFlag value);
  public:

  // bool createParent = 5;
  void clear_createparent();
  bool createparent() const;
  void set_createparent(bool value);
  private:
  bool _internal_createparent() const;
  void _internal_set_createparent(bool value);
  public:

  // uint64 blockSize = 6;
  void clear_blocksize();
  uint64_t blocksize() const;
  void set_blocksize(uint64_t value);
  private:
  uint64_t _internal_blocksize() const;
  void _internal_set_blocksize(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:ClientNamenode.CreateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientname_;
    ::Permission* permission_;
    int flag_;
    bool createparent_;
    uint64_t blocksize_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ClientNamenode_2eproto;
};
// -------------------------------------------------------------------

class CreateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ClientNamenode.CreateResponse) */ {
 public:
  inline CreateResponse() : CreateResponse(nullptr) {}
  ~CreateResponse() override;
  explicit PROTOBUF_CONSTEXPR CreateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateResponse(const CreateResponse& from);
  CreateResponse(CreateResponse&& from) noexcept
    : CreateResponse() {
    *this = ::std::move(from);
  }

  inline CreateResponse& operator=(const CreateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateResponse& operator=(CreateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateResponse* internal_default_instance() {
    return reinterpret_cast<const CreateResponse*>(
               &_CreateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CreateResponse& a, CreateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateResponse& from) {
    CreateResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ClientNamenode.CreateResponse";
  }
  protected:
  explicit CreateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // optional .FileStatus status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::FileStatus& status() const;
  PROTOBUF_NODISCARD ::FileStatus* release_status();
  ::FileStatus* mutable_status();
  void set_allocated_status(::FileStatus* status);
  private:
  const ::FileStatus& _internal_status() const;
  ::FileStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::FileStatus* status);
  ::FileStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:ClientNamenode.CreateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::FileStatus* status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ClientNamenode_2eproto;
};
// -------------------------------------------------------------------

class AppendRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ClientNamenode.AppendRequest) */ {
 public:
  inline AppendRequest() : AppendRequest(nullptr) {}
  ~AppendRequest() override;
  explicit PROTOBUF_CONSTEXPR AppendRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppendRequest(const AppendRequest& from);
  AppendRequest(AppendRequest&& from) noexcept
    : AppendRequest() {
    *this = ::std::move(from);
  }

  inline AppendRequest& operator=(const AppendRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppendRequest& operator=(AppendRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppendRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppendRequest* internal_default_instance() {
    return reinterpret_cast<const AppendRequest*>(
               &_AppendRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(AppendRequest& a, AppendRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AppendRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppendRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AppendRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AppendRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppendRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AppendRequest& from) {
    AppendRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppendRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ClientNamenode.AppendRequest";
  }
  protected:
  explicit AppendRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrcFieldNumber = 1,
    kClientNameFieldNumber = 2,
  };
  // string src = 1;
  void clear_src();
  const std::string& src() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_src(ArgT0&& arg0, ArgT... args);
  std::string* mutable_src();
  PROTOBUF_NODISCARD std::string* release_src();
  void set_allocated_src(std::string* src);
  private:
  const std::string& _internal_src() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_src(const std::string& value);
  std::string* _internal_mutable_src();
  public:

  // string clientName = 2;
  void clear_clientname();
  const std::string& clientname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clientname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clientname();
  PROTOBUF_NODISCARD std::string* release_clientname();
  void set_allocated_clientname(std::string* clientname);
  private:
  const std::string& _internal_clientname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientname(const std::string& value);
  std::string* _internal_mutable_clientname();
  public:

  // @@protoc_insertion_point(class_scope:ClientNamenode.AppendRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientname_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ClientNamenode_2eproto;
};
// -------------------------------------------------------------------

class AppendResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ClientNamenode.AppendResponse) */ {
 public:
  inline AppendResponse() : AppendResponse(nullptr) {}
  ~AppendResponse() override;
  explicit PROTOBUF_CONSTEXPR AppendResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppendResponse(const AppendResponse& from);
  AppendResponse(AppendResponse&& from) noexcept
    : AppendResponse() {
    *this = ::std::move(from);
  }

  inline AppendResponse& operator=(const AppendResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppendResponse& operator=(AppendResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppendResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppendResponse* internal_default_instance() {
    return reinterpret_cast<const AppendResponse*>(
               &_AppendResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(AppendResponse& a, AppendResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AppendResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppendResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AppendResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AppendResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppendResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AppendResponse& from) {
    AppendResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppendResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ClientNamenode.AppendResponse";
  }
  protected:
  explicit AppendResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockFieldNumber = 1,
  };
  // optional .LocatedBlock block = 1;
  bool has_block() const;
  private:
  bool _internal_has_block() const;
  public:
  void clear_block();
  const ::LocatedBlock& block() const;
  PROTOBUF_NODISCARD ::LocatedBlock* release_block();
  ::LocatedBlock* mutable_block();
  void set_allocated_block(::LocatedBlock* block);
  private:
  const ::LocatedBlock& _internal_block() const;
  ::LocatedBlock* _internal_mutable_block();
  public:
  void unsafe_arena_set_allocated_block(
      ::LocatedBlock* block);
  ::LocatedBlock* unsafe_arena_release_block();

  // @@protoc_insertion_point(class_scope:ClientNamenode.AppendResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::LocatedBlock* block_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ClientNamenode_2eproto;
};
// -------------------------------------------------------------------

class RenameRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ClientNamenode.RenameRequest) */ {
 public:
  inline RenameRequest() : RenameRequest(nullptr) {}
  ~RenameRequest() override;
  explicit PROTOBUF_CONSTEXPR RenameRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RenameRequest(const RenameRequest& from);
  RenameRequest(RenameRequest&& from) noexcept
    : RenameRequest() {
    *this = ::std::move(from);
  }

  inline RenameRequest& operator=(const RenameRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RenameRequest& operator=(RenameRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RenameRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RenameRequest* internal_default_instance() {
    return reinterpret_cast<const RenameRequest*>(
               &_RenameRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RenameRequest& a, RenameRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RenameRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RenameRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RenameRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RenameRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RenameRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RenameRequest& from) {
    RenameRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RenameRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ClientNamenode.RenameRequest";
  }
  protected:
  explicit RenameRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrcFieldNumber = 1,
    kDstFieldNumber = 2,
  };
  // string src = 1;
  void clear_src();
  const std::string& src() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_src(ArgT0&& arg0, ArgT... args);
  std::string* mutable_src();
  PROTOBUF_NODISCARD std::string* release_src();
  void set_allocated_src(std::string* src);
  private:
  const std::string& _internal_src() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_src(const std::string& value);
  std::string* _internal_mutable_src();
  public:

  // string dst = 2;
  void clear_dst();
  const std::string& dst() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dst(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dst();
  PROTOBUF_NODISCARD std::string* release_dst();
  void set_allocated_dst(std::string* dst);
  private:
  const std::string& _internal_dst() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dst(const std::string& value);
  std::string* _internal_mutable_dst();
  public:

  // @@protoc_insertion_point(class_scope:ClientNamenode.RenameRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dst_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ClientNamenode_2eproto;
};
// -------------------------------------------------------------------

class RenameResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ClientNamenode.RenameResponse) */ {
 public:
  inline RenameResponse() : RenameResponse(nullptr) {}
  ~RenameResponse() override;
  explicit PROTOBUF_CONSTEXPR RenameResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RenameResponse(const RenameResponse& from);
  RenameResponse(RenameResponse&& from) noexcept
    : RenameResponse() {
    *this = ::std::move(from);
  }

  inline RenameResponse& operator=(const RenameResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RenameResponse& operator=(RenameResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RenameResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RenameResponse* internal_default_instance() {
    return reinterpret_cast<const RenameResponse*>(
               &_RenameResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(RenameResponse& a, RenameResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RenameResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RenameResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RenameResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RenameResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RenameResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RenameResponse& from) {
    RenameResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RenameResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ClientNamenode.RenameResponse";
  }
  protected:
  explicit RenameResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // bool result = 1;
  void clear_result();
  bool result() const;
  void set_result(bool value);
  private:
  bool _internal_result() const;
  void _internal_set_result(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ClientNamenode.RenameResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ClientNamenode_2eproto;
};
// -------------------------------------------------------------------

class DeleteRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ClientNamenode.DeleteRequest) */ {
 public:
  inline DeleteRequest() : DeleteRequest(nullptr) {}
  ~DeleteRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteRequest(const DeleteRequest& from);
  DeleteRequest(DeleteRequest&& from) noexcept
    : DeleteRequest() {
    *this = ::std::move(from);
  }

  inline DeleteRequest& operator=(const DeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteRequest& operator=(DeleteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteRequest*>(
               &_DeleteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(DeleteRequest& a, DeleteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteRequest& from) {
    DeleteRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ClientNamenode.DeleteRequest";
  }
  protected:
  explicit DeleteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrcFieldNumber = 1,
    kRecursiveFieldNumber = 2,
  };
  // string src = 1;
  void clear_src();
  const std::string& src() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_src(ArgT0&& arg0, ArgT... args);
  std::string* mutable_src();
  PROTOBUF_NODISCARD std::string* release_src();
  void set_allocated_src(std::string* src);
  private:
  const std::string& _internal_src() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_src(const std::string& value);
  std::string* _internal_mutable_src();
  public:

  // bool recursive = 2;
  void clear_recursive();
  bool recursive() const;
  void set_recursive(bool value);
  private:
  bool _internal_recursive() const;
  void _internal_set_recursive(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ClientNamenode.DeleteRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_;
    bool recursive_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ClientNamenode_2eproto;
};
// -------------------------------------------------------------------

class DeleteResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ClientNamenode.DeleteResponse) */ {
 public:
  inline DeleteResponse() : DeleteResponse(nullptr) {}
  ~DeleteResponse() override;
  explicit PROTOBUF_CONSTEXPR DeleteResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteResponse(const DeleteResponse& from);
  DeleteResponse(DeleteResponse&& from) noexcept
    : DeleteResponse() {
    *this = ::std::move(from);
  }

  inline DeleteResponse& operator=(const DeleteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteResponse& operator=(DeleteResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteResponse*>(
               &_DeleteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(DeleteResponse& a, DeleteResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteResponse& from) {
    DeleteResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ClientNamenode.DeleteResponse";
  }
  protected:
  explicit DeleteResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // bool result = 1;
  void clear_result();
  bool result() const;
  void set_result(bool value);
  private:
  bool _internal_result() const;
  void _internal_set_result(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ClientNamenode.DeleteResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ClientNamenode_2eproto;
};
// -------------------------------------------------------------------

class SetPermissionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ClientNamenode.SetPermissionRequest) */ {
 public:
  inline SetPermissionRequest() : SetPermissionRequest(nullptr) {}
  ~SetPermissionRequest() override;
  explicit PROTOBUF_CONSTEXPR SetPermissionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetPermissionRequest(const SetPermissionRequest& from);
  SetPermissionRequest(SetPermissionRequest&& from) noexcept
    : SetPermissionRequest() {
    *this = ::std::move(from);
  }

  inline SetPermissionRequest& operator=(const SetPermissionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetPermissionRequest& operator=(SetPermissionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetPermissionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetPermissionRequest* internal_default_instance() {
    return reinterpret_cast<const SetPermissionRequest*>(
               &_SetPermissionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SetPermissionRequest& a, SetPermissionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetPermissionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetPermissionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetPermissionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetPermissionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetPermissionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetPermissionRequest& from) {
    SetPermissionRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetPermissionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ClientNamenode.SetPermissionRequest";
  }
  protected:
  explicit SetPermissionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrcFieldNumber = 1,
    kPermissionFieldNumber = 2,
  };
  // string src = 1;
  void clear_src();
  const std::string& src() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_src(ArgT0&& arg0, ArgT... args);
  std::string* mutable_src();
  PROTOBUF_NODISCARD std::string* release_src();
  void set_allocated_src(std::string* src);
  private:
  const std::string& _internal_src() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_src(const std::string& value);
  std::string* _internal_mutable_src();
  public:

  // .Permission permission = 2;
  bool has_permission() const;
  private:
  bool _internal_has_permission() const;
  public:
  void clear_permission();
  const ::Permission& permission() const;
  PROTOBUF_NODISCARD ::Permission* release_permission();
  ::Permission* mutable_permission();
  void set_allocated_permission(::Permission* permission);
  private:
  const ::Permission& _internal_permission() const;
  ::Permission* _internal_mutable_permission();
  public:
  void unsafe_arena_set_allocated_permission(
      ::Permission* permission);
  ::Permission* unsafe_arena_release_permission();

  // @@protoc_insertion_point(class_scope:ClientNamenode.SetPermissionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_;
    ::Permission* permission_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ClientNamenode_2eproto;
};
// -------------------------------------------------------------------

class SetPermissionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:ClientNamenode.SetPermissionResponse) */ {
 public:
  inline SetPermissionResponse() : SetPermissionResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SetPermissionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetPermissionResponse(const SetPermissionResponse& from);
  SetPermissionResponse(SetPermissionResponse&& from) noexcept
    : SetPermissionResponse() {
    *this = ::std::move(from);
  }

  inline SetPermissionResponse& operator=(const SetPermissionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetPermissionResponse& operator=(SetPermissionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetPermissionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetPermissionResponse* internal_default_instance() {
    return reinterpret_cast<const SetPermissionResponse*>(
               &_SetPermissionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SetPermissionResponse& a, SetPermissionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetPermissionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetPermissionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetPermissionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetPermissionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SetPermissionResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SetPermissionResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ClientNamenode.SetPermissionResponse";
  }
  protected:
  explicit SetPermissionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ClientNamenode.SetPermissionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_ClientNamenode_2eproto;
};
// -------------------------------------------------------------------

class SetOwnerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ClientNamenode.SetOwnerRequest) */ {
 public:
  inline SetOwnerRequest() : SetOwnerRequest(nullptr) {}
  ~SetOwnerRequest() override;
  explicit PROTOBUF_CONSTEXPR SetOwnerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetOwnerRequest(const SetOwnerRequest& from);
  SetOwnerRequest(SetOwnerRequest&& from) noexcept
    : SetOwnerRequest() {
    *this = ::std::move(from);
  }

  inline SetOwnerRequest& operator=(const SetOwnerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetOwnerRequest& operator=(SetOwnerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetOwnerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetOwnerRequest* internal_default_instance() {
    return reinterpret_cast<const SetOwnerRequest*>(
               &_SetOwnerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SetOwnerRequest& a, SetOwnerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetOwnerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetOwnerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetOwnerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetOwnerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetOwnerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetOwnerRequest& from) {
    SetOwnerRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetOwnerRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ClientNamenode.SetOwnerRequest";
  }
  protected:
  explicit SetOwnerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrcFieldNumber = 1,
    kUsernameFieldNumber = 2,
    kGroupnameFieldNumber = 3,
  };
  // string src = 1;
  void clear_src();
  const std::string& src() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_src(ArgT0&& arg0, ArgT... args);
  std::string* mutable_src();
  PROTOBUF_NODISCARD std::string* release_src();
  void set_allocated_src(std::string* src);
  private:
  const std::string& _internal_src() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_src(const std::string& value);
  std::string* _internal_mutable_src();
  public:

  // optional string username = 2;
  bool has_username() const;
  private:
  bool _internal_has_username() const;
  public:
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // optional string groupname = 3;
  bool has_groupname() const;
  private:
  bool _internal_has_groupname() const;
  public:
  void clear_groupname();
  const std::string& groupname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_groupname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_groupname();
  PROTOBUF_NODISCARD std::string* release_groupname();
  void set_allocated_groupname(std::string* groupname);
  private:
  const std::string& _internal_groupname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_groupname(const std::string& value);
  std::string* _internal_mutable_groupname();
  public:

  // @@protoc_insertion_point(class_scope:ClientNamenode.SetOwnerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr groupname_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ClientNamenode_2eproto;
};
// -------------------------------------------------------------------

class SetOwnerResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:ClientNamenode.SetOwnerResponse) */ {
 public:
  inline SetOwnerResponse() : SetOwnerResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SetOwnerResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetOwnerResponse(const SetOwnerResponse& from);
  SetOwnerResponse(SetOwnerResponse&& from) noexcept
    : SetOwnerResponse() {
    *this = ::std::move(from);
  }

  inline SetOwnerResponse& operator=(const SetOwnerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetOwnerResponse& operator=(SetOwnerResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetOwnerResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetOwnerResponse* internal_default_instance() {
    return reinterpret_cast<const SetOwnerResponse*>(
               &_SetOwnerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(SetOwnerResponse& a, SetOwnerResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetOwnerResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetOwnerResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetOwnerResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetOwnerResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SetOwnerResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SetOwnerResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ClientNamenode.SetOwnerResponse";
  }
  protected:
  explicit SetOwnerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ClientNamenode.SetOwnerResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_ClientNamenode_2eproto;
};
// -------------------------------------------------------------------

class AddBlockRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ClientNamenode.AddBlockRequest) */ {
 public:
  inline AddBlockRequest() : AddBlockRequest(nullptr) {}
  ~AddBlockRequest() override;
  explicit PROTOBUF_CONSTEXPR AddBlockRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddBlockRequest(const AddBlockRequest& from);
  AddBlockRequest(AddBlockRequest&& from) noexcept
    : AddBlockRequest() {
    *this = ::std::move(from);
  }

  inline AddBlockRequest& operator=(const AddBlockRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddBlockRequest& operator=(AddBlockRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddBlockRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddBlockRequest* internal_default_instance() {
    return reinterpret_cast<const AddBlockRequest*>(
               &_AddBlockRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(AddBlockRequest& a, AddBlockRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AddBlockRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddBlockRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddBlockRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddBlockRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddBlockRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddBlockRequest& from) {
    AddBlockRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddBlockRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ClientNamenode.AddBlockRequest";
  }
  protected:
  explicit AddBlockRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExcludeNodesFieldNumber = 4,
    kFavoredNodesFieldNumber = 6,
    kSrcFieldNumber = 1,
    kClientNameFieldNumber = 2,
    kFileIdFieldNumber = 5,
  };
  // repeated .DatanodeInfo excludeNodes = 4;
  int excludenodes_size() const;
  private:
  int _internal_excludenodes_size() const;
  public:
  void clear_excludenodes();
  ::DatanodeInfo* mutable_excludenodes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DatanodeInfo >*
      mutable_excludenodes();
  private:
  const ::DatanodeInfo& _internal_excludenodes(int index) const;
  ::DatanodeInfo* _internal_add_excludenodes();
  public:
  const ::DatanodeInfo& excludenodes(int index) const;
  ::DatanodeInfo* add_excludenodes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DatanodeInfo >&
      excludenodes() const;

  // repeated string favoredNodes = 6;
  int favorednodes_size() const;
  private:
  int _internal_favorednodes_size() const;
  public:
  void clear_favorednodes();
  const std::string& favorednodes(int index) const;
  std::string* mutable_favorednodes(int index);
  void set_favorednodes(int index, const std::string& value);
  void set_favorednodes(int index, std::string&& value);
  void set_favorednodes(int index, const char* value);
  void set_favorednodes(int index, const char* value, size_t size);
  std::string* add_favorednodes();
  void add_favorednodes(const std::string& value);
  void add_favorednodes(std::string&& value);
  void add_favorednodes(const char* value);
  void add_favorednodes(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& favorednodes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_favorednodes();
  private:
  const std::string& _internal_favorednodes(int index) const;
  std::string* _internal_add_favorednodes();
  public:

  // string src = 1;
  void clear_src();
  const std::string& src() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_src(ArgT0&& arg0, ArgT... args);
  std::string* mutable_src();
  PROTOBUF_NODISCARD std::string* release_src();
  void set_allocated_src(std::string* src);
  private:
  const std::string& _internal_src() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_src(const std::string& value);
  std::string* _internal_mutable_src();
  public:

  // string clientName = 2;
  void clear_clientname();
  const std::string& clientname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clientname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clientname();
  PROTOBUF_NODISCARD std::string* release_clientname();
  void set_allocated_clientname(std::string* clientname);
  private:
  const std::string& _internal_clientname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientname(const std::string& value);
  std::string* _internal_mutable_clientname();
  public:

  // optional uint64 fileId = 5;
  bool has_fileid() const;
  private:
  bool _internal_has_fileid() const;
  public:
  void clear_fileid();
  uint64_t fileid() const;
  void set_fileid(uint64_t value);
  private:
  uint64_t _internal_fileid() const;
  void _internal_set_fileid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:ClientNamenode.AddBlockRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DatanodeInfo > excludenodes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> favorednodes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientname_;
    uint64_t fileid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ClientNamenode_2eproto;
};
// -------------------------------------------------------------------

class AddBlockResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ClientNamenode.AddBlockResponse) */ {
 public:
  inline AddBlockResponse() : AddBlockResponse(nullptr) {}
  ~AddBlockResponse() override;
  explicit PROTOBUF_CONSTEXPR AddBlockResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddBlockResponse(const AddBlockResponse& from);
  AddBlockResponse(AddBlockResponse&& from) noexcept
    : AddBlockResponse() {
    *this = ::std::move(from);
  }

  inline AddBlockResponse& operator=(const AddBlockResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddBlockResponse& operator=(AddBlockResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddBlockResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddBlockResponse* internal_default_instance() {
    return reinterpret_cast<const AddBlockResponse*>(
               &_AddBlockResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(AddBlockResponse& a, AddBlockResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AddBlockResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddBlockResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddBlockResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddBlockResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddBlockResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddBlockResponse& from) {
    AddBlockResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddBlockResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ClientNamenode.AddBlockResponse";
  }
  protected:
  explicit AddBlockResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockFieldNumber = 1,
  };
  // .LocatedBlock block = 1;
  bool has_block() const;
  private:
  bool _internal_has_block() const;
  public:
  void clear_block();
  const ::LocatedBlock& block() const;
  PROTOBUF_NODISCARD ::LocatedBlock* release_block();
  ::LocatedBlock* mutable_block();
  void set_allocated_block(::LocatedBlock* block);
  private:
  const ::LocatedBlock& _internal_block() const;
  ::LocatedBlock* _internal_mutable_block();
  public:
  void unsafe_arena_set_allocated_block(
      ::LocatedBlock* block);
  ::LocatedBlock* unsafe_arena_release_block();

  // @@protoc_insertion_point(class_scope:ClientNamenode.AddBlockResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::LocatedBlock* block_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ClientNamenode_2eproto;
};
// -------------------------------------------------------------------

class mkdirRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ClientNamenode.mkdirRequest) */ {
 public:
  inline mkdirRequest() : mkdirRequest(nullptr) {}
  ~mkdirRequest() override;
  explicit PROTOBUF_CONSTEXPR mkdirRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  mkdirRequest(const mkdirRequest& from);
  mkdirRequest(mkdirRequest&& from) noexcept
    : mkdirRequest() {
    *this = ::std::move(from);
  }

  inline mkdirRequest& operator=(const mkdirRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline mkdirRequest& operator=(mkdirRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const mkdirRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const mkdirRequest* internal_default_instance() {
    return reinterpret_cast<const mkdirRequest*>(
               &_mkdirRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(mkdirRequest& a, mkdirRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(mkdirRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(mkdirRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  mkdirRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<mkdirRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const mkdirRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const mkdirRequest& from) {
    mkdirRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(mkdirRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ClientNamenode.mkdirRequest";
  }
  protected:
  explicit mkdirRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrcFieldNumber = 1,
    kPermissionFieldNumber = 2,
    kCreateParentFieldNumber = 3,
  };
  // string src = 1;
  void clear_src();
  const std::string& src() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_src(ArgT0&& arg0, ArgT... args);
  std::string* mutable_src();
  PROTOBUF_NODISCARD std::string* release_src();
  void set_allocated_src(std::string* src);
  private:
  const std::string& _internal_src() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_src(const std::string& value);
  std::string* _internal_mutable_src();
  public:

  // .Permission permission = 2;
  bool has_permission() const;
  private:
  bool _internal_has_permission() const;
  public:
  void clear_permission();
  const ::Permission& permission() const;
  PROTOBUF_NODISCARD ::Permission* release_permission();
  ::Permission* mutable_permission();
  void set_allocated_permission(::Permission* permission);
  private:
  const ::Permission& _internal_permission() const;
  ::Permission* _internal_mutable_permission();
  public:
  void unsafe_arena_set_allocated_permission(
      ::Permission* permission);
  ::Permission* unsafe_arena_release_permission();

  // bool createParent = 3;
  void clear_createparent();
  bool createparent() const;
  void set_createparent(bool value);
  private:
  bool _internal_createparent() const;
  void _internal_set_createparent(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ClientNamenode.mkdirRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_;
    ::Permission* permission_;
    bool createparent_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ClientNamenode_2eproto;
};
// -------------------------------------------------------------------

class mkdirResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ClientNamenode.mkdirResponse) */ {
 public:
  inline mkdirResponse() : mkdirResponse(nullptr) {}
  ~mkdirResponse() override;
  explicit PROTOBUF_CONSTEXPR mkdirResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  mkdirResponse(const mkdirResponse& from);
  mkdirResponse(mkdirResponse&& from) noexcept
    : mkdirResponse() {
    *this = ::std::move(from);
  }

  inline mkdirResponse& operator=(const mkdirResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline mkdirResponse& operator=(mkdirResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const mkdirResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const mkdirResponse* internal_default_instance() {
    return reinterpret_cast<const mkdirResponse*>(
               &_mkdirResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(mkdirResponse& a, mkdirResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(mkdirResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(mkdirResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  mkdirResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<mkdirResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const mkdirResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const mkdirResponse& from) {
    mkdirResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(mkdirResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ClientNamenode.mkdirResponse";
  }
  protected:
  explicit mkdirResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsSuccessFieldNumber = 1,
  };
  // bool isSuccess = 1;
  void clear_issuccess();
  bool issuccess() const;
  void set_issuccess(bool value);
  private:
  bool _internal_issuccess() const;
  void _internal_set_issuccess(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ClientNamenode.mkdirResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool issuccess_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ClientNamenode_2eproto;
};
// -------------------------------------------------------------------

class GetListingRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ClientNamenode.GetListingRequest) */ {
 public:
  inline GetListingRequest() : GetListingRequest(nullptr) {}
  ~GetListingRequest() override;
  explicit PROTOBUF_CONSTEXPR GetListingRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetListingRequest(const GetListingRequest& from);
  GetListingRequest(GetListingRequest&& from) noexcept
    : GetListingRequest() {
    *this = ::std::move(from);
  }

  inline GetListingRequest& operator=(const GetListingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetListingRequest& operator=(GetListingRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetListingRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetListingRequest* internal_default_instance() {
    return reinterpret_cast<const GetListingRequest*>(
               &_GetListingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(GetListingRequest& a, GetListingRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetListingRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetListingRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetListingRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetListingRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetListingRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetListingRequest& from) {
    GetListingRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetListingRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ClientNamenode.GetListingRequest";
  }
  protected:
  explicit GetListingRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrcFieldNumber = 1,
    kStartAfterFieldNumber = 2,
    kNeedLocationFieldNumber = 3,
  };
  // string src = 1;
  void clear_src();
  const std::string& src() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_src(ArgT0&& arg0, ArgT... args);
  std::string* mutable_src();
  PROTOBUF_NODISCARD std::string* release_src();
  void set_allocated_src(std::string* src);
  private:
  const std::string& _internal_src() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_src(const std::string& value);
  std::string* _internal_mutable_src();
  public:

  // bytes startAfter = 2;
  void clear_startafter();
  const std::string& startafter() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_startafter(ArgT0&& arg0, ArgT... args);
  std::string* mutable_startafter();
  PROTOBUF_NODISCARD std::string* release_startafter();
  void set_allocated_startafter(std::string* startafter);
  private:
  const std::string& _internal_startafter() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_startafter(const std::string& value);
  std::string* _internal_mutable_startafter();
  public:

  // bool needLocation = 3;
  void clear_needlocation();
  bool needlocation() const;
  void set_needlocation(bool value);
  private:
  bool _internal_needlocation() const;
  void _internal_set_needlocation(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ClientNamenode.GetListingRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr startafter_;
    bool needlocation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ClientNamenode_2eproto;
};
// -------------------------------------------------------------------

class GetListingResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ClientNamenode.GetListingResponse) */ {
 public:
  inline GetListingResponse() : GetListingResponse(nullptr) {}
  ~GetListingResponse() override;
  explicit PROTOBUF_CONSTEXPR GetListingResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetListingResponse(const GetListingResponse& from);
  GetListingResponse(GetListingResponse&& from) noexcept
    : GetListingResponse() {
    *this = ::std::move(from);
  }

  inline GetListingResponse& operator=(const GetListingResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetListingResponse& operator=(GetListingResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetListingResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetListingResponse* internal_default_instance() {
    return reinterpret_cast<const GetListingResponse*>(
               &_GetListingResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(GetListingResponse& a, GetListingResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetListingResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetListingResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetListingResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetListingResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetListingResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetListingResponse& from) {
    GetListingResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetListingResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ClientNamenode.GetListingResponse";
  }
  protected:
  explicit GetListingResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDirListFieldNumber = 1,
  };
  // optional .DirectoryListing dirList = 1;
  bool has_dirlist() const;
  private:
  bool _internal_has_dirlist() const;
  public:
  void clear_dirlist();
  const ::DirectoryListing& dirlist() const;
  PROTOBUF_NODISCARD ::DirectoryListing* release_dirlist();
  ::DirectoryListing* mutable_dirlist();
  void set_allocated_dirlist(::DirectoryListing* dirlist);
  private:
  const ::DirectoryListing& _internal_dirlist() const;
  ::DirectoryListing* _internal_mutable_dirlist();
  public:
  void unsafe_arena_set_allocated_dirlist(
      ::DirectoryListing* dirlist);
  ::DirectoryListing* unsafe_arena_release_dirlist();

  // @@protoc_insertion_point(class_scope:ClientNamenode.GetListingResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::DirectoryListing* dirlist_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ClientNamenode_2eproto;
};
// -------------------------------------------------------------------

class RenewLeaseRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ClientNamenode.RenewLeaseRequest) */ {
 public:
  inline RenewLeaseRequest() : RenewLeaseRequest(nullptr) {}
  ~RenewLeaseRequest() override;
  explicit PROTOBUF_CONSTEXPR RenewLeaseRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RenewLeaseRequest(const RenewLeaseRequest& from);
  RenewLeaseRequest(RenewLeaseRequest&& from) noexcept
    : RenewLeaseRequest() {
    *this = ::std::move(from);
  }

  inline RenewLeaseRequest& operator=(const RenewLeaseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RenewLeaseRequest& operator=(RenewLeaseRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RenewLeaseRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RenewLeaseRequest* internal_default_instance() {
    return reinterpret_cast<const RenewLeaseRequest*>(
               &_RenewLeaseRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(RenewLeaseRequest& a, RenewLeaseRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RenewLeaseRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RenewLeaseRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RenewLeaseRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RenewLeaseRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RenewLeaseRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RenewLeaseRequest& from) {
    RenewLeaseRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RenewLeaseRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ClientNamenode.RenewLeaseRequest";
  }
  protected:
  explicit RenewLeaseRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientNameFieldNumber = 1,
  };
  // string ClientName = 1;
  void clear_clientname();
  const std::string& clientname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clientname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clientname();
  PROTOBUF_NODISCARD std::string* release_clientname();
  void set_allocated_clientname(std::string* clientname);
  private:
  const std::string& _internal_clientname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientname(const std::string& value);
  std::string* _internal_mutable_clientname();
  public:

  // @@protoc_insertion_point(class_scope:ClientNamenode.RenewLeaseRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientname_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ClientNamenode_2eproto;
};
// -------------------------------------------------------------------

class RenewLeaseResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:ClientNamenode.RenewLeaseResponse) */ {
 public:
  inline RenewLeaseResponse() : RenewLeaseResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR RenewLeaseResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RenewLeaseResponse(const RenewLeaseResponse& from);
  RenewLeaseResponse(RenewLeaseResponse&& from) noexcept
    : RenewLeaseResponse() {
    *this = ::std::move(from);
  }

  inline RenewLeaseResponse& operator=(const RenewLeaseResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RenewLeaseResponse& operator=(RenewLeaseResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RenewLeaseResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RenewLeaseResponse* internal_default_instance() {
    return reinterpret_cast<const RenewLeaseResponse*>(
               &_RenewLeaseResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(RenewLeaseResponse& a, RenewLeaseResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RenewLeaseResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RenewLeaseResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RenewLeaseResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RenewLeaseResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const RenewLeaseResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const RenewLeaseResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ClientNamenode.RenewLeaseResponse";
  }
  protected:
  explicit RenewLeaseResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ClientNamenode.RenewLeaseResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_ClientNamenode_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GetBlockLocationsRequest

// string src = 1;
inline void GetBlockLocationsRequest::clear_src() {
  _impl_.src_.ClearToEmpty();
}
inline const std::string& GetBlockLocationsRequest::src() const {
  // @@protoc_insertion_point(field_get:ClientNamenode.GetBlockLocationsRequest.src)
  return _internal_src();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetBlockLocationsRequest::set_src(ArgT0&& arg0, ArgT... args) {
 
 _impl_.src_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ClientNamenode.GetBlockLocationsRequest.src)
}
inline std::string* GetBlockLocationsRequest::mutable_src() {
  std::string* _s = _internal_mutable_src();
  // @@protoc_insertion_point(field_mutable:ClientNamenode.GetBlockLocationsRequest.src)
  return _s;
}
inline const std::string& GetBlockLocationsRequest::_internal_src() const {
  return _impl_.src_.Get();
}
inline void GetBlockLocationsRequest::_internal_set_src(const std::string& value) {
  
  _impl_.src_.Set(value, GetArenaForAllocation());
}
inline std::string* GetBlockLocationsRequest::_internal_mutable_src() {
  
  return _impl_.src_.Mutable(GetArenaForAllocation());
}
inline std::string* GetBlockLocationsRequest::release_src() {
  // @@protoc_insertion_point(field_release:ClientNamenode.GetBlockLocationsRequest.src)
  return _impl_.src_.Release();
}
inline void GetBlockLocationsRequest::set_allocated_src(std::string* src) {
  if (src != nullptr) {
    
  } else {
    
  }
  _impl_.src_.SetAllocated(src, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.src_.IsDefault()) {
    _impl_.src_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ClientNamenode.GetBlockLocationsRequest.src)
}

// uint64 offset = 2;
inline void GetBlockLocationsRequest::clear_offset() {
  _impl_.offset_ = uint64_t{0u};
}
inline uint64_t GetBlockLocationsRequest::_internal_offset() const {
  return _impl_.offset_;
}
inline uint64_t GetBlockLocationsRequest::offset() const {
  // @@protoc_insertion_point(field_get:ClientNamenode.GetBlockLocationsRequest.offset)
  return _internal_offset();
}
inline void GetBlockLocationsRequest::_internal_set_offset(uint64_t value) {
  
  _impl_.offset_ = value;
}
inline void GetBlockLocationsRequest::set_offset(uint64_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:ClientNamenode.GetBlockLocationsRequest.offset)
}

// uint64 length = 3;
inline void GetBlockLocationsRequest::clear_length() {
  _impl_.length_ = uint64_t{0u};
}
inline uint64_t GetBlockLocationsRequest::_internal_length() const {
  return _impl_.length_;
}
inline uint64_t GetBlockLocationsRequest::length() const {
  // @@protoc_insertion_point(field_get:ClientNamenode.GetBlockLocationsRequest.length)
  return _internal_length();
}
inline void GetBlockLocationsRequest::_internal_set_length(uint64_t value) {
  
  _impl_.length_ = value;
}
inline void GetBlockLocationsRequest::set_length(uint64_t value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:ClientNamenode.GetBlockLocationsRequest.length)
}

// -------------------------------------------------------------------

// GetBlockLocationResponse

// optional .LocatedBlocks location = 1;
inline bool GetBlockLocationResponse::_internal_has_location() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.location_ != nullptr);
  return value;
}
inline bool GetBlockLocationResponse::has_location() const {
  return _internal_has_location();
}
inline const ::LocatedBlocks& GetBlockLocationResponse::_internal_location() const {
  const ::LocatedBlocks* p = _impl_.location_;
  return p != nullptr ? *p : reinterpret_cast<const ::LocatedBlocks&>(
      ::_LocatedBlocks_default_instance_);
}
inline const ::LocatedBlocks& GetBlockLocationResponse::location() const {
  // @@protoc_insertion_point(field_get:ClientNamenode.GetBlockLocationResponse.location)
  return _internal_location();
}
inline void GetBlockLocationResponse::unsafe_arena_set_allocated_location(
    ::LocatedBlocks* location) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.location_);
  }
  _impl_.location_ = location;
  if (location) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ClientNamenode.GetBlockLocationResponse.location)
}
inline ::LocatedBlocks* GetBlockLocationResponse::release_location() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::LocatedBlocks* temp = _impl_.location_;
  _impl_.location_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::LocatedBlocks* GetBlockLocationResponse::unsafe_arena_release_location() {
  // @@protoc_insertion_point(field_release:ClientNamenode.GetBlockLocationResponse.location)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::LocatedBlocks* temp = _impl_.location_;
  _impl_.location_ = nullptr;
  return temp;
}
inline ::LocatedBlocks* GetBlockLocationResponse::_internal_mutable_location() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.location_ == nullptr) {
    auto* p = CreateMaybeMessage<::LocatedBlocks>(GetArenaForAllocation());
    _impl_.location_ = p;
  }
  return _impl_.location_;
}
inline ::LocatedBlocks* GetBlockLocationResponse::mutable_location() {
  ::LocatedBlocks* _msg = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:ClientNamenode.GetBlockLocationResponse.location)
  return _msg;
}
inline void GetBlockLocationResponse::set_allocated_location(::LocatedBlocks* location) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.location_);
  }
  if (location) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(location));
    if (message_arena != submessage_arena) {
      location = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.location_ = location;
  // @@protoc_insertion_point(field_set_allocated:ClientNamenode.GetBlockLocationResponse.location)
}

// -------------------------------------------------------------------

// GetServerDefaultsRequest

// -------------------------------------------------------------------

// GetServerDefaultsResponse

// .ServerDefaults erverDefaults = 1;
inline bool GetServerDefaultsResponse::_internal_has_erverdefaults() const {
  return this != internal_default_instance() && _impl_.erverdefaults_ != nullptr;
}
inline bool GetServerDefaultsResponse::has_erverdefaults() const {
  return _internal_has_erverdefaults();
}
inline const ::ServerDefaults& GetServerDefaultsResponse::_internal_erverdefaults() const {
  const ::ServerDefaults* p = _impl_.erverdefaults_;
  return p != nullptr ? *p : reinterpret_cast<const ::ServerDefaults&>(
      ::_ServerDefaults_default_instance_);
}
inline const ::ServerDefaults& GetServerDefaultsResponse::erverdefaults() const {
  // @@protoc_insertion_point(field_get:ClientNamenode.GetServerDefaultsResponse.erverDefaults)
  return _internal_erverdefaults();
}
inline void GetServerDefaultsResponse::unsafe_arena_set_allocated_erverdefaults(
    ::ServerDefaults* erverdefaults) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.erverdefaults_);
  }
  _impl_.erverdefaults_ = erverdefaults;
  if (erverdefaults) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ClientNamenode.GetServerDefaultsResponse.erverDefaults)
}
inline ::ServerDefaults* GetServerDefaultsResponse::release_erverdefaults() {
  
  ::ServerDefaults* temp = _impl_.erverdefaults_;
  _impl_.erverdefaults_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ServerDefaults* GetServerDefaultsResponse::unsafe_arena_release_erverdefaults() {
  // @@protoc_insertion_point(field_release:ClientNamenode.GetServerDefaultsResponse.erverDefaults)
  
  ::ServerDefaults* temp = _impl_.erverdefaults_;
  _impl_.erverdefaults_ = nullptr;
  return temp;
}
inline ::ServerDefaults* GetServerDefaultsResponse::_internal_mutable_erverdefaults() {
  
  if (_impl_.erverdefaults_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerDefaults>(GetArenaForAllocation());
    _impl_.erverdefaults_ = p;
  }
  return _impl_.erverdefaults_;
}
inline ::ServerDefaults* GetServerDefaultsResponse::mutable_erverdefaults() {
  ::ServerDefaults* _msg = _internal_mutable_erverdefaults();
  // @@protoc_insertion_point(field_mutable:ClientNamenode.GetServerDefaultsResponse.erverDefaults)
  return _msg;
}
inline void GetServerDefaultsResponse::set_allocated_erverdefaults(::ServerDefaults* erverdefaults) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.erverdefaults_);
  }
  if (erverdefaults) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(erverdefaults));
    if (message_arena != submessage_arena) {
      erverdefaults = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, erverdefaults, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.erverdefaults_ = erverdefaults;
  // @@protoc_insertion_point(field_set_allocated:ClientNamenode.GetServerDefaultsResponse.erverDefaults)
}

// -------------------------------------------------------------------

// CreateRequest

// string src = 1;
inline void CreateRequest::clear_src() {
  _impl_.src_.ClearToEmpty();
}
inline const std::string& CreateRequest::src() const {
  // @@protoc_insertion_point(field_get:ClientNamenode.CreateRequest.src)
  return _internal_src();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateRequest::set_src(ArgT0&& arg0, ArgT... args) {
 
 _impl_.src_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ClientNamenode.CreateRequest.src)
}
inline std::string* CreateRequest::mutable_src() {
  std::string* _s = _internal_mutable_src();
  // @@protoc_insertion_point(field_mutable:ClientNamenode.CreateRequest.src)
  return _s;
}
inline const std::string& CreateRequest::_internal_src() const {
  return _impl_.src_.Get();
}
inline void CreateRequest::_internal_set_src(const std::string& value) {
  
  _impl_.src_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateRequest::_internal_mutable_src() {
  
  return _impl_.src_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateRequest::release_src() {
  // @@protoc_insertion_point(field_release:ClientNamenode.CreateRequest.src)
  return _impl_.src_.Release();
}
inline void CreateRequest::set_allocated_src(std::string* src) {
  if (src != nullptr) {
    
  } else {
    
  }
  _impl_.src_.SetAllocated(src, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.src_.IsDefault()) {
    _impl_.src_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ClientNamenode.CreateRequest.src)
}

// string clientName = 2;
inline void CreateRequest::clear_clientname() {
  _impl_.clientname_.ClearToEmpty();
}
inline const std::string& CreateRequest::clientname() const {
  // @@protoc_insertion_point(field_get:ClientNamenode.CreateRequest.clientName)
  return _internal_clientname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateRequest::set_clientname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.clientname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ClientNamenode.CreateRequest.clientName)
}
inline std::string* CreateRequest::mutable_clientname() {
  std::string* _s = _internal_mutable_clientname();
  // @@protoc_insertion_point(field_mutable:ClientNamenode.CreateRequest.clientName)
  return _s;
}
inline const std::string& CreateRequest::_internal_clientname() const {
  return _impl_.clientname_.Get();
}
inline void CreateRequest::_internal_set_clientname(const std::string& value) {
  
  _impl_.clientname_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateRequest::_internal_mutable_clientname() {
  
  return _impl_.clientname_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateRequest::release_clientname() {
  // @@protoc_insertion_point(field_release:ClientNamenode.CreateRequest.clientName)
  return _impl_.clientname_.Release();
}
inline void CreateRequest::set_allocated_clientname(std::string* clientname) {
  if (clientname != nullptr) {
    
  } else {
    
  }
  _impl_.clientname_.SetAllocated(clientname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.clientname_.IsDefault()) {
    _impl_.clientname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ClientNamenode.CreateRequest.clientName)
}

// .ClientNamenode.CreateFlag flag = 3;
inline void CreateRequest::clear_flag() {
  _impl_.flag_ = 0;
}
inline ::ClientNamenode::CreateFlag CreateRequest::_internal_flag() const {
  return static_cast< ::ClientNamenode::CreateFlag >(_impl_.flag_);
}
inline ::ClientNamenode::CreateFlag CreateRequest::flag() const {
  // @@protoc_insertion_point(field_get:ClientNamenode.CreateRequest.flag)
  return _internal_flag();
}
inline void CreateRequest::_internal_set_flag(::ClientNamenode::CreateFlag value) {
  
  _impl_.flag_ = value;
}
inline void CreateRequest::set_flag(::ClientNamenode::CreateFlag value) {
  _internal_set_flag(value);
  // @@protoc_insertion_point(field_set:ClientNamenode.CreateRequest.flag)
}

// .Permission permission = 4;
inline bool CreateRequest::_internal_has_permission() const {
  return this != internal_default_instance() && _impl_.permission_ != nullptr;
}
inline bool CreateRequest::has_permission() const {
  return _internal_has_permission();
}
inline const ::Permission& CreateRequest::_internal_permission() const {
  const ::Permission* p = _impl_.permission_;
  return p != nullptr ? *p : reinterpret_cast<const ::Permission&>(
      ::_Permission_default_instance_);
}
inline const ::Permission& CreateRequest::permission() const {
  // @@protoc_insertion_point(field_get:ClientNamenode.CreateRequest.permission)
  return _internal_permission();
}
inline void CreateRequest::unsafe_arena_set_allocated_permission(
    ::Permission* permission) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.permission_);
  }
  _impl_.permission_ = permission;
  if (permission) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ClientNamenode.CreateRequest.permission)
}
inline ::Permission* CreateRequest::release_permission() {
  
  ::Permission* temp = _impl_.permission_;
  _impl_.permission_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Permission* CreateRequest::unsafe_arena_release_permission() {
  // @@protoc_insertion_point(field_release:ClientNamenode.CreateRequest.permission)
  
  ::Permission* temp = _impl_.permission_;
  _impl_.permission_ = nullptr;
  return temp;
}
inline ::Permission* CreateRequest::_internal_mutable_permission() {
  
  if (_impl_.permission_ == nullptr) {
    auto* p = CreateMaybeMessage<::Permission>(GetArenaForAllocation());
    _impl_.permission_ = p;
  }
  return _impl_.permission_;
}
inline ::Permission* CreateRequest::mutable_permission() {
  ::Permission* _msg = _internal_mutable_permission();
  // @@protoc_insertion_point(field_mutable:ClientNamenode.CreateRequest.permission)
  return _msg;
}
inline void CreateRequest::set_allocated_permission(::Permission* permission) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.permission_);
  }
  if (permission) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(permission));
    if (message_arena != submessage_arena) {
      permission = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, permission, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.permission_ = permission;
  // @@protoc_insertion_point(field_set_allocated:ClientNamenode.CreateRequest.permission)
}

// bool createParent = 5;
inline void CreateRequest::clear_createparent() {
  _impl_.createparent_ = false;
}
inline bool CreateRequest::_internal_createparent() const {
  return _impl_.createparent_;
}
inline bool CreateRequest::createparent() const {
  // @@protoc_insertion_point(field_get:ClientNamenode.CreateRequest.createParent)
  return _internal_createparent();
}
inline void CreateRequest::_internal_set_createparent(bool value) {
  
  _impl_.createparent_ = value;
}
inline void CreateRequest::set_createparent(bool value) {
  _internal_set_createparent(value);
  // @@protoc_insertion_point(field_set:ClientNamenode.CreateRequest.createParent)
}

// uint64 blockSize = 6;
inline void CreateRequest::clear_blocksize() {
  _impl_.blocksize_ = uint64_t{0u};
}
inline uint64_t CreateRequest::_internal_blocksize() const {
  return _impl_.blocksize_;
}
inline uint64_t CreateRequest::blocksize() const {
  // @@protoc_insertion_point(field_get:ClientNamenode.CreateRequest.blockSize)
  return _internal_blocksize();
}
inline void CreateRequest::_internal_set_blocksize(uint64_t value) {
  
  _impl_.blocksize_ = value;
}
inline void CreateRequest::set_blocksize(uint64_t value) {
  _internal_set_blocksize(value);
  // @@protoc_insertion_point(field_set:ClientNamenode.CreateRequest.blockSize)
}

// -------------------------------------------------------------------

// CreateResponse

// optional .FileStatus status = 1;
inline bool CreateResponse::_internal_has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
  return value;
}
inline bool CreateResponse::has_status() const {
  return _internal_has_status();
}
inline const ::FileStatus& CreateResponse::_internal_status() const {
  const ::FileStatus* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::FileStatus&>(
      ::_FileStatus_default_instance_);
}
inline const ::FileStatus& CreateResponse::status() const {
  // @@protoc_insertion_point(field_get:ClientNamenode.CreateResponse.status)
  return _internal_status();
}
inline void CreateResponse::unsafe_arena_set_allocated_status(
    ::FileStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ClientNamenode.CreateResponse.status)
}
inline ::FileStatus* CreateResponse::release_status() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::FileStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::FileStatus* CreateResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:ClientNamenode.CreateResponse.status)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::FileStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::FileStatus* CreateResponse::_internal_mutable_status() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::FileStatus>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::FileStatus* CreateResponse::mutable_status() {
  ::FileStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:ClientNamenode.CreateResponse.status)
  return _msg;
}
inline void CreateResponse::set_allocated_status(::FileStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:ClientNamenode.CreateResponse.status)
}

// -------------------------------------------------------------------

// AppendRequest

// string src = 1;
inline void AppendRequest::clear_src() {
  _impl_.src_.ClearToEmpty();
}
inline const std::string& AppendRequest::src() const {
  // @@protoc_insertion_point(field_get:ClientNamenode.AppendRequest.src)
  return _internal_src();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppendRequest::set_src(ArgT0&& arg0, ArgT... args) {
 
 _impl_.src_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ClientNamenode.AppendRequest.src)
}
inline std::string* AppendRequest::mutable_src() {
  std::string* _s = _internal_mutable_src();
  // @@protoc_insertion_point(field_mutable:ClientNamenode.AppendRequest.src)
  return _s;
}
inline const std::string& AppendRequest::_internal_src() const {
  return _impl_.src_.Get();
}
inline void AppendRequest::_internal_set_src(const std::string& value) {
  
  _impl_.src_.Set(value, GetArenaForAllocation());
}
inline std::string* AppendRequest::_internal_mutable_src() {
  
  return _impl_.src_.Mutable(GetArenaForAllocation());
}
inline std::string* AppendRequest::release_src() {
  // @@protoc_insertion_point(field_release:ClientNamenode.AppendRequest.src)
  return _impl_.src_.Release();
}
inline void AppendRequest::set_allocated_src(std::string* src) {
  if (src != nullptr) {
    
  } else {
    
  }
  _impl_.src_.SetAllocated(src, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.src_.IsDefault()) {
    _impl_.src_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ClientNamenode.AppendRequest.src)
}

// string clientName = 2;
inline void AppendRequest::clear_clientname() {
  _impl_.clientname_.ClearToEmpty();
}
inline const std::string& AppendRequest::clientname() const {
  // @@protoc_insertion_point(field_get:ClientNamenode.AppendRequest.clientName)
  return _internal_clientname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppendRequest::set_clientname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.clientname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ClientNamenode.AppendRequest.clientName)
}
inline std::string* AppendRequest::mutable_clientname() {
  std::string* _s = _internal_mutable_clientname();
  // @@protoc_insertion_point(field_mutable:ClientNamenode.AppendRequest.clientName)
  return _s;
}
inline const std::string& AppendRequest::_internal_clientname() const {
  return _impl_.clientname_.Get();
}
inline void AppendRequest::_internal_set_clientname(const std::string& value) {
  
  _impl_.clientname_.Set(value, GetArenaForAllocation());
}
inline std::string* AppendRequest::_internal_mutable_clientname() {
  
  return _impl_.clientname_.Mutable(GetArenaForAllocation());
}
inline std::string* AppendRequest::release_clientname() {
  // @@protoc_insertion_point(field_release:ClientNamenode.AppendRequest.clientName)
  return _impl_.clientname_.Release();
}
inline void AppendRequest::set_allocated_clientname(std::string* clientname) {
  if (clientname != nullptr) {
    
  } else {
    
  }
  _impl_.clientname_.SetAllocated(clientname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.clientname_.IsDefault()) {
    _impl_.clientname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ClientNamenode.AppendRequest.clientName)
}

// -------------------------------------------------------------------

// AppendResponse

// optional .LocatedBlock block = 1;
inline bool AppendResponse::_internal_has_block() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.block_ != nullptr);
  return value;
}
inline bool AppendResponse::has_block() const {
  return _internal_has_block();
}
inline const ::LocatedBlock& AppendResponse::_internal_block() const {
  const ::LocatedBlock* p = _impl_.block_;
  return p != nullptr ? *p : reinterpret_cast<const ::LocatedBlock&>(
      ::_LocatedBlock_default_instance_);
}
inline const ::LocatedBlock& AppendResponse::block() const {
  // @@protoc_insertion_point(field_get:ClientNamenode.AppendResponse.block)
  return _internal_block();
}
inline void AppendResponse::unsafe_arena_set_allocated_block(
    ::LocatedBlock* block) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.block_);
  }
  _impl_.block_ = block;
  if (block) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ClientNamenode.AppendResponse.block)
}
inline ::LocatedBlock* AppendResponse::release_block() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::LocatedBlock* temp = _impl_.block_;
  _impl_.block_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::LocatedBlock* AppendResponse::unsafe_arena_release_block() {
  // @@protoc_insertion_point(field_release:ClientNamenode.AppendResponse.block)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::LocatedBlock* temp = _impl_.block_;
  _impl_.block_ = nullptr;
  return temp;
}
inline ::LocatedBlock* AppendResponse::_internal_mutable_block() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.block_ == nullptr) {
    auto* p = CreateMaybeMessage<::LocatedBlock>(GetArenaForAllocation());
    _impl_.block_ = p;
  }
  return _impl_.block_;
}
inline ::LocatedBlock* AppendResponse::mutable_block() {
  ::LocatedBlock* _msg = _internal_mutable_block();
  // @@protoc_insertion_point(field_mutable:ClientNamenode.AppendResponse.block)
  return _msg;
}
inline void AppendResponse::set_allocated_block(::LocatedBlock* block) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.block_);
  }
  if (block) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(block));
    if (message_arena != submessage_arena) {
      block = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, block, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.block_ = block;
  // @@protoc_insertion_point(field_set_allocated:ClientNamenode.AppendResponse.block)
}

// -------------------------------------------------------------------

// RenameRequest

// string src = 1;
inline void RenameRequest::clear_src() {
  _impl_.src_.ClearToEmpty();
}
inline const std::string& RenameRequest::src() const {
  // @@protoc_insertion_point(field_get:ClientNamenode.RenameRequest.src)
  return _internal_src();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RenameRequest::set_src(ArgT0&& arg0, ArgT... args) {
 
 _impl_.src_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ClientNamenode.RenameRequest.src)
}
inline std::string* RenameRequest::mutable_src() {
  std::string* _s = _internal_mutable_src();
  // @@protoc_insertion_point(field_mutable:ClientNamenode.RenameRequest.src)
  return _s;
}
inline const std::string& RenameRequest::_internal_src() const {
  return _impl_.src_.Get();
}
inline void RenameRequest::_internal_set_src(const std::string& value) {
  
  _impl_.src_.Set(value, GetArenaForAllocation());
}
inline std::string* RenameRequest::_internal_mutable_src() {
  
  return _impl_.src_.Mutable(GetArenaForAllocation());
}
inline std::string* RenameRequest::release_src() {
  // @@protoc_insertion_point(field_release:ClientNamenode.RenameRequest.src)
  return _impl_.src_.Release();
}
inline void RenameRequest::set_allocated_src(std::string* src) {
  if (src != nullptr) {
    
  } else {
    
  }
  _impl_.src_.SetAllocated(src, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.src_.IsDefault()) {
    _impl_.src_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ClientNamenode.RenameRequest.src)
}

// string dst = 2;
inline void RenameRequest::clear_dst() {
  _impl_.dst_.ClearToEmpty();
}
inline const std::string& RenameRequest::dst() const {
  // @@protoc_insertion_point(field_get:ClientNamenode.RenameRequest.dst)
  return _internal_dst();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RenameRequest::set_dst(ArgT0&& arg0, ArgT... args) {
 
 _impl_.dst_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ClientNamenode.RenameRequest.dst)
}
inline std::string* RenameRequest::mutable_dst() {
  std::string* _s = _internal_mutable_dst();
  // @@protoc_insertion_point(field_mutable:ClientNamenode.RenameRequest.dst)
  return _s;
}
inline const std::string& RenameRequest::_internal_dst() const {
  return _impl_.dst_.Get();
}
inline void RenameRequest::_internal_set_dst(const std::string& value) {
  
  _impl_.dst_.Set(value, GetArenaForAllocation());
}
inline std::string* RenameRequest::_internal_mutable_dst() {
  
  return _impl_.dst_.Mutable(GetArenaForAllocation());
}
inline std::string* RenameRequest::release_dst() {
  // @@protoc_insertion_point(field_release:ClientNamenode.RenameRequest.dst)
  return _impl_.dst_.Release();
}
inline void RenameRequest::set_allocated_dst(std::string* dst) {
  if (dst != nullptr) {
    
  } else {
    
  }
  _impl_.dst_.SetAllocated(dst, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dst_.IsDefault()) {
    _impl_.dst_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ClientNamenode.RenameRequest.dst)
}

// -------------------------------------------------------------------

// RenameResponse

// bool result = 1;
inline void RenameResponse::clear_result() {
  _impl_.result_ = false;
}
inline bool RenameResponse::_internal_result() const {
  return _impl_.result_;
}
inline bool RenameResponse::result() const {
  // @@protoc_insertion_point(field_get:ClientNamenode.RenameResponse.result)
  return _internal_result();
}
inline void RenameResponse::_internal_set_result(bool value) {
  
  _impl_.result_ = value;
}
inline void RenameResponse::set_result(bool value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:ClientNamenode.RenameResponse.result)
}

// -------------------------------------------------------------------

// DeleteRequest

// string src = 1;
inline void DeleteRequest::clear_src() {
  _impl_.src_.ClearToEmpty();
}
inline const std::string& DeleteRequest::src() const {
  // @@protoc_insertion_point(field_get:ClientNamenode.DeleteRequest.src)
  return _internal_src();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteRequest::set_src(ArgT0&& arg0, ArgT... args) {
 
 _impl_.src_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ClientNamenode.DeleteRequest.src)
}
inline std::string* DeleteRequest::mutable_src() {
  std::string* _s = _internal_mutable_src();
  // @@protoc_insertion_point(field_mutable:ClientNamenode.DeleteRequest.src)
  return _s;
}
inline const std::string& DeleteRequest::_internal_src() const {
  return _impl_.src_.Get();
}
inline void DeleteRequest::_internal_set_src(const std::string& value) {
  
  _impl_.src_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteRequest::_internal_mutable_src() {
  
  return _impl_.src_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteRequest::release_src() {
  // @@protoc_insertion_point(field_release:ClientNamenode.DeleteRequest.src)
  return _impl_.src_.Release();
}
inline void DeleteRequest::set_allocated_src(std::string* src) {
  if (src != nullptr) {
    
  } else {
    
  }
  _impl_.src_.SetAllocated(src, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.src_.IsDefault()) {
    _impl_.src_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ClientNamenode.DeleteRequest.src)
}

// bool recursive = 2;
inline void DeleteRequest::clear_recursive() {
  _impl_.recursive_ = false;
}
inline bool DeleteRequest::_internal_recursive() const {
  return _impl_.recursive_;
}
inline bool DeleteRequest::recursive() const {
  // @@protoc_insertion_point(field_get:ClientNamenode.DeleteRequest.recursive)
  return _internal_recursive();
}
inline void DeleteRequest::_internal_set_recursive(bool value) {
  
  _impl_.recursive_ = value;
}
inline void DeleteRequest::set_recursive(bool value) {
  _internal_set_recursive(value);
  // @@protoc_insertion_point(field_set:ClientNamenode.DeleteRequest.recursive)
}

// -------------------------------------------------------------------

// DeleteResponse

// bool result = 1;
inline void DeleteResponse::clear_result() {
  _impl_.result_ = false;
}
inline bool DeleteResponse::_internal_result() const {
  return _impl_.result_;
}
inline bool DeleteResponse::result() const {
  // @@protoc_insertion_point(field_get:ClientNamenode.DeleteResponse.result)
  return _internal_result();
}
inline void DeleteResponse::_internal_set_result(bool value) {
  
  _impl_.result_ = value;
}
inline void DeleteResponse::set_result(bool value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:ClientNamenode.DeleteResponse.result)
}

// -------------------------------------------------------------------

// SetPermissionRequest

// string src = 1;
inline void SetPermissionRequest::clear_src() {
  _impl_.src_.ClearToEmpty();
}
inline const std::string& SetPermissionRequest::src() const {
  // @@protoc_insertion_point(field_get:ClientNamenode.SetPermissionRequest.src)
  return _internal_src();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetPermissionRequest::set_src(ArgT0&& arg0, ArgT... args) {
 
 _impl_.src_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ClientNamenode.SetPermissionRequest.src)
}
inline std::string* SetPermissionRequest::mutable_src() {
  std::string* _s = _internal_mutable_src();
  // @@protoc_insertion_point(field_mutable:ClientNamenode.SetPermissionRequest.src)
  return _s;
}
inline const std::string& SetPermissionRequest::_internal_src() const {
  return _impl_.src_.Get();
}
inline void SetPermissionRequest::_internal_set_src(const std::string& value) {
  
  _impl_.src_.Set(value, GetArenaForAllocation());
}
inline std::string* SetPermissionRequest::_internal_mutable_src() {
  
  return _impl_.src_.Mutable(GetArenaForAllocation());
}
inline std::string* SetPermissionRequest::release_src() {
  // @@protoc_insertion_point(field_release:ClientNamenode.SetPermissionRequest.src)
  return _impl_.src_.Release();
}
inline void SetPermissionRequest::set_allocated_src(std::string* src) {
  if (src != nullptr) {
    
  } else {
    
  }
  _impl_.src_.SetAllocated(src, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.src_.IsDefault()) {
    _impl_.src_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ClientNamenode.SetPermissionRequest.src)
}

// .Permission permission = 2;
inline bool SetPermissionRequest::_internal_has_permission() const {
  return this != internal_default_instance() && _impl_.permission_ != nullptr;
}
inline bool SetPermissionRequest::has_permission() const {
  return _internal_has_permission();
}
inline const ::Permission& SetPermissionRequest::_internal_permission() const {
  const ::Permission* p = _impl_.permission_;
  return p != nullptr ? *p : reinterpret_cast<const ::Permission&>(
      ::_Permission_default_instance_);
}
inline const ::Permission& SetPermissionRequest::permission() const {
  // @@protoc_insertion_point(field_get:ClientNamenode.SetPermissionRequest.permission)
  return _internal_permission();
}
inline void SetPermissionRequest::unsafe_arena_set_allocated_permission(
    ::Permission* permission) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.permission_);
  }
  _impl_.permission_ = permission;
  if (permission) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ClientNamenode.SetPermissionRequest.permission)
}
inline ::Permission* SetPermissionRequest::release_permission() {
  
  ::Permission* temp = _impl_.permission_;
  _impl_.permission_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Permission* SetPermissionRequest::unsafe_arena_release_permission() {
  // @@protoc_insertion_point(field_release:ClientNamenode.SetPermissionRequest.permission)
  
  ::Permission* temp = _impl_.permission_;
  _impl_.permission_ = nullptr;
  return temp;
}
inline ::Permission* SetPermissionRequest::_internal_mutable_permission() {
  
  if (_impl_.permission_ == nullptr) {
    auto* p = CreateMaybeMessage<::Permission>(GetArenaForAllocation());
    _impl_.permission_ = p;
  }
  return _impl_.permission_;
}
inline ::Permission* SetPermissionRequest::mutable_permission() {
  ::Permission* _msg = _internal_mutable_permission();
  // @@protoc_insertion_point(field_mutable:ClientNamenode.SetPermissionRequest.permission)
  return _msg;
}
inline void SetPermissionRequest::set_allocated_permission(::Permission* permission) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.permission_);
  }
  if (permission) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(permission));
    if (message_arena != submessage_arena) {
      permission = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, permission, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.permission_ = permission;
  // @@protoc_insertion_point(field_set_allocated:ClientNamenode.SetPermissionRequest.permission)
}

// -------------------------------------------------------------------

// SetPermissionResponse

// -------------------------------------------------------------------

// SetOwnerRequest

// string src = 1;
inline void SetOwnerRequest::clear_src() {
  _impl_.src_.ClearToEmpty();
}
inline const std::string& SetOwnerRequest::src() const {
  // @@protoc_insertion_point(field_get:ClientNamenode.SetOwnerRequest.src)
  return _internal_src();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetOwnerRequest::set_src(ArgT0&& arg0, ArgT... args) {
 
 _impl_.src_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ClientNamenode.SetOwnerRequest.src)
}
inline std::string* SetOwnerRequest::mutable_src() {
  std::string* _s = _internal_mutable_src();
  // @@protoc_insertion_point(field_mutable:ClientNamenode.SetOwnerRequest.src)
  return _s;
}
inline const std::string& SetOwnerRequest::_internal_src() const {
  return _impl_.src_.Get();
}
inline void SetOwnerRequest::_internal_set_src(const std::string& value) {
  
  _impl_.src_.Set(value, GetArenaForAllocation());
}
inline std::string* SetOwnerRequest::_internal_mutable_src() {
  
  return _impl_.src_.Mutable(GetArenaForAllocation());
}
inline std::string* SetOwnerRequest::release_src() {
  // @@protoc_insertion_point(field_release:ClientNamenode.SetOwnerRequest.src)
  return _impl_.src_.Release();
}
inline void SetOwnerRequest::set_allocated_src(std::string* src) {
  if (src != nullptr) {
    
  } else {
    
  }
  _impl_.src_.SetAllocated(src, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.src_.IsDefault()) {
    _impl_.src_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ClientNamenode.SetOwnerRequest.src)
}

// optional string username = 2;
inline bool SetOwnerRequest::_internal_has_username() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SetOwnerRequest::has_username() const {
  return _internal_has_username();
}
inline void SetOwnerRequest::clear_username() {
  _impl_.username_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SetOwnerRequest::username() const {
  // @@protoc_insertion_point(field_get:ClientNamenode.SetOwnerRequest.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetOwnerRequest::set_username(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ClientNamenode.SetOwnerRequest.username)
}
inline std::string* SetOwnerRequest::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:ClientNamenode.SetOwnerRequest.username)
  return _s;
}
inline const std::string& SetOwnerRequest::_internal_username() const {
  return _impl_.username_.Get();
}
inline void SetOwnerRequest::_internal_set_username(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* SetOwnerRequest::_internal_mutable_username() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* SetOwnerRequest::release_username() {
  // @@protoc_insertion_point(field_release:ClientNamenode.SetOwnerRequest.username)
  if (!_internal_has_username()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.username_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SetOwnerRequest::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ClientNamenode.SetOwnerRequest.username)
}

// optional string groupname = 3;
inline bool SetOwnerRequest::_internal_has_groupname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SetOwnerRequest::has_groupname() const {
  return _internal_has_groupname();
}
inline void SetOwnerRequest::clear_groupname() {
  _impl_.groupname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SetOwnerRequest::groupname() const {
  // @@protoc_insertion_point(field_get:ClientNamenode.SetOwnerRequest.groupname)
  return _internal_groupname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetOwnerRequest::set_groupname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.groupname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ClientNamenode.SetOwnerRequest.groupname)
}
inline std::string* SetOwnerRequest::mutable_groupname() {
  std::string* _s = _internal_mutable_groupname();
  // @@protoc_insertion_point(field_mutable:ClientNamenode.SetOwnerRequest.groupname)
  return _s;
}
inline const std::string& SetOwnerRequest::_internal_groupname() const {
  return _impl_.groupname_.Get();
}
inline void SetOwnerRequest::_internal_set_groupname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.groupname_.Set(value, GetArenaForAllocation());
}
inline std::string* SetOwnerRequest::_internal_mutable_groupname() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.groupname_.Mutable(GetArenaForAllocation());
}
inline std::string* SetOwnerRequest::release_groupname() {
  // @@protoc_insertion_point(field_release:ClientNamenode.SetOwnerRequest.groupname)
  if (!_internal_has_groupname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.groupname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.groupname_.IsDefault()) {
    _impl_.groupname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SetOwnerRequest::set_allocated_groupname(std::string* groupname) {
  if (groupname != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.groupname_.SetAllocated(groupname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.groupname_.IsDefault()) {
    _impl_.groupname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ClientNamenode.SetOwnerRequest.groupname)
}

// -------------------------------------------------------------------

// SetOwnerResponse

// -------------------------------------------------------------------

// AddBlockRequest

// string src = 1;
inline void AddBlockRequest::clear_src() {
  _impl_.src_.ClearToEmpty();
}
inline const std::string& AddBlockRequest::src() const {
  // @@protoc_insertion_point(field_get:ClientNamenode.AddBlockRequest.src)
  return _internal_src();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddBlockRequest::set_src(ArgT0&& arg0, ArgT... args) {
 
 _impl_.src_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ClientNamenode.AddBlockRequest.src)
}
inline std::string* AddBlockRequest::mutable_src() {
  std::string* _s = _internal_mutable_src();
  // @@protoc_insertion_point(field_mutable:ClientNamenode.AddBlockRequest.src)
  return _s;
}
inline const std::string& AddBlockRequest::_internal_src() const {
  return _impl_.src_.Get();
}
inline void AddBlockRequest::_internal_set_src(const std::string& value) {
  
  _impl_.src_.Set(value, GetArenaForAllocation());
}
inline std::string* AddBlockRequest::_internal_mutable_src() {
  
  return _impl_.src_.Mutable(GetArenaForAllocation());
}
inline std::string* AddBlockRequest::release_src() {
  // @@protoc_insertion_point(field_release:ClientNamenode.AddBlockRequest.src)
  return _impl_.src_.Release();
}
inline void AddBlockRequest::set_allocated_src(std::string* src) {
  if (src != nullptr) {
    
  } else {
    
  }
  _impl_.src_.SetAllocated(src, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.src_.IsDefault()) {
    _impl_.src_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ClientNamenode.AddBlockRequest.src)
}

// string clientName = 2;
inline void AddBlockRequest::clear_clientname() {
  _impl_.clientname_.ClearToEmpty();
}
inline const std::string& AddBlockRequest::clientname() const {
  // @@protoc_insertion_point(field_get:ClientNamenode.AddBlockRequest.clientName)
  return _internal_clientname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddBlockRequest::set_clientname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.clientname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ClientNamenode.AddBlockRequest.clientName)
}
inline std::string* AddBlockRequest::mutable_clientname() {
  std::string* _s = _internal_mutable_clientname();
  // @@protoc_insertion_point(field_mutable:ClientNamenode.AddBlockRequest.clientName)
  return _s;
}
inline const std::string& AddBlockRequest::_internal_clientname() const {
  return _impl_.clientname_.Get();
}
inline void AddBlockRequest::_internal_set_clientname(const std::string& value) {
  
  _impl_.clientname_.Set(value, GetArenaForAllocation());
}
inline std::string* AddBlockRequest::_internal_mutable_clientname() {
  
  return _impl_.clientname_.Mutable(GetArenaForAllocation());
}
inline std::string* AddBlockRequest::release_clientname() {
  // @@protoc_insertion_point(field_release:ClientNamenode.AddBlockRequest.clientName)
  return _impl_.clientname_.Release();
}
inline void AddBlockRequest::set_allocated_clientname(std::string* clientname) {
  if (clientname != nullptr) {
    
  } else {
    
  }
  _impl_.clientname_.SetAllocated(clientname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.clientname_.IsDefault()) {
    _impl_.clientname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ClientNamenode.AddBlockRequest.clientName)
}

// repeated .DatanodeInfo excludeNodes = 4;
inline int AddBlockRequest::_internal_excludenodes_size() const {
  return _impl_.excludenodes_.size();
}
inline int AddBlockRequest::excludenodes_size() const {
  return _internal_excludenodes_size();
}
inline ::DatanodeInfo* AddBlockRequest::mutable_excludenodes(int index) {
  // @@protoc_insertion_point(field_mutable:ClientNamenode.AddBlockRequest.excludeNodes)
  return _impl_.excludenodes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DatanodeInfo >*
AddBlockRequest::mutable_excludenodes() {
  // @@protoc_insertion_point(field_mutable_list:ClientNamenode.AddBlockRequest.excludeNodes)
  return &_impl_.excludenodes_;
}
inline const ::DatanodeInfo& AddBlockRequest::_internal_excludenodes(int index) const {
  return _impl_.excludenodes_.Get(index);
}
inline const ::DatanodeInfo& AddBlockRequest::excludenodes(int index) const {
  // @@protoc_insertion_point(field_get:ClientNamenode.AddBlockRequest.excludeNodes)
  return _internal_excludenodes(index);
}
inline ::DatanodeInfo* AddBlockRequest::_internal_add_excludenodes() {
  return _impl_.excludenodes_.Add();
}
inline ::DatanodeInfo* AddBlockRequest::add_excludenodes() {
  ::DatanodeInfo* _add = _internal_add_excludenodes();
  // @@protoc_insertion_point(field_add:ClientNamenode.AddBlockRequest.excludeNodes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DatanodeInfo >&
AddBlockRequest::excludenodes() const {
  // @@protoc_insertion_point(field_list:ClientNamenode.AddBlockRequest.excludeNodes)
  return _impl_.excludenodes_;
}

// optional uint64 fileId = 5;
inline bool AddBlockRequest::_internal_has_fileid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AddBlockRequest::has_fileid() const {
  return _internal_has_fileid();
}
inline void AddBlockRequest::clear_fileid() {
  _impl_.fileid_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t AddBlockRequest::_internal_fileid() const {
  return _impl_.fileid_;
}
inline uint64_t AddBlockRequest::fileid() const {
  // @@protoc_insertion_point(field_get:ClientNamenode.AddBlockRequest.fileId)
  return _internal_fileid();
}
inline void AddBlockRequest::_internal_set_fileid(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.fileid_ = value;
}
inline void AddBlockRequest::set_fileid(uint64_t value) {
  _internal_set_fileid(value);
  // @@protoc_insertion_point(field_set:ClientNamenode.AddBlockRequest.fileId)
}

// repeated string favoredNodes = 6;
inline int AddBlockRequest::_internal_favorednodes_size() const {
  return _impl_.favorednodes_.size();
}
inline int AddBlockRequest::favorednodes_size() const {
  return _internal_favorednodes_size();
}
inline void AddBlockRequest::clear_favorednodes() {
  _impl_.favorednodes_.Clear();
}
inline std::string* AddBlockRequest::add_favorednodes() {
  std::string* _s = _internal_add_favorednodes();
  // @@protoc_insertion_point(field_add_mutable:ClientNamenode.AddBlockRequest.favoredNodes)
  return _s;
}
inline const std::string& AddBlockRequest::_internal_favorednodes(int index) const {
  return _impl_.favorednodes_.Get(index);
}
inline const std::string& AddBlockRequest::favorednodes(int index) const {
  // @@protoc_insertion_point(field_get:ClientNamenode.AddBlockRequest.favoredNodes)
  return _internal_favorednodes(index);
}
inline std::string* AddBlockRequest::mutable_favorednodes(int index) {
  // @@protoc_insertion_point(field_mutable:ClientNamenode.AddBlockRequest.favoredNodes)
  return _impl_.favorednodes_.Mutable(index);
}
inline void AddBlockRequest::set_favorednodes(int index, const std::string& value) {
  _impl_.favorednodes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ClientNamenode.AddBlockRequest.favoredNodes)
}
inline void AddBlockRequest::set_favorednodes(int index, std::string&& value) {
  _impl_.favorednodes_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ClientNamenode.AddBlockRequest.favoredNodes)
}
inline void AddBlockRequest::set_favorednodes(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.favorednodes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ClientNamenode.AddBlockRequest.favoredNodes)
}
inline void AddBlockRequest::set_favorednodes(int index, const char* value, size_t size) {
  _impl_.favorednodes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ClientNamenode.AddBlockRequest.favoredNodes)
}
inline std::string* AddBlockRequest::_internal_add_favorednodes() {
  return _impl_.favorednodes_.Add();
}
inline void AddBlockRequest::add_favorednodes(const std::string& value) {
  _impl_.favorednodes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ClientNamenode.AddBlockRequest.favoredNodes)
}
inline void AddBlockRequest::add_favorednodes(std::string&& value) {
  _impl_.favorednodes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ClientNamenode.AddBlockRequest.favoredNodes)
}
inline void AddBlockRequest::add_favorednodes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.favorednodes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ClientNamenode.AddBlockRequest.favoredNodes)
}
inline void AddBlockRequest::add_favorednodes(const char* value, size_t size) {
  _impl_.favorednodes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ClientNamenode.AddBlockRequest.favoredNodes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AddBlockRequest::favorednodes() const {
  // @@protoc_insertion_point(field_list:ClientNamenode.AddBlockRequest.favoredNodes)
  return _impl_.favorednodes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AddBlockRequest::mutable_favorednodes() {
  // @@protoc_insertion_point(field_mutable_list:ClientNamenode.AddBlockRequest.favoredNodes)
  return &_impl_.favorednodes_;
}

// -------------------------------------------------------------------

// AddBlockResponse

// .LocatedBlock block = 1;
inline bool AddBlockResponse::_internal_has_block() const {
  return this != internal_default_instance() && _impl_.block_ != nullptr;
}
inline bool AddBlockResponse::has_block() const {
  return _internal_has_block();
}
inline const ::LocatedBlock& AddBlockResponse::_internal_block() const {
  const ::LocatedBlock* p = _impl_.block_;
  return p != nullptr ? *p : reinterpret_cast<const ::LocatedBlock&>(
      ::_LocatedBlock_default_instance_);
}
inline const ::LocatedBlock& AddBlockResponse::block() const {
  // @@protoc_insertion_point(field_get:ClientNamenode.AddBlockResponse.block)
  return _internal_block();
}
inline void AddBlockResponse::unsafe_arena_set_allocated_block(
    ::LocatedBlock* block) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.block_);
  }
  _impl_.block_ = block;
  if (block) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ClientNamenode.AddBlockResponse.block)
}
inline ::LocatedBlock* AddBlockResponse::release_block() {
  
  ::LocatedBlock* temp = _impl_.block_;
  _impl_.block_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::LocatedBlock* AddBlockResponse::unsafe_arena_release_block() {
  // @@protoc_insertion_point(field_release:ClientNamenode.AddBlockResponse.block)
  
  ::LocatedBlock* temp = _impl_.block_;
  _impl_.block_ = nullptr;
  return temp;
}
inline ::LocatedBlock* AddBlockResponse::_internal_mutable_block() {
  
  if (_impl_.block_ == nullptr) {
    auto* p = CreateMaybeMessage<::LocatedBlock>(GetArenaForAllocation());
    _impl_.block_ = p;
  }
  return _impl_.block_;
}
inline ::LocatedBlock* AddBlockResponse::mutable_block() {
  ::LocatedBlock* _msg = _internal_mutable_block();
  // @@protoc_insertion_point(field_mutable:ClientNamenode.AddBlockResponse.block)
  return _msg;
}
inline void AddBlockResponse::set_allocated_block(::LocatedBlock* block) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.block_);
  }
  if (block) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(block));
    if (message_arena != submessage_arena) {
      block = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, block, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.block_ = block;
  // @@protoc_insertion_point(field_set_allocated:ClientNamenode.AddBlockResponse.block)
}

// -------------------------------------------------------------------

// mkdirRequest

// string src = 1;
inline void mkdirRequest::clear_src() {
  _impl_.src_.ClearToEmpty();
}
inline const std::string& mkdirRequest::src() const {
  // @@protoc_insertion_point(field_get:ClientNamenode.mkdirRequest.src)
  return _internal_src();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void mkdirRequest::set_src(ArgT0&& arg0, ArgT... args) {
 
 _impl_.src_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ClientNamenode.mkdirRequest.src)
}
inline std::string* mkdirRequest::mutable_src() {
  std::string* _s = _internal_mutable_src();
  // @@protoc_insertion_point(field_mutable:ClientNamenode.mkdirRequest.src)
  return _s;
}
inline const std::string& mkdirRequest::_internal_src() const {
  return _impl_.src_.Get();
}
inline void mkdirRequest::_internal_set_src(const std::string& value) {
  
  _impl_.src_.Set(value, GetArenaForAllocation());
}
inline std::string* mkdirRequest::_internal_mutable_src() {
  
  return _impl_.src_.Mutable(GetArenaForAllocation());
}
inline std::string* mkdirRequest::release_src() {
  // @@protoc_insertion_point(field_release:ClientNamenode.mkdirRequest.src)
  return _impl_.src_.Release();
}
inline void mkdirRequest::set_allocated_src(std::string* src) {
  if (src != nullptr) {
    
  } else {
    
  }
  _impl_.src_.SetAllocated(src, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.src_.IsDefault()) {
    _impl_.src_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ClientNamenode.mkdirRequest.src)
}

// .Permission permission = 2;
inline bool mkdirRequest::_internal_has_permission() const {
  return this != internal_default_instance() && _impl_.permission_ != nullptr;
}
inline bool mkdirRequest::has_permission() const {
  return _internal_has_permission();
}
inline const ::Permission& mkdirRequest::_internal_permission() const {
  const ::Permission* p = _impl_.permission_;
  return p != nullptr ? *p : reinterpret_cast<const ::Permission&>(
      ::_Permission_default_instance_);
}
inline const ::Permission& mkdirRequest::permission() const {
  // @@protoc_insertion_point(field_get:ClientNamenode.mkdirRequest.permission)
  return _internal_permission();
}
inline void mkdirRequest::unsafe_arena_set_allocated_permission(
    ::Permission* permission) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.permission_);
  }
  _impl_.permission_ = permission;
  if (permission) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ClientNamenode.mkdirRequest.permission)
}
inline ::Permission* mkdirRequest::release_permission() {
  
  ::Permission* temp = _impl_.permission_;
  _impl_.permission_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Permission* mkdirRequest::unsafe_arena_release_permission() {
  // @@protoc_insertion_point(field_release:ClientNamenode.mkdirRequest.permission)
  
  ::Permission* temp = _impl_.permission_;
  _impl_.permission_ = nullptr;
  return temp;
}
inline ::Permission* mkdirRequest::_internal_mutable_permission() {
  
  if (_impl_.permission_ == nullptr) {
    auto* p = CreateMaybeMessage<::Permission>(GetArenaForAllocation());
    _impl_.permission_ = p;
  }
  return _impl_.permission_;
}
inline ::Permission* mkdirRequest::mutable_permission() {
  ::Permission* _msg = _internal_mutable_permission();
  // @@protoc_insertion_point(field_mutable:ClientNamenode.mkdirRequest.permission)
  return _msg;
}
inline void mkdirRequest::set_allocated_permission(::Permission* permission) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.permission_);
  }
  if (permission) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(permission));
    if (message_arena != submessage_arena) {
      permission = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, permission, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.permission_ = permission;
  // @@protoc_insertion_point(field_set_allocated:ClientNamenode.mkdirRequest.permission)
}

// bool createParent = 3;
inline void mkdirRequest::clear_createparent() {
  _impl_.createparent_ = false;
}
inline bool mkdirRequest::_internal_createparent() const {
  return _impl_.createparent_;
}
inline bool mkdirRequest::createparent() const {
  // @@protoc_insertion_point(field_get:ClientNamenode.mkdirRequest.createParent)
  return _internal_createparent();
}
inline void mkdirRequest::_internal_set_createparent(bool value) {
  
  _impl_.createparent_ = value;
}
inline void mkdirRequest::set_createparent(bool value) {
  _internal_set_createparent(value);
  // @@protoc_insertion_point(field_set:ClientNamenode.mkdirRequest.createParent)
}

// -------------------------------------------------------------------

// mkdirResponse

// bool isSuccess = 1;
inline void mkdirResponse::clear_issuccess() {
  _impl_.issuccess_ = false;
}
inline bool mkdirResponse::_internal_issuccess() const {
  return _impl_.issuccess_;
}
inline bool mkdirResponse::issuccess() const {
  // @@protoc_insertion_point(field_get:ClientNamenode.mkdirResponse.isSuccess)
  return _internal_issuccess();
}
inline void mkdirResponse::_internal_set_issuccess(bool value) {
  
  _impl_.issuccess_ = value;
}
inline void mkdirResponse::set_issuccess(bool value) {
  _internal_set_issuccess(value);
  // @@protoc_insertion_point(field_set:ClientNamenode.mkdirResponse.isSuccess)
}

// -------------------------------------------------------------------

// GetListingRequest

// string src = 1;
inline void GetListingRequest::clear_src() {
  _impl_.src_.ClearToEmpty();
}
inline const std::string& GetListingRequest::src() const {
  // @@protoc_insertion_point(field_get:ClientNamenode.GetListingRequest.src)
  return _internal_src();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetListingRequest::set_src(ArgT0&& arg0, ArgT... args) {
 
 _impl_.src_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ClientNamenode.GetListingRequest.src)
}
inline std::string* GetListingRequest::mutable_src() {
  std::string* _s = _internal_mutable_src();
  // @@protoc_insertion_point(field_mutable:ClientNamenode.GetListingRequest.src)
  return _s;
}
inline const std::string& GetListingRequest::_internal_src() const {
  return _impl_.src_.Get();
}
inline void GetListingRequest::_internal_set_src(const std::string& value) {
  
  _impl_.src_.Set(value, GetArenaForAllocation());
}
inline std::string* GetListingRequest::_internal_mutable_src() {
  
  return _impl_.src_.Mutable(GetArenaForAllocation());
}
inline std::string* GetListingRequest::release_src() {
  // @@protoc_insertion_point(field_release:ClientNamenode.GetListingRequest.src)
  return _impl_.src_.Release();
}
inline void GetListingRequest::set_allocated_src(std::string* src) {
  if (src != nullptr) {
    
  } else {
    
  }
  _impl_.src_.SetAllocated(src, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.src_.IsDefault()) {
    _impl_.src_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ClientNamenode.GetListingRequest.src)
}

// bytes startAfter = 2;
inline void GetListingRequest::clear_startafter() {
  _impl_.startafter_.ClearToEmpty();
}
inline const std::string& GetListingRequest::startafter() const {
  // @@protoc_insertion_point(field_get:ClientNamenode.GetListingRequest.startAfter)
  return _internal_startafter();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetListingRequest::set_startafter(ArgT0&& arg0, ArgT... args) {
 
 _impl_.startafter_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ClientNamenode.GetListingRequest.startAfter)
}
inline std::string* GetListingRequest::mutable_startafter() {
  std::string* _s = _internal_mutable_startafter();
  // @@protoc_insertion_point(field_mutable:ClientNamenode.GetListingRequest.startAfter)
  return _s;
}
inline const std::string& GetListingRequest::_internal_startafter() const {
  return _impl_.startafter_.Get();
}
inline void GetListingRequest::_internal_set_startafter(const std::string& value) {
  
  _impl_.startafter_.Set(value, GetArenaForAllocation());
}
inline std::string* GetListingRequest::_internal_mutable_startafter() {
  
  return _impl_.startafter_.Mutable(GetArenaForAllocation());
}
inline std::string* GetListingRequest::release_startafter() {
  // @@protoc_insertion_point(field_release:ClientNamenode.GetListingRequest.startAfter)
  return _impl_.startafter_.Release();
}
inline void GetListingRequest::set_allocated_startafter(std::string* startafter) {
  if (startafter != nullptr) {
    
  } else {
    
  }
  _impl_.startafter_.SetAllocated(startafter, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.startafter_.IsDefault()) {
    _impl_.startafter_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ClientNamenode.GetListingRequest.startAfter)
}

// bool needLocation = 3;
inline void GetListingRequest::clear_needlocation() {
  _impl_.needlocation_ = false;
}
inline bool GetListingRequest::_internal_needlocation() const {
  return _impl_.needlocation_;
}
inline bool GetListingRequest::needlocation() const {
  // @@protoc_insertion_point(field_get:ClientNamenode.GetListingRequest.needLocation)
  return _internal_needlocation();
}
inline void GetListingRequest::_internal_set_needlocation(bool value) {
  
  _impl_.needlocation_ = value;
}
inline void GetListingRequest::set_needlocation(bool value) {
  _internal_set_needlocation(value);
  // @@protoc_insertion_point(field_set:ClientNamenode.GetListingRequest.needLocation)
}

// -------------------------------------------------------------------

// GetListingResponse

// optional .DirectoryListing dirList = 1;
inline bool GetListingResponse::_internal_has_dirlist() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dirlist_ != nullptr);
  return value;
}
inline bool GetListingResponse::has_dirlist() const {
  return _internal_has_dirlist();
}
inline const ::DirectoryListing& GetListingResponse::_internal_dirlist() const {
  const ::DirectoryListing* p = _impl_.dirlist_;
  return p != nullptr ? *p : reinterpret_cast<const ::DirectoryListing&>(
      ::_DirectoryListing_default_instance_);
}
inline const ::DirectoryListing& GetListingResponse::dirlist() const {
  // @@protoc_insertion_point(field_get:ClientNamenode.GetListingResponse.dirList)
  return _internal_dirlist();
}
inline void GetListingResponse::unsafe_arena_set_allocated_dirlist(
    ::DirectoryListing* dirlist) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dirlist_);
  }
  _impl_.dirlist_ = dirlist;
  if (dirlist) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ClientNamenode.GetListingResponse.dirList)
}
inline ::DirectoryListing* GetListingResponse::release_dirlist() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DirectoryListing* temp = _impl_.dirlist_;
  _impl_.dirlist_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DirectoryListing* GetListingResponse::unsafe_arena_release_dirlist() {
  // @@protoc_insertion_point(field_release:ClientNamenode.GetListingResponse.dirList)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DirectoryListing* temp = _impl_.dirlist_;
  _impl_.dirlist_ = nullptr;
  return temp;
}
inline ::DirectoryListing* GetListingResponse::_internal_mutable_dirlist() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.dirlist_ == nullptr) {
    auto* p = CreateMaybeMessage<::DirectoryListing>(GetArenaForAllocation());
    _impl_.dirlist_ = p;
  }
  return _impl_.dirlist_;
}
inline ::DirectoryListing* GetListingResponse::mutable_dirlist() {
  ::DirectoryListing* _msg = _internal_mutable_dirlist();
  // @@protoc_insertion_point(field_mutable:ClientNamenode.GetListingResponse.dirList)
  return _msg;
}
inline void GetListingResponse::set_allocated_dirlist(::DirectoryListing* dirlist) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dirlist_);
  }
  if (dirlist) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dirlist));
    if (message_arena != submessage_arena) {
      dirlist = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dirlist, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.dirlist_ = dirlist;
  // @@protoc_insertion_point(field_set_allocated:ClientNamenode.GetListingResponse.dirList)
}

// -------------------------------------------------------------------

// RenewLeaseRequest

// string ClientName = 1;
inline void RenewLeaseRequest::clear_clientname() {
  _impl_.clientname_.ClearToEmpty();
}
inline const std::string& RenewLeaseRequest::clientname() const {
  // @@protoc_insertion_point(field_get:ClientNamenode.RenewLeaseRequest.ClientName)
  return _internal_clientname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RenewLeaseRequest::set_clientname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.clientname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ClientNamenode.RenewLeaseRequest.ClientName)
}
inline std::string* RenewLeaseRequest::mutable_clientname() {
  std::string* _s = _internal_mutable_clientname();
  // @@protoc_insertion_point(field_mutable:ClientNamenode.RenewLeaseRequest.ClientName)
  return _s;
}
inline const std::string& RenewLeaseRequest::_internal_clientname() const {
  return _impl_.clientname_.Get();
}
inline void RenewLeaseRequest::_internal_set_clientname(const std::string& value) {
  
  _impl_.clientname_.Set(value, GetArenaForAllocation());
}
inline std::string* RenewLeaseRequest::_internal_mutable_clientname() {
  
  return _impl_.clientname_.Mutable(GetArenaForAllocation());
}
inline std::string* RenewLeaseRequest::release_clientname() {
  // @@protoc_insertion_point(field_release:ClientNamenode.RenewLeaseRequest.ClientName)
  return _impl_.clientname_.Release();
}
inline void RenewLeaseRequest::set_allocated_clientname(std::string* clientname) {
  if (clientname != nullptr) {
    
  } else {
    
  }
  _impl_.clientname_.SetAllocated(clientname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.clientname_.IsDefault()) {
    _impl_.clientname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ClientNamenode.RenewLeaseRequest.ClientName)
}

// -------------------------------------------------------------------

// RenewLeaseResponse

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ClientNamenode

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::ClientNamenode::CreateFlag> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ClientNamenode::CreateFlag>() {
  return ::ClientNamenode::CreateFlag_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_ClientNamenode_2eproto
