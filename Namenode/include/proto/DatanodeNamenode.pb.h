// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: DatanodeNamenode.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_DatanodeNamenode_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_DatanodeNamenode_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "dfs.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_DatanodeNamenode_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_DatanodeNamenode_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_DatanodeNamenode_2eproto;
namespace DatanodeNamenode {
class BalanceBandwidth;
struct BalanceBandwidthDefaultTypeInternal;
extern BalanceBandwidthDefaultTypeInternal _BalanceBandwidth_default_instance_;
class BlockCommand;
struct BlockCommandDefaultTypeInternal;
extern BlockCommandDefaultTypeInternal _BlockCommand_default_instance_;
class BlockId;
struct BlockIdDefaultTypeInternal;
extern BlockIdDefaultTypeInternal _BlockId_default_instance_;
class BlockReceivedAndDeletedRequest;
struct BlockReceivedAndDeletedRequestDefaultTypeInternal;
extern BlockReceivedAndDeletedRequestDefaultTypeInternal _BlockReceivedAndDeletedRequest_default_instance_;
class BlockReceivedAndDeletedResponse;
struct BlockReceivedAndDeletedResponseDefaultTypeInternal;
extern BlockReceivedAndDeletedResponseDefaultTypeInternal _BlockReceivedAndDeletedResponse_default_instance_;
class BlockRecovery;
struct BlockRecoveryDefaultTypeInternal;
extern BlockRecoveryDefaultTypeInternal _BlockRecovery_default_instance_;
class CacheCommand;
struct CacheCommandDefaultTypeInternal;
extern CacheCommandDefaultTypeInternal _CacheCommand_default_instance_;
class DatanodeCommand;
struct DatanodeCommandDefaultTypeInternal;
extern DatanodeCommandDefaultTypeInternal _DatanodeCommand_default_instance_;
class DatanodeRegister;
struct DatanodeRegisterDefaultTypeInternal;
extern DatanodeRegisterDefaultTypeInternal _DatanodeRegister_default_instance_;
class ErrorReportRequest;
struct ErrorReportRequestDefaultTypeInternal;
extern ErrorReportRequestDefaultTypeInternal _ErrorReportRequest_default_instance_;
class ErrorReportResponse;
struct ErrorReportResponseDefaultTypeInternal;
extern ErrorReportResponseDefaultTypeInternal _ErrorReportResponse_default_instance_;
class Finalize;
struct FinalizeDefaultTypeInternal;
extern FinalizeDefaultTypeInternal _Finalize_default_instance_;
class HeartBeatRequest;
struct HeartBeatRequestDefaultTypeInternal;
extern HeartBeatRequestDefaultTypeInternal _HeartBeatRequest_default_instance_;
class HeartBeatResponse;
struct HeartBeatResponseDefaultTypeInternal;
extern HeartBeatResponseDefaultTypeInternal _HeartBeatResponse_default_instance_;
class KeyUpdate;
struct KeyUpdateDefaultTypeInternal;
extern KeyUpdateDefaultTypeInternal _KeyUpdate_default_instance_;
class ReceivedDeletedBlockInfo;
struct ReceivedDeletedBlockInfoDefaultTypeInternal;
extern ReceivedDeletedBlockInfoDefaultTypeInternal _ReceivedDeletedBlockInfo_default_instance_;
class Register;
struct RegisterDefaultTypeInternal;
extern RegisterDefaultTypeInternal _Register_default_instance_;
class RegisterDatanodeRequest;
struct RegisterDatanodeRequestDefaultTypeInternal;
extern RegisterDatanodeRequestDefaultTypeInternal _RegisterDatanodeRequest_default_instance_;
class RegisterDatanodeResponse;
struct RegisterDatanodeResponseDefaultTypeInternal;
extern RegisterDatanodeResponseDefaultTypeInternal _RegisterDatanodeResponse_default_instance_;
class ReportBadBlockRequest;
struct ReportBadBlockRequestDefaultTypeInternal;
extern ReportBadBlockRequestDefaultTypeInternal _ReportBadBlockRequest_default_instance_;
class ReportBadBlockResponse;
struct ReportBadBlockResponseDefaultTypeInternal;
extern ReportBadBlockResponseDefaultTypeInternal _ReportBadBlockResponse_default_instance_;
class blockReportRequest;
struct blockReportRequestDefaultTypeInternal;
extern blockReportRequestDefaultTypeInternal _blockReportRequest_default_instance_;
class blockReportResponse;
struct blockReportResponseDefaultTypeInternal;
extern blockReportResponseDefaultTypeInternal _blockReportResponse_default_instance_;
class cacheReportRequest;
struct cacheReportRequestDefaultTypeInternal;
extern cacheReportRequestDefaultTypeInternal _cacheReportRequest_default_instance_;
class cacheReportResponse;
struct cacheReportResponseDefaultTypeInternal;
extern cacheReportResponseDefaultTypeInternal _cacheReportResponse_default_instance_;
}  // namespace DatanodeNamenode
PROTOBUF_NAMESPACE_OPEN
template<> ::DatanodeNamenode::BalanceBandwidth* Arena::CreateMaybeMessage<::DatanodeNamenode::BalanceBandwidth>(Arena*);
template<> ::DatanodeNamenode::BlockCommand* Arena::CreateMaybeMessage<::DatanodeNamenode::BlockCommand>(Arena*);
template<> ::DatanodeNamenode::BlockId* Arena::CreateMaybeMessage<::DatanodeNamenode::BlockId>(Arena*);
template<> ::DatanodeNamenode::BlockReceivedAndDeletedRequest* Arena::CreateMaybeMessage<::DatanodeNamenode::BlockReceivedAndDeletedRequest>(Arena*);
template<> ::DatanodeNamenode::BlockReceivedAndDeletedResponse* Arena::CreateMaybeMessage<::DatanodeNamenode::BlockReceivedAndDeletedResponse>(Arena*);
template<> ::DatanodeNamenode::BlockRecovery* Arena::CreateMaybeMessage<::DatanodeNamenode::BlockRecovery>(Arena*);
template<> ::DatanodeNamenode::CacheCommand* Arena::CreateMaybeMessage<::DatanodeNamenode::CacheCommand>(Arena*);
template<> ::DatanodeNamenode::DatanodeCommand* Arena::CreateMaybeMessage<::DatanodeNamenode::DatanodeCommand>(Arena*);
template<> ::DatanodeNamenode::DatanodeRegister* Arena::CreateMaybeMessage<::DatanodeNamenode::DatanodeRegister>(Arena*);
template<> ::DatanodeNamenode::ErrorReportRequest* Arena::CreateMaybeMessage<::DatanodeNamenode::ErrorReportRequest>(Arena*);
template<> ::DatanodeNamenode::ErrorReportResponse* Arena::CreateMaybeMessage<::DatanodeNamenode::ErrorReportResponse>(Arena*);
template<> ::DatanodeNamenode::Finalize* Arena::CreateMaybeMessage<::DatanodeNamenode::Finalize>(Arena*);
template<> ::DatanodeNamenode::HeartBeatRequest* Arena::CreateMaybeMessage<::DatanodeNamenode::HeartBeatRequest>(Arena*);
template<> ::DatanodeNamenode::HeartBeatResponse* Arena::CreateMaybeMessage<::DatanodeNamenode::HeartBeatResponse>(Arena*);
template<> ::DatanodeNamenode::KeyUpdate* Arena::CreateMaybeMessage<::DatanodeNamenode::KeyUpdate>(Arena*);
template<> ::DatanodeNamenode::ReceivedDeletedBlockInfo* Arena::CreateMaybeMessage<::DatanodeNamenode::ReceivedDeletedBlockInfo>(Arena*);
template<> ::DatanodeNamenode::Register* Arena::CreateMaybeMessage<::DatanodeNamenode::Register>(Arena*);
template<> ::DatanodeNamenode::RegisterDatanodeRequest* Arena::CreateMaybeMessage<::DatanodeNamenode::RegisterDatanodeRequest>(Arena*);
template<> ::DatanodeNamenode::RegisterDatanodeResponse* Arena::CreateMaybeMessage<::DatanodeNamenode::RegisterDatanodeResponse>(Arena*);
template<> ::DatanodeNamenode::ReportBadBlockRequest* Arena::CreateMaybeMessage<::DatanodeNamenode::ReportBadBlockRequest>(Arena*);
template<> ::DatanodeNamenode::ReportBadBlockResponse* Arena::CreateMaybeMessage<::DatanodeNamenode::ReportBadBlockResponse>(Arena*);
template<> ::DatanodeNamenode::blockReportRequest* Arena::CreateMaybeMessage<::DatanodeNamenode::blockReportRequest>(Arena*);
template<> ::DatanodeNamenode::blockReportResponse* Arena::CreateMaybeMessage<::DatanodeNamenode::blockReportResponse>(Arena*);
template<> ::DatanodeNamenode::cacheReportRequest* Arena::CreateMaybeMessage<::DatanodeNamenode::cacheReportRequest>(Arena*);
template<> ::DatanodeNamenode::cacheReportResponse* Arena::CreateMaybeMessage<::DatanodeNamenode::cacheReportResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace DatanodeNamenode {

enum DatanodeCommand_Type : int {
  DatanodeCommand_Type_BalancerBandwidthCommand = 0,
  DatanodeCommand_Type_BlockCommand = 1,
  DatanodeCommand_Type_BlockRecoveryCommand = 2,
  DatanodeCommand_Type_FinalizeCommand = 3,
  DatanodeCommand_Type_KeyUpdateCommand = 4,
  DatanodeCommand_Type_RegisterCommand = 5,
  DatanodeCommand_Type_UnusedUpgradeCommand = 6,
  DatanodeCommand_Type_NullDatanodeCommand = 7,
  DatanodeCommand_Type_BlockIdCommand = 8,
  DatanodeCommand_Type_CacheCommand = 9,
  DatanodeCommand_Type_DatanodeCommand_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DatanodeCommand_Type_DatanodeCommand_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DatanodeCommand_Type_IsValid(int value);
constexpr DatanodeCommand_Type DatanodeCommand_Type_Type_MIN = DatanodeCommand_Type_BalancerBandwidthCommand;
constexpr DatanodeCommand_Type DatanodeCommand_Type_Type_MAX = DatanodeCommand_Type_CacheCommand;
constexpr int DatanodeCommand_Type_Type_ARRAYSIZE = DatanodeCommand_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DatanodeCommand_Type_descriptor();
template<typename T>
inline const std::string& DatanodeCommand_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DatanodeCommand_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DatanodeCommand_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DatanodeCommand_Type_descriptor(), enum_t_value);
}
inline bool DatanodeCommand_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DatanodeCommand_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DatanodeCommand_Type>(
    DatanodeCommand_Type_descriptor(), name, value);
}
enum BlockCommand_Action : int {
  BlockCommand_Action_TRANSFER = 0,
  BlockCommand_Action_INVALIDATE = 1,
  BlockCommand_Action_SHUTDOWN = 2,
  BlockCommand_Action_BlockCommand_Action_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  BlockCommand_Action_BlockCommand_Action_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool BlockCommand_Action_IsValid(int value);
constexpr BlockCommand_Action BlockCommand_Action_Action_MIN = BlockCommand_Action_TRANSFER;
constexpr BlockCommand_Action BlockCommand_Action_Action_MAX = BlockCommand_Action_SHUTDOWN;
constexpr int BlockCommand_Action_Action_ARRAYSIZE = BlockCommand_Action_Action_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BlockCommand_Action_descriptor();
template<typename T>
inline const std::string& BlockCommand_Action_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BlockCommand_Action>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BlockCommand_Action_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BlockCommand_Action_descriptor(), enum_t_value);
}
inline bool BlockCommand_Action_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BlockCommand_Action* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BlockCommand_Action>(
    BlockCommand_Action_descriptor(), name, value);
}
enum BlockId_Action : int {
  BlockId_Action_CACHE = 0,
  BlockId_Action_UNCACHE = 1,
  BlockId_Action_BlockId_Action_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  BlockId_Action_BlockId_Action_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool BlockId_Action_IsValid(int value);
constexpr BlockId_Action BlockId_Action_Action_MIN = BlockId_Action_CACHE;
constexpr BlockId_Action BlockId_Action_Action_MAX = BlockId_Action_UNCACHE;
constexpr int BlockId_Action_Action_ARRAYSIZE = BlockId_Action_Action_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BlockId_Action_descriptor();
template<typename T>
inline const std::string& BlockId_Action_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BlockId_Action>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BlockId_Action_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BlockId_Action_descriptor(), enum_t_value);
}
inline bool BlockId_Action_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BlockId_Action* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BlockId_Action>(
    BlockId_Action_descriptor(), name, value);
}
enum ReceivedDeletedBlockInfo_BlockStatus : int {
  ReceivedDeletedBlockInfo_BlockStatus_RECEIVING = 0,
  ReceivedDeletedBlockInfo_BlockStatus_RECEIVED = 1,
  ReceivedDeletedBlockInfo_BlockStatus_DELETED = 2,
  ReceivedDeletedBlockInfo_BlockStatus_ReceivedDeletedBlockInfo_BlockStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ReceivedDeletedBlockInfo_BlockStatus_ReceivedDeletedBlockInfo_BlockStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ReceivedDeletedBlockInfo_BlockStatus_IsValid(int value);
constexpr ReceivedDeletedBlockInfo_BlockStatus ReceivedDeletedBlockInfo_BlockStatus_BlockStatus_MIN = ReceivedDeletedBlockInfo_BlockStatus_RECEIVING;
constexpr ReceivedDeletedBlockInfo_BlockStatus ReceivedDeletedBlockInfo_BlockStatus_BlockStatus_MAX = ReceivedDeletedBlockInfo_BlockStatus_DELETED;
constexpr int ReceivedDeletedBlockInfo_BlockStatus_BlockStatus_ARRAYSIZE = ReceivedDeletedBlockInfo_BlockStatus_BlockStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ReceivedDeletedBlockInfo_BlockStatus_descriptor();
template<typename T>
inline const std::string& ReceivedDeletedBlockInfo_BlockStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ReceivedDeletedBlockInfo_BlockStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ReceivedDeletedBlockInfo_BlockStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ReceivedDeletedBlockInfo_BlockStatus_descriptor(), enum_t_value);
}
inline bool ReceivedDeletedBlockInfo_BlockStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ReceivedDeletedBlockInfo_BlockStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ReceivedDeletedBlockInfo_BlockStatus>(
    ReceivedDeletedBlockInfo_BlockStatus_descriptor(), name, value);
}
enum ErrorReportRequest_ErrorCode : int {
  ErrorReportRequest_ErrorCode_NOTIFY = 0,
  ErrorReportRequest_ErrorCode_DISK_ERROR = 1,
  ErrorReportRequest_ErrorCode_INVALID_BLOCK = 2,
  ErrorReportRequest_ErrorCode_FATAL_DISK_ERROR = 3,
  ErrorReportRequest_ErrorCode_ErrorReportRequest_ErrorCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ErrorReportRequest_ErrorCode_ErrorReportRequest_ErrorCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ErrorReportRequest_ErrorCode_IsValid(int value);
constexpr ErrorReportRequest_ErrorCode ErrorReportRequest_ErrorCode_ErrorCode_MIN = ErrorReportRequest_ErrorCode_NOTIFY;
constexpr ErrorReportRequest_ErrorCode ErrorReportRequest_ErrorCode_ErrorCode_MAX = ErrorReportRequest_ErrorCode_FATAL_DISK_ERROR;
constexpr int ErrorReportRequest_ErrorCode_ErrorCode_ARRAYSIZE = ErrorReportRequest_ErrorCode_ErrorCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ErrorReportRequest_ErrorCode_descriptor();
template<typename T>
inline const std::string& ErrorReportRequest_ErrorCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ErrorReportRequest_ErrorCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ErrorReportRequest_ErrorCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ErrorReportRequest_ErrorCode_descriptor(), enum_t_value);
}
inline bool ErrorReportRequest_ErrorCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ErrorReportRequest_ErrorCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ErrorReportRequest_ErrorCode>(
    ErrorReportRequest_ErrorCode_descriptor(), name, value);
}
// ===================================================================

class DatanodeRegister final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DatanodeNamenode.DatanodeRegister) */ {
 public:
  inline DatanodeRegister() : DatanodeRegister(nullptr) {}
  ~DatanodeRegister() override;
  explicit PROTOBUF_CONSTEXPR DatanodeRegister(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DatanodeRegister(const DatanodeRegister& from);
  DatanodeRegister(DatanodeRegister&& from) noexcept
    : DatanodeRegister() {
    *this = ::std::move(from);
  }

  inline DatanodeRegister& operator=(const DatanodeRegister& from) {
    CopyFrom(from);
    return *this;
  }
  inline DatanodeRegister& operator=(DatanodeRegister&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DatanodeRegister& default_instance() {
    return *internal_default_instance();
  }
  static inline const DatanodeRegister* internal_default_instance() {
    return reinterpret_cast<const DatanodeRegister*>(
               &_DatanodeRegister_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DatanodeRegister& a, DatanodeRegister& b) {
    a.Swap(&b);
  }
  inline void Swap(DatanodeRegister* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DatanodeRegister* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DatanodeRegister* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DatanodeRegister>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DatanodeRegister& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DatanodeRegister& from) {
    DatanodeRegister::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DatanodeRegister* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DatanodeNamenode.DatanodeRegister";
  }
  protected:
  explicit DatanodeRegister(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSoftwareVersionFieldNumber = 3,
    kIdFieldNumber = 1,
    kInfoFieldNumber = 2,
  };
  // string softwareVersion = 3;
  void clear_softwareversion();
  const std::string& softwareversion() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_softwareversion(ArgT0&& arg0, ArgT... args);
  std::string* mutable_softwareversion();
  PROTOBUF_NODISCARD std::string* release_softwareversion();
  void set_allocated_softwareversion(std::string* softwareversion);
  private:
  const std::string& _internal_softwareversion() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_softwareversion(const std::string& value);
  std::string* _internal_mutable_softwareversion();
  public:

  // .DatanodeID id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::DatanodeID& id() const;
  PROTOBUF_NODISCARD ::DatanodeID* release_id();
  ::DatanodeID* mutable_id();
  void set_allocated_id(::DatanodeID* id);
  private:
  const ::DatanodeID& _internal_id() const;
  ::DatanodeID* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::DatanodeID* id);
  ::DatanodeID* unsafe_arena_release_id();

  // .DatanodeInfo info = 2;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::DatanodeInfo& info() const;
  PROTOBUF_NODISCARD ::DatanodeInfo* release_info();
  ::DatanodeInfo* mutable_info();
  void set_allocated_info(::DatanodeInfo* info);
  private:
  const ::DatanodeInfo& _internal_info() const;
  ::DatanodeInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::DatanodeInfo* info);
  ::DatanodeInfo* unsafe_arena_release_info();

  // @@protoc_insertion_point(class_scope:DatanodeNamenode.DatanodeRegister)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr softwareversion_;
    ::DatanodeID* id_;
    ::DatanodeInfo* info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_DatanodeNamenode_2eproto;
};
// -------------------------------------------------------------------

class DatanodeCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DatanodeNamenode.DatanodeCommand) */ {
 public:
  inline DatanodeCommand() : DatanodeCommand(nullptr) {}
  ~DatanodeCommand() override;
  explicit PROTOBUF_CONSTEXPR DatanodeCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DatanodeCommand(const DatanodeCommand& from);
  DatanodeCommand(DatanodeCommand&& from) noexcept
    : DatanodeCommand() {
    *this = ::std::move(from);
  }

  inline DatanodeCommand& operator=(const DatanodeCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline DatanodeCommand& operator=(DatanodeCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DatanodeCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const DatanodeCommand* internal_default_instance() {
    return reinterpret_cast<const DatanodeCommand*>(
               &_DatanodeCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DatanodeCommand& a, DatanodeCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(DatanodeCommand* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DatanodeCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DatanodeCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DatanodeCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DatanodeCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DatanodeCommand& from) {
    DatanodeCommand::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DatanodeCommand* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DatanodeNamenode.DatanodeCommand";
  }
  protected:
  explicit DatanodeCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DatanodeCommand_Type Type;
  static constexpr Type BalancerBandwidthCommand =
    DatanodeCommand_Type_BalancerBandwidthCommand;
  static constexpr Type BlockCommand =
    DatanodeCommand_Type_BlockCommand;
  static constexpr Type BlockRecoveryCommand =
    DatanodeCommand_Type_BlockRecoveryCommand;
  static constexpr Type FinalizeCommand =
    DatanodeCommand_Type_FinalizeCommand;
  static constexpr Type KeyUpdateCommand =
    DatanodeCommand_Type_KeyUpdateCommand;
  static constexpr Type RegisterCommand =
    DatanodeCommand_Type_RegisterCommand;
  static constexpr Type UnusedUpgradeCommand =
    DatanodeCommand_Type_UnusedUpgradeCommand;
  static constexpr Type NullDatanodeCommand =
    DatanodeCommand_Type_NullDatanodeCommand;
  static constexpr Type BlockIdCommand =
    DatanodeCommand_Type_BlockIdCommand;
  static constexpr Type CacheCommand =
    DatanodeCommand_Type_CacheCommand;
  static inline bool Type_IsValid(int value) {
    return DatanodeCommand_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    DatanodeCommand_Type_Type_MIN;
  static constexpr Type Type_MAX =
    DatanodeCommand_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    DatanodeCommand_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return DatanodeCommand_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return DatanodeCommand_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return DatanodeCommand_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kBalanceCmdFieldNumber = 2,
    kBlkCmdFieldNumber = 3,
    kRecoveryCmdFieldNumber = 4,
    kFinalizeCmdFieldNumber = 5,
    kKeyUpdateCmdFieldNumber = 6,
    kRegisterCmdFieldNumber = 7,
    kBlkIdCmdFieldNumber = 8,
    kCacheCmdFieldNumber = 9,
    kCommandTypeFieldNumber = 1,
  };
  // optional .DatanodeNamenode.BalanceBandwidth balanceCmd = 2;
  bool has_balancecmd() const;
  private:
  bool _internal_has_balancecmd() const;
  public:
  void clear_balancecmd();
  const ::DatanodeNamenode::BalanceBandwidth& balancecmd() const;
  PROTOBUF_NODISCARD ::DatanodeNamenode::BalanceBandwidth* release_balancecmd();
  ::DatanodeNamenode::BalanceBandwidth* mutable_balancecmd();
  void set_allocated_balancecmd(::DatanodeNamenode::BalanceBandwidth* balancecmd);
  private:
  const ::DatanodeNamenode::BalanceBandwidth& _internal_balancecmd() const;
  ::DatanodeNamenode::BalanceBandwidth* _internal_mutable_balancecmd();
  public:
  void unsafe_arena_set_allocated_balancecmd(
      ::DatanodeNamenode::BalanceBandwidth* balancecmd);
  ::DatanodeNamenode::BalanceBandwidth* unsafe_arena_release_balancecmd();

  // optional .DatanodeNamenode.BlockCommand blkCmd = 3;
  bool has_blkcmd() const;
  private:
  bool _internal_has_blkcmd() const;
  public:
  void clear_blkcmd();
  const ::DatanodeNamenode::BlockCommand& blkcmd() const;
  PROTOBUF_NODISCARD ::DatanodeNamenode::BlockCommand* release_blkcmd();
  ::DatanodeNamenode::BlockCommand* mutable_blkcmd();
  void set_allocated_blkcmd(::DatanodeNamenode::BlockCommand* blkcmd);
  private:
  const ::DatanodeNamenode::BlockCommand& _internal_blkcmd() const;
  ::DatanodeNamenode::BlockCommand* _internal_mutable_blkcmd();
  public:
  void unsafe_arena_set_allocated_blkcmd(
      ::DatanodeNamenode::BlockCommand* blkcmd);
  ::DatanodeNamenode::BlockCommand* unsafe_arena_release_blkcmd();

  // optional .DatanodeNamenode.BlockRecovery recoveryCmd = 4;
  bool has_recoverycmd() const;
  private:
  bool _internal_has_recoverycmd() const;
  public:
  void clear_recoverycmd();
  const ::DatanodeNamenode::BlockRecovery& recoverycmd() const;
  PROTOBUF_NODISCARD ::DatanodeNamenode::BlockRecovery* release_recoverycmd();
  ::DatanodeNamenode::BlockRecovery* mutable_recoverycmd();
  void set_allocated_recoverycmd(::DatanodeNamenode::BlockRecovery* recoverycmd);
  private:
  const ::DatanodeNamenode::BlockRecovery& _internal_recoverycmd() const;
  ::DatanodeNamenode::BlockRecovery* _internal_mutable_recoverycmd();
  public:
  void unsafe_arena_set_allocated_recoverycmd(
      ::DatanodeNamenode::BlockRecovery* recoverycmd);
  ::DatanodeNamenode::BlockRecovery* unsafe_arena_release_recoverycmd();

  // optional .DatanodeNamenode.Finalize finalizeCmd = 5;
  bool has_finalizecmd() const;
  private:
  bool _internal_has_finalizecmd() const;
  public:
  void clear_finalizecmd();
  const ::DatanodeNamenode::Finalize& finalizecmd() const;
  PROTOBUF_NODISCARD ::DatanodeNamenode::Finalize* release_finalizecmd();
  ::DatanodeNamenode::Finalize* mutable_finalizecmd();
  void set_allocated_finalizecmd(::DatanodeNamenode::Finalize* finalizecmd);
  private:
  const ::DatanodeNamenode::Finalize& _internal_finalizecmd() const;
  ::DatanodeNamenode::Finalize* _internal_mutable_finalizecmd();
  public:
  void unsafe_arena_set_allocated_finalizecmd(
      ::DatanodeNamenode::Finalize* finalizecmd);
  ::DatanodeNamenode::Finalize* unsafe_arena_release_finalizecmd();

  // optional .DatanodeNamenode.KeyUpdate keyUpdateCmd = 6;
  bool has_keyupdatecmd() const;
  private:
  bool _internal_has_keyupdatecmd() const;
  public:
  void clear_keyupdatecmd();
  const ::DatanodeNamenode::KeyUpdate& keyupdatecmd() const;
  PROTOBUF_NODISCARD ::DatanodeNamenode::KeyUpdate* release_keyupdatecmd();
  ::DatanodeNamenode::KeyUpdate* mutable_keyupdatecmd();
  void set_allocated_keyupdatecmd(::DatanodeNamenode::KeyUpdate* keyupdatecmd);
  private:
  const ::DatanodeNamenode::KeyUpdate& _internal_keyupdatecmd() const;
  ::DatanodeNamenode::KeyUpdate* _internal_mutable_keyupdatecmd();
  public:
  void unsafe_arena_set_allocated_keyupdatecmd(
      ::DatanodeNamenode::KeyUpdate* keyupdatecmd);
  ::DatanodeNamenode::KeyUpdate* unsafe_arena_release_keyupdatecmd();

  // optional .DatanodeNamenode.Register registerCmd = 7;
  bool has_registercmd() const;
  private:
  bool _internal_has_registercmd() const;
  public:
  void clear_registercmd();
  const ::DatanodeNamenode::Register& registercmd() const;
  PROTOBUF_NODISCARD ::DatanodeNamenode::Register* release_registercmd();
  ::DatanodeNamenode::Register* mutable_registercmd();
  void set_allocated_registercmd(::DatanodeNamenode::Register* registercmd);
  private:
  const ::DatanodeNamenode::Register& _internal_registercmd() const;
  ::DatanodeNamenode::Register* _internal_mutable_registercmd();
  public:
  void unsafe_arena_set_allocated_registercmd(
      ::DatanodeNamenode::Register* registercmd);
  ::DatanodeNamenode::Register* unsafe_arena_release_registercmd();

  // optional .DatanodeNamenode.BlockId blkIdCmd = 8;
  bool has_blkidcmd() const;
  private:
  bool _internal_has_blkidcmd() const;
  public:
  void clear_blkidcmd();
  const ::DatanodeNamenode::BlockId& blkidcmd() const;
  PROTOBUF_NODISCARD ::DatanodeNamenode::BlockId* release_blkidcmd();
  ::DatanodeNamenode::BlockId* mutable_blkidcmd();
  void set_allocated_blkidcmd(::DatanodeNamenode::BlockId* blkidcmd);
  private:
  const ::DatanodeNamenode::BlockId& _internal_blkidcmd() const;
  ::DatanodeNamenode::BlockId* _internal_mutable_blkidcmd();
  public:
  void unsafe_arena_set_allocated_blkidcmd(
      ::DatanodeNamenode::BlockId* blkidcmd);
  ::DatanodeNamenode::BlockId* unsafe_arena_release_blkidcmd();

  // optional .DatanodeNamenode.CacheCommand cacheCmd = 9;
  bool has_cachecmd() const;
  private:
  bool _internal_has_cachecmd() const;
  public:
  void clear_cachecmd();
  const ::DatanodeNamenode::CacheCommand& cachecmd() const;
  PROTOBUF_NODISCARD ::DatanodeNamenode::CacheCommand* release_cachecmd();
  ::DatanodeNamenode::CacheCommand* mutable_cachecmd();
  void set_allocated_cachecmd(::DatanodeNamenode::CacheCommand* cachecmd);
  private:
  const ::DatanodeNamenode::CacheCommand& _internal_cachecmd() const;
  ::DatanodeNamenode::CacheCommand* _internal_mutable_cachecmd();
  public:
  void unsafe_arena_set_allocated_cachecmd(
      ::DatanodeNamenode::CacheCommand* cachecmd);
  ::DatanodeNamenode::CacheCommand* unsafe_arena_release_cachecmd();

  // .DatanodeNamenode.DatanodeCommand.Type commandType = 1;
  void clear_commandtype();
  ::DatanodeNamenode::DatanodeCommand_Type commandtype() const;
  void set_commandtype(::DatanodeNamenode::DatanodeCommand_Type value);
  private:
  ::DatanodeNamenode::DatanodeCommand_Type _internal_commandtype() const;
  void _internal_set_commandtype(::DatanodeNamenode::DatanodeCommand_Type value);
  public:

  // @@protoc_insertion_point(class_scope:DatanodeNamenode.DatanodeCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::DatanodeNamenode::BalanceBandwidth* balancecmd_;
    ::DatanodeNamenode::BlockCommand* blkcmd_;
    ::DatanodeNamenode::BlockRecovery* recoverycmd_;
    ::DatanodeNamenode::Finalize* finalizecmd_;
    ::DatanodeNamenode::KeyUpdate* keyupdatecmd_;
    ::DatanodeNamenode::Register* registercmd_;
    ::DatanodeNamenode::BlockId* blkidcmd_;
    ::DatanodeNamenode::CacheCommand* cachecmd_;
    int commandtype_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_DatanodeNamenode_2eproto;
};
// -------------------------------------------------------------------

class BalanceBandwidth final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DatanodeNamenode.BalanceBandwidth) */ {
 public:
  inline BalanceBandwidth() : BalanceBandwidth(nullptr) {}
  ~BalanceBandwidth() override;
  explicit PROTOBUF_CONSTEXPR BalanceBandwidth(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BalanceBandwidth(const BalanceBandwidth& from);
  BalanceBandwidth(BalanceBandwidth&& from) noexcept
    : BalanceBandwidth() {
    *this = ::std::move(from);
  }

  inline BalanceBandwidth& operator=(const BalanceBandwidth& from) {
    CopyFrom(from);
    return *this;
  }
  inline BalanceBandwidth& operator=(BalanceBandwidth&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BalanceBandwidth& default_instance() {
    return *internal_default_instance();
  }
  static inline const BalanceBandwidth* internal_default_instance() {
    return reinterpret_cast<const BalanceBandwidth*>(
               &_BalanceBandwidth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(BalanceBandwidth& a, BalanceBandwidth& b) {
    a.Swap(&b);
  }
  inline void Swap(BalanceBandwidth* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BalanceBandwidth* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BalanceBandwidth* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BalanceBandwidth>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BalanceBandwidth& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BalanceBandwidth& from) {
    BalanceBandwidth::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BalanceBandwidth* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DatanodeNamenode.BalanceBandwidth";
  }
  protected:
  explicit BalanceBandwidth(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBandwidthFieldNumber = 1,
  };
  // uint64 bandwidth = 1;
  void clear_bandwidth();
  uint64_t bandwidth() const;
  void set_bandwidth(uint64_t value);
  private:
  uint64_t _internal_bandwidth() const;
  void _internal_set_bandwidth(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:DatanodeNamenode.BalanceBandwidth)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t bandwidth_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_DatanodeNamenode_2eproto;
};
// -------------------------------------------------------------------

class BlockCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DatanodeNamenode.BlockCommand) */ {
 public:
  inline BlockCommand() : BlockCommand(nullptr) {}
  ~BlockCommand() override;
  explicit PROTOBUF_CONSTEXPR BlockCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockCommand(const BlockCommand& from);
  BlockCommand(BlockCommand&& from) noexcept
    : BlockCommand() {
    *this = ::std::move(from);
  }

  inline BlockCommand& operator=(const BlockCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockCommand& operator=(BlockCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockCommand* internal_default_instance() {
    return reinterpret_cast<const BlockCommand*>(
               &_BlockCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(BlockCommand& a, BlockCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockCommand* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BlockCommand& from) {
    BlockCommand::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockCommand* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DatanodeNamenode.BlockCommand";
  }
  protected:
  explicit BlockCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef BlockCommand_Action Action;
  static constexpr Action TRANSFER =
    BlockCommand_Action_TRANSFER;
  static constexpr Action INVALIDATE =
    BlockCommand_Action_INVALIDATE;
  static constexpr Action SHUTDOWN =
    BlockCommand_Action_SHUTDOWN;
  static inline bool Action_IsValid(int value) {
    return BlockCommand_Action_IsValid(value);
  }
  static constexpr Action Action_MIN =
    BlockCommand_Action_Action_MIN;
  static constexpr Action Action_MAX =
    BlockCommand_Action_Action_MAX;
  static constexpr int Action_ARRAYSIZE =
    BlockCommand_Action_Action_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Action_descriptor() {
    return BlockCommand_Action_descriptor();
  }
  template<typename T>
  static inline const std::string& Action_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Action>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Action_Name.");
    return BlockCommand_Action_Name(enum_t_value);
  }
  static inline bool Action_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Action* value) {
    return BlockCommand_Action_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kBlocksFieldNumber = 2,
    kTargetsFieldNumber = 3,
    kActionFieldNumber = 1,
  };
  // repeated .Block blocks = 2;
  int blocks_size() const;
  private:
  int _internal_blocks_size() const;
  public:
  void clear_blocks();
  ::Block* mutable_blocks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Block >*
      mutable_blocks();
  private:
  const ::Block& _internal_blocks(int index) const;
  ::Block* _internal_add_blocks();
  public:
  const ::Block& blocks(int index) const;
  ::Block* add_blocks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Block >&
      blocks() const;

  // repeated .DatanodeInfo targets = 3;
  int targets_size() const;
  private:
  int _internal_targets_size() const;
  public:
  void clear_targets();
  ::DatanodeInfo* mutable_targets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DatanodeInfo >*
      mutable_targets();
  private:
  const ::DatanodeInfo& _internal_targets(int index) const;
  ::DatanodeInfo* _internal_add_targets();
  public:
  const ::DatanodeInfo& targets(int index) const;
  ::DatanodeInfo* add_targets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DatanodeInfo >&
      targets() const;

  // .DatanodeNamenode.BlockCommand.Action action = 1;
  void clear_action();
  ::DatanodeNamenode::BlockCommand_Action action() const;
  void set_action(::DatanodeNamenode::BlockCommand_Action value);
  private:
  ::DatanodeNamenode::BlockCommand_Action _internal_action() const;
  void _internal_set_action(::DatanodeNamenode::BlockCommand_Action value);
  public:

  // @@protoc_insertion_point(class_scope:DatanodeNamenode.BlockCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Block > blocks_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DatanodeInfo > targets_;
    int action_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_DatanodeNamenode_2eproto;
};
// -------------------------------------------------------------------

class BlockRecovery final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:DatanodeNamenode.BlockRecovery) */ {
 public:
  inline BlockRecovery() : BlockRecovery(nullptr) {}
  explicit PROTOBUF_CONSTEXPR BlockRecovery(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockRecovery(const BlockRecovery& from);
  BlockRecovery(BlockRecovery&& from) noexcept
    : BlockRecovery() {
    *this = ::std::move(from);
  }

  inline BlockRecovery& operator=(const BlockRecovery& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockRecovery& operator=(BlockRecovery&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockRecovery& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockRecovery* internal_default_instance() {
    return reinterpret_cast<const BlockRecovery*>(
               &_BlockRecovery_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(BlockRecovery& a, BlockRecovery& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockRecovery* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockRecovery* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockRecovery* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockRecovery>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const BlockRecovery& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const BlockRecovery& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DatanodeNamenode.BlockRecovery";
  }
  protected:
  explicit BlockRecovery(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DatanodeNamenode.BlockRecovery)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_DatanodeNamenode_2eproto;
};
// -------------------------------------------------------------------

class Finalize final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:DatanodeNamenode.Finalize) */ {
 public:
  inline Finalize() : Finalize(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Finalize(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Finalize(const Finalize& from);
  Finalize(Finalize&& from) noexcept
    : Finalize() {
    *this = ::std::move(from);
  }

  inline Finalize& operator=(const Finalize& from) {
    CopyFrom(from);
    return *this;
  }
  inline Finalize& operator=(Finalize&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Finalize& default_instance() {
    return *internal_default_instance();
  }
  static inline const Finalize* internal_default_instance() {
    return reinterpret_cast<const Finalize*>(
               &_Finalize_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Finalize& a, Finalize& b) {
    a.Swap(&b);
  }
  inline void Swap(Finalize* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Finalize* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Finalize* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Finalize>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Finalize& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Finalize& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DatanodeNamenode.Finalize";
  }
  protected:
  explicit Finalize(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DatanodeNamenode.Finalize)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_DatanodeNamenode_2eproto;
};
// -------------------------------------------------------------------

class KeyUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:DatanodeNamenode.KeyUpdate) */ {
 public:
  inline KeyUpdate() : KeyUpdate(nullptr) {}
  explicit PROTOBUF_CONSTEXPR KeyUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeyUpdate(const KeyUpdate& from);
  KeyUpdate(KeyUpdate&& from) noexcept
    : KeyUpdate() {
    *this = ::std::move(from);
  }

  inline KeyUpdate& operator=(const KeyUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyUpdate& operator=(KeyUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeyUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyUpdate* internal_default_instance() {
    return reinterpret_cast<const KeyUpdate*>(
               &_KeyUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(KeyUpdate& a, KeyUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(KeyUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeyUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KeyUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const KeyUpdate& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const KeyUpdate& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DatanodeNamenode.KeyUpdate";
  }
  protected:
  explicit KeyUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DatanodeNamenode.KeyUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_DatanodeNamenode_2eproto;
};
// -------------------------------------------------------------------

class Register final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:DatanodeNamenode.Register) */ {
 public:
  inline Register() : Register(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Register(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Register(const Register& from);
  Register(Register&& from) noexcept
    : Register() {
    *this = ::std::move(from);
  }

  inline Register& operator=(const Register& from) {
    CopyFrom(from);
    return *this;
  }
  inline Register& operator=(Register&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Register& default_instance() {
    return *internal_default_instance();
  }
  static inline const Register* internal_default_instance() {
    return reinterpret_cast<const Register*>(
               &_Register_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Register& a, Register& b) {
    a.Swap(&b);
  }
  inline void Swap(Register* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Register* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Register* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Register>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Register& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Register& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DatanodeNamenode.Register";
  }
  protected:
  explicit Register(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DatanodeNamenode.Register)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_DatanodeNamenode_2eproto;
};
// -------------------------------------------------------------------

class CacheCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DatanodeNamenode.CacheCommand) */ {
 public:
  inline CacheCommand() : CacheCommand(nullptr) {}
  ~CacheCommand() override;
  explicit PROTOBUF_CONSTEXPR CacheCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CacheCommand(const CacheCommand& from);
  CacheCommand(CacheCommand&& from) noexcept
    : CacheCommand() {
    *this = ::std::move(from);
  }

  inline CacheCommand& operator=(const CacheCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline CacheCommand& operator=(CacheCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CacheCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const CacheCommand* internal_default_instance() {
    return reinterpret_cast<const CacheCommand*>(
               &_CacheCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CacheCommand& a, CacheCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(CacheCommand* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CacheCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CacheCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CacheCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CacheCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CacheCommand& from) {
    CacheCommand::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CacheCommand* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DatanodeNamenode.CacheCommand";
  }
  protected:
  explicit CacheCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlocksFieldNumber = 1,
  };
  // repeated uint64 blocks = 1;
  int blocks_size() const;
  private:
  int _internal_blocks_size() const;
  public:
  void clear_blocks();
  private:
  uint64_t _internal_blocks(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_blocks() const;
  void _internal_add_blocks(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_blocks();
  public:
  uint64_t blocks(int index) const;
  void set_blocks(int index, uint64_t value);
  void add_blocks(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      blocks() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_blocks();

  // @@protoc_insertion_point(class_scope:DatanodeNamenode.CacheCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > blocks_;
    mutable std::atomic<int> _blocks_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_DatanodeNamenode_2eproto;
};
// -------------------------------------------------------------------

class BlockId final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DatanodeNamenode.BlockId) */ {
 public:
  inline BlockId() : BlockId(nullptr) {}
  ~BlockId() override;
  explicit PROTOBUF_CONSTEXPR BlockId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockId(const BlockId& from);
  BlockId(BlockId&& from) noexcept
    : BlockId() {
    *this = ::std::move(from);
  }

  inline BlockId& operator=(const BlockId& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockId& operator=(BlockId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockId& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockId* internal_default_instance() {
    return reinterpret_cast<const BlockId*>(
               &_BlockId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(BlockId& a, BlockId& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockId>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockId& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BlockId& from) {
    BlockId::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockId* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DatanodeNamenode.BlockId";
  }
  protected:
  explicit BlockId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef BlockId_Action Action;
  static constexpr Action CACHE =
    BlockId_Action_CACHE;
  static constexpr Action UNCACHE =
    BlockId_Action_UNCACHE;
  static inline bool Action_IsValid(int value) {
    return BlockId_Action_IsValid(value);
  }
  static constexpr Action Action_MIN =
    BlockId_Action_Action_MIN;
  static constexpr Action Action_MAX =
    BlockId_Action_Action_MAX;
  static constexpr int Action_ARRAYSIZE =
    BlockId_Action_Action_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Action_descriptor() {
    return BlockId_Action_descriptor();
  }
  template<typename T>
  static inline const std::string& Action_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Action>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Action_Name.");
    return BlockId_Action_Name(enum_t_value);
  }
  static inline bool Action_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Action* value) {
    return BlockId_Action_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kBlockIdsFieldNumber = 2,
    kActionFieldNumber = 1,
  };
  // repeated uint64 blockIds = 2;
  int blockids_size() const;
  private:
  int _internal_blockids_size() const;
  public:
  void clear_blockids();
  private:
  uint64_t _internal_blockids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_blockids() const;
  void _internal_add_blockids(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_blockids();
  public:
  uint64_t blockids(int index) const;
  void set_blockids(int index, uint64_t value);
  void add_blockids(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      blockids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_blockids();

  // .DatanodeNamenode.BlockId.Action action = 1;
  void clear_action();
  ::DatanodeNamenode::BlockId_Action action() const;
  void set_action(::DatanodeNamenode::BlockId_Action value);
  private:
  ::DatanodeNamenode::BlockId_Action _internal_action() const;
  void _internal_set_action(::DatanodeNamenode::BlockId_Action value);
  public:

  // @@protoc_insertion_point(class_scope:DatanodeNamenode.BlockId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > blockids_;
    mutable std::atomic<int> _blockids_cached_byte_size_;
    int action_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_DatanodeNamenode_2eproto;
};
// -------------------------------------------------------------------

class ReceivedDeletedBlockInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DatanodeNamenode.ReceivedDeletedBlockInfo) */ {
 public:
  inline ReceivedDeletedBlockInfo() : ReceivedDeletedBlockInfo(nullptr) {}
  ~ReceivedDeletedBlockInfo() override;
  explicit PROTOBUF_CONSTEXPR ReceivedDeletedBlockInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReceivedDeletedBlockInfo(const ReceivedDeletedBlockInfo& from);
  ReceivedDeletedBlockInfo(ReceivedDeletedBlockInfo&& from) noexcept
    : ReceivedDeletedBlockInfo() {
    *this = ::std::move(from);
  }

  inline ReceivedDeletedBlockInfo& operator=(const ReceivedDeletedBlockInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReceivedDeletedBlockInfo& operator=(ReceivedDeletedBlockInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReceivedDeletedBlockInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReceivedDeletedBlockInfo* internal_default_instance() {
    return reinterpret_cast<const ReceivedDeletedBlockInfo*>(
               &_ReceivedDeletedBlockInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ReceivedDeletedBlockInfo& a, ReceivedDeletedBlockInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ReceivedDeletedBlockInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReceivedDeletedBlockInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReceivedDeletedBlockInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReceivedDeletedBlockInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReceivedDeletedBlockInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReceivedDeletedBlockInfo& from) {
    ReceivedDeletedBlockInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReceivedDeletedBlockInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DatanodeNamenode.ReceivedDeletedBlockInfo";
  }
  protected:
  explicit ReceivedDeletedBlockInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ReceivedDeletedBlockInfo_BlockStatus BlockStatus;
  static constexpr BlockStatus RECEIVING =
    ReceivedDeletedBlockInfo_BlockStatus_RECEIVING;
  static constexpr BlockStatus RECEIVED =
    ReceivedDeletedBlockInfo_BlockStatus_RECEIVED;
  static constexpr BlockStatus DELETED =
    ReceivedDeletedBlockInfo_BlockStatus_DELETED;
  static inline bool BlockStatus_IsValid(int value) {
    return ReceivedDeletedBlockInfo_BlockStatus_IsValid(value);
  }
  static constexpr BlockStatus BlockStatus_MIN =
    ReceivedDeletedBlockInfo_BlockStatus_BlockStatus_MIN;
  static constexpr BlockStatus BlockStatus_MAX =
    ReceivedDeletedBlockInfo_BlockStatus_BlockStatus_MAX;
  static constexpr int BlockStatus_ARRAYSIZE =
    ReceivedDeletedBlockInfo_BlockStatus_BlockStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  BlockStatus_descriptor() {
    return ReceivedDeletedBlockInfo_BlockStatus_descriptor();
  }
  template<typename T>
  static inline const std::string& BlockStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, BlockStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function BlockStatus_Name.");
    return ReceivedDeletedBlockInfo_BlockStatus_Name(enum_t_value);
  }
  static inline bool BlockStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      BlockStatus* value) {
    return ReceivedDeletedBlockInfo_BlockStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kBlockFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // .Block block = 1;
  bool has_block() const;
  private:
  bool _internal_has_block() const;
  public:
  void clear_block();
  const ::Block& block() const;
  PROTOBUF_NODISCARD ::Block* release_block();
  ::Block* mutable_block();
  void set_allocated_block(::Block* block);
  private:
  const ::Block& _internal_block() const;
  ::Block* _internal_mutable_block();
  public:
  void unsafe_arena_set_allocated_block(
      ::Block* block);
  ::Block* unsafe_arena_release_block();

  // .DatanodeNamenode.ReceivedDeletedBlockInfo.BlockStatus status = 2;
  void clear_status();
  ::DatanodeNamenode::ReceivedDeletedBlockInfo_BlockStatus status() const;
  void set_status(::DatanodeNamenode::ReceivedDeletedBlockInfo_BlockStatus value);
  private:
  ::DatanodeNamenode::ReceivedDeletedBlockInfo_BlockStatus _internal_status() const;
  void _internal_set_status(::DatanodeNamenode::ReceivedDeletedBlockInfo_BlockStatus value);
  public:

  // @@protoc_insertion_point(class_scope:DatanodeNamenode.ReceivedDeletedBlockInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Block* block_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_DatanodeNamenode_2eproto;
};
// -------------------------------------------------------------------

class RegisterDatanodeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DatanodeNamenode.RegisterDatanodeRequest) */ {
 public:
  inline RegisterDatanodeRequest() : RegisterDatanodeRequest(nullptr) {}
  ~RegisterDatanodeRequest() override;
  explicit PROTOBUF_CONSTEXPR RegisterDatanodeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterDatanodeRequest(const RegisterDatanodeRequest& from);
  RegisterDatanodeRequest(RegisterDatanodeRequest&& from) noexcept
    : RegisterDatanodeRequest() {
    *this = ::std::move(from);
  }

  inline RegisterDatanodeRequest& operator=(const RegisterDatanodeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterDatanodeRequest& operator=(RegisterDatanodeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterDatanodeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterDatanodeRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterDatanodeRequest*>(
               &_RegisterDatanodeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(RegisterDatanodeRequest& a, RegisterDatanodeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterDatanodeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterDatanodeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterDatanodeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterDatanodeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterDatanodeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegisterDatanodeRequest& from) {
    RegisterDatanodeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterDatanodeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DatanodeNamenode.RegisterDatanodeRequest";
  }
  protected:
  explicit RegisterDatanodeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegistrationFieldNumber = 1,
  };
  // .DatanodeNamenode.DatanodeRegister registration = 1;
  bool has_registration() const;
  private:
  bool _internal_has_registration() const;
  public:
  void clear_registration();
  const ::DatanodeNamenode::DatanodeRegister& registration() const;
  PROTOBUF_NODISCARD ::DatanodeNamenode::DatanodeRegister* release_registration();
  ::DatanodeNamenode::DatanodeRegister* mutable_registration();
  void set_allocated_registration(::DatanodeNamenode::DatanodeRegister* registration);
  private:
  const ::DatanodeNamenode::DatanodeRegister& _internal_registration() const;
  ::DatanodeNamenode::DatanodeRegister* _internal_mutable_registration();
  public:
  void unsafe_arena_set_allocated_registration(
      ::DatanodeNamenode::DatanodeRegister* registration);
  ::DatanodeNamenode::DatanodeRegister* unsafe_arena_release_registration();

  // @@protoc_insertion_point(class_scope:DatanodeNamenode.RegisterDatanodeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::DatanodeNamenode::DatanodeRegister* registration_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_DatanodeNamenode_2eproto;
};
// -------------------------------------------------------------------

class RegisterDatanodeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DatanodeNamenode.RegisterDatanodeResponse) */ {
 public:
  inline RegisterDatanodeResponse() : RegisterDatanodeResponse(nullptr) {}
  ~RegisterDatanodeResponse() override;
  explicit PROTOBUF_CONSTEXPR RegisterDatanodeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterDatanodeResponse(const RegisterDatanodeResponse& from);
  RegisterDatanodeResponse(RegisterDatanodeResponse&& from) noexcept
    : RegisterDatanodeResponse() {
    *this = ::std::move(from);
  }

  inline RegisterDatanodeResponse& operator=(const RegisterDatanodeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterDatanodeResponse& operator=(RegisterDatanodeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterDatanodeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterDatanodeResponse* internal_default_instance() {
    return reinterpret_cast<const RegisterDatanodeResponse*>(
               &_RegisterDatanodeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(RegisterDatanodeResponse& a, RegisterDatanodeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterDatanodeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterDatanodeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterDatanodeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterDatanodeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterDatanodeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegisterDatanodeResponse& from) {
    RegisterDatanodeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterDatanodeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DatanodeNamenode.RegisterDatanodeResponse";
  }
  protected:
  explicit RegisterDatanodeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegistrationFieldNumber = 1,
  };
  // .DatanodeNamenode.DatanodeRegister registration = 1;
  bool has_registration() const;
  private:
  bool _internal_has_registration() const;
  public:
  void clear_registration();
  const ::DatanodeNamenode::DatanodeRegister& registration() const;
  PROTOBUF_NODISCARD ::DatanodeNamenode::DatanodeRegister* release_registration();
  ::DatanodeNamenode::DatanodeRegister* mutable_registration();
  void set_allocated_registration(::DatanodeNamenode::DatanodeRegister* registration);
  private:
  const ::DatanodeNamenode::DatanodeRegister& _internal_registration() const;
  ::DatanodeNamenode::DatanodeRegister* _internal_mutable_registration();
  public:
  void unsafe_arena_set_allocated_registration(
      ::DatanodeNamenode::DatanodeRegister* registration);
  ::DatanodeNamenode::DatanodeRegister* unsafe_arena_release_registration();

  // @@protoc_insertion_point(class_scope:DatanodeNamenode.RegisterDatanodeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::DatanodeNamenode::DatanodeRegister* registration_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_DatanodeNamenode_2eproto;
};
// -------------------------------------------------------------------

class HeartBeatRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DatanodeNamenode.HeartBeatRequest) */ {
 public:
  inline HeartBeatRequest() : HeartBeatRequest(nullptr) {}
  ~HeartBeatRequest() override;
  explicit PROTOBUF_CONSTEXPR HeartBeatRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeartBeatRequest(const HeartBeatRequest& from);
  HeartBeatRequest(HeartBeatRequest&& from) noexcept
    : HeartBeatRequest() {
    *this = ::std::move(from);
  }

  inline HeartBeatRequest& operator=(const HeartBeatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeartBeatRequest& operator=(HeartBeatRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeartBeatRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeartBeatRequest* internal_default_instance() {
    return reinterpret_cast<const HeartBeatRequest*>(
               &_HeartBeatRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(HeartBeatRequest& a, HeartBeatRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HeartBeatRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeartBeatRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeartBeatRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeartBeatRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HeartBeatRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HeartBeatRequest& from) {
    HeartBeatRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeartBeatRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DatanodeNamenode.HeartBeatRequest";
  }
  protected:
  explicit HeartBeatRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegistrationFieldNumber = 1,
    kXmitsInProgressFieldNumber = 3,
    kXceiverCountFieldNumber = 4,
    kCacheCapacityFieldNumber = 6,
    kCacheUsedFieldNumber = 7,
    kFailedVolumsFieldNumber = 5,
  };
  // .DatanodeNamenode.DatanodeRegister registration = 1;
  bool has_registration() const;
  private:
  bool _internal_has_registration() const;
  public:
  void clear_registration();
  const ::DatanodeNamenode::DatanodeRegister& registration() const;
  PROTOBUF_NODISCARD ::DatanodeNamenode::DatanodeRegister* release_registration();
  ::DatanodeNamenode::DatanodeRegister* mutable_registration();
  void set_allocated_registration(::DatanodeNamenode::DatanodeRegister* registration);
  private:
  const ::DatanodeNamenode::DatanodeRegister& _internal_registration() const;
  ::DatanodeNamenode::DatanodeRegister* _internal_mutable_registration();
  public:
  void unsafe_arena_set_allocated_registration(
      ::DatanodeNamenode::DatanodeRegister* registration);
  ::DatanodeNamenode::DatanodeRegister* unsafe_arena_release_registration();

  // optional uint32 xmitsInProgress = 3;
  bool has_xmitsinprogress() const;
  private:
  bool _internal_has_xmitsinprogress() const;
  public:
  void clear_xmitsinprogress();
  uint32_t xmitsinprogress() const;
  void set_xmitsinprogress(uint32_t value);
  private:
  uint32_t _internal_xmitsinprogress() const;
  void _internal_set_xmitsinprogress(uint32_t value);
  public:

  // optional uint32 xceiverCount = 4;
  bool has_xceivercount() const;
  private:
  bool _internal_has_xceivercount() const;
  public:
  void clear_xceivercount();
  uint32_t xceivercount() const;
  void set_xceivercount(uint32_t value);
  private:
  uint32_t _internal_xceivercount() const;
  void _internal_set_xceivercount(uint32_t value);
  public:

  // optional uint64 cacheCapacity = 6;
  bool has_cachecapacity() const;
  private:
  bool _internal_has_cachecapacity() const;
  public:
  void clear_cachecapacity();
  uint64_t cachecapacity() const;
  void set_cachecapacity(uint64_t value);
  private:
  uint64_t _internal_cachecapacity() const;
  void _internal_set_cachecapacity(uint64_t value);
  public:

  // optional uint64 cacheUsed = 7;
  bool has_cacheused() const;
  private:
  bool _internal_has_cacheused() const;
  public:
  void clear_cacheused();
  uint64_t cacheused() const;
  void set_cacheused(uint64_t value);
  private:
  uint64_t _internal_cacheused() const;
  void _internal_set_cacheused(uint64_t value);
  public:

  // optional uint32 failedVolums = 5;
  bool has_failedvolums() const;
  private:
  bool _internal_has_failedvolums() const;
  public:
  void clear_failedvolums();
  uint32_t failedvolums() const;
  void set_failedvolums(uint32_t value);
  private:
  uint32_t _internal_failedvolums() const;
  void _internal_set_failedvolums(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:DatanodeNamenode.HeartBeatRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::DatanodeNamenode::DatanodeRegister* registration_;
    uint32_t xmitsinprogress_;
    uint32_t xceivercount_;
    uint64_t cachecapacity_;
    uint64_t cacheused_;
    uint32_t failedvolums_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_DatanodeNamenode_2eproto;
};
// -------------------------------------------------------------------

class HeartBeatResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DatanodeNamenode.HeartBeatResponse) */ {
 public:
  inline HeartBeatResponse() : HeartBeatResponse(nullptr) {}
  ~HeartBeatResponse() override;
  explicit PROTOBUF_CONSTEXPR HeartBeatResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeartBeatResponse(const HeartBeatResponse& from);
  HeartBeatResponse(HeartBeatResponse&& from) noexcept
    : HeartBeatResponse() {
    *this = ::std::move(from);
  }

  inline HeartBeatResponse& operator=(const HeartBeatResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeartBeatResponse& operator=(HeartBeatResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeartBeatResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeartBeatResponse* internal_default_instance() {
    return reinterpret_cast<const HeartBeatResponse*>(
               &_HeartBeatResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(HeartBeatResponse& a, HeartBeatResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(HeartBeatResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeartBeatResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeartBeatResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeartBeatResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HeartBeatResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HeartBeatResponse& from) {
    HeartBeatResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeartBeatResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DatanodeNamenode.HeartBeatResponse";
  }
  protected:
  explicit HeartBeatResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCmdsFieldNumber = 1,
  };
  // repeated .DatanodeNamenode.DatanodeCommand cmds = 1;
  int cmds_size() const;
  private:
  int _internal_cmds_size() const;
  public:
  void clear_cmds();
  ::DatanodeNamenode::DatanodeCommand* mutable_cmds(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DatanodeNamenode::DatanodeCommand >*
      mutable_cmds();
  private:
  const ::DatanodeNamenode::DatanodeCommand& _internal_cmds(int index) const;
  ::DatanodeNamenode::DatanodeCommand* _internal_add_cmds();
  public:
  const ::DatanodeNamenode::DatanodeCommand& cmds(int index) const;
  ::DatanodeNamenode::DatanodeCommand* add_cmds();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DatanodeNamenode::DatanodeCommand >&
      cmds() const;

  // @@protoc_insertion_point(class_scope:DatanodeNamenode.HeartBeatResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DatanodeNamenode::DatanodeCommand > cmds_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_DatanodeNamenode_2eproto;
};
// -------------------------------------------------------------------

class blockReportRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:DatanodeNamenode.blockReportRequest) */ {
 public:
  inline blockReportRequest() : blockReportRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR blockReportRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  blockReportRequest(const blockReportRequest& from);
  blockReportRequest(blockReportRequest&& from) noexcept
    : blockReportRequest() {
    *this = ::std::move(from);
  }

  inline blockReportRequest& operator=(const blockReportRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline blockReportRequest& operator=(blockReportRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const blockReportRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const blockReportRequest* internal_default_instance() {
    return reinterpret_cast<const blockReportRequest*>(
               &_blockReportRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(blockReportRequest& a, blockReportRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(blockReportRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(blockReportRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  blockReportRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<blockReportRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const blockReportRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const blockReportRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DatanodeNamenode.blockReportRequest";
  }
  protected:
  explicit blockReportRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DatanodeNamenode.blockReportRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_DatanodeNamenode_2eproto;
};
// -------------------------------------------------------------------

class blockReportResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:DatanodeNamenode.blockReportResponse) */ {
 public:
  inline blockReportResponse() : blockReportResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR blockReportResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  blockReportResponse(const blockReportResponse& from);
  blockReportResponse(blockReportResponse&& from) noexcept
    : blockReportResponse() {
    *this = ::std::move(from);
  }

  inline blockReportResponse& operator=(const blockReportResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline blockReportResponse& operator=(blockReportResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const blockReportResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const blockReportResponse* internal_default_instance() {
    return reinterpret_cast<const blockReportResponse*>(
               &_blockReportResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(blockReportResponse& a, blockReportResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(blockReportResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(blockReportResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  blockReportResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<blockReportResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const blockReportResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const blockReportResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DatanodeNamenode.blockReportResponse";
  }
  protected:
  explicit blockReportResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DatanodeNamenode.blockReportResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_DatanodeNamenode_2eproto;
};
// -------------------------------------------------------------------

class cacheReportRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:DatanodeNamenode.cacheReportRequest) */ {
 public:
  inline cacheReportRequest() : cacheReportRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR cacheReportRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  cacheReportRequest(const cacheReportRequest& from);
  cacheReportRequest(cacheReportRequest&& from) noexcept
    : cacheReportRequest() {
    *this = ::std::move(from);
  }

  inline cacheReportRequest& operator=(const cacheReportRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline cacheReportRequest& operator=(cacheReportRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const cacheReportRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const cacheReportRequest* internal_default_instance() {
    return reinterpret_cast<const cacheReportRequest*>(
               &_cacheReportRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(cacheReportRequest& a, cacheReportRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(cacheReportRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(cacheReportRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  cacheReportRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<cacheReportRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const cacheReportRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const cacheReportRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DatanodeNamenode.cacheReportRequest";
  }
  protected:
  explicit cacheReportRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DatanodeNamenode.cacheReportRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_DatanodeNamenode_2eproto;
};
// -------------------------------------------------------------------

class cacheReportResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:DatanodeNamenode.cacheReportResponse) */ {
 public:
  inline cacheReportResponse() : cacheReportResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR cacheReportResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  cacheReportResponse(const cacheReportResponse& from);
  cacheReportResponse(cacheReportResponse&& from) noexcept
    : cacheReportResponse() {
    *this = ::std::move(from);
  }

  inline cacheReportResponse& operator=(const cacheReportResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline cacheReportResponse& operator=(cacheReportResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const cacheReportResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const cacheReportResponse* internal_default_instance() {
    return reinterpret_cast<const cacheReportResponse*>(
               &_cacheReportResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(cacheReportResponse& a, cacheReportResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(cacheReportResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(cacheReportResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  cacheReportResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<cacheReportResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const cacheReportResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const cacheReportResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DatanodeNamenode.cacheReportResponse";
  }
  protected:
  explicit cacheReportResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DatanodeNamenode.cacheReportResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_DatanodeNamenode_2eproto;
};
// -------------------------------------------------------------------

class BlockReceivedAndDeletedRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DatanodeNamenode.BlockReceivedAndDeletedRequest) */ {
 public:
  inline BlockReceivedAndDeletedRequest() : BlockReceivedAndDeletedRequest(nullptr) {}
  ~BlockReceivedAndDeletedRequest() override;
  explicit PROTOBUF_CONSTEXPR BlockReceivedAndDeletedRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockReceivedAndDeletedRequest(const BlockReceivedAndDeletedRequest& from);
  BlockReceivedAndDeletedRequest(BlockReceivedAndDeletedRequest&& from) noexcept
    : BlockReceivedAndDeletedRequest() {
    *this = ::std::move(from);
  }

  inline BlockReceivedAndDeletedRequest& operator=(const BlockReceivedAndDeletedRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockReceivedAndDeletedRequest& operator=(BlockReceivedAndDeletedRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockReceivedAndDeletedRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockReceivedAndDeletedRequest* internal_default_instance() {
    return reinterpret_cast<const BlockReceivedAndDeletedRequest*>(
               &_BlockReceivedAndDeletedRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(BlockReceivedAndDeletedRequest& a, BlockReceivedAndDeletedRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockReceivedAndDeletedRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockReceivedAndDeletedRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockReceivedAndDeletedRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockReceivedAndDeletedRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockReceivedAndDeletedRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BlockReceivedAndDeletedRequest& from) {
    BlockReceivedAndDeletedRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockReceivedAndDeletedRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DatanodeNamenode.BlockReceivedAndDeletedRequest";
  }
  protected:
  explicit BlockReceivedAndDeletedRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlocksFieldNumber = 2,
    kRegistrationFieldNumber = 1,
  };
  // repeated .DatanodeNamenode.ReceivedDeletedBlockInfo blocks = 2;
  int blocks_size() const;
  private:
  int _internal_blocks_size() const;
  public:
  void clear_blocks();
  ::DatanodeNamenode::ReceivedDeletedBlockInfo* mutable_blocks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DatanodeNamenode::ReceivedDeletedBlockInfo >*
      mutable_blocks();
  private:
  const ::DatanodeNamenode::ReceivedDeletedBlockInfo& _internal_blocks(int index) const;
  ::DatanodeNamenode::ReceivedDeletedBlockInfo* _internal_add_blocks();
  public:
  const ::DatanodeNamenode::ReceivedDeletedBlockInfo& blocks(int index) const;
  ::DatanodeNamenode::ReceivedDeletedBlockInfo* add_blocks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DatanodeNamenode::ReceivedDeletedBlockInfo >&
      blocks() const;

  // .DatanodeNamenode.DatanodeRegister registration = 1;
  bool has_registration() const;
  private:
  bool _internal_has_registration() const;
  public:
  void clear_registration();
  const ::DatanodeNamenode::DatanodeRegister& registration() const;
  PROTOBUF_NODISCARD ::DatanodeNamenode::DatanodeRegister* release_registration();
  ::DatanodeNamenode::DatanodeRegister* mutable_registration();
  void set_allocated_registration(::DatanodeNamenode::DatanodeRegister* registration);
  private:
  const ::DatanodeNamenode::DatanodeRegister& _internal_registration() const;
  ::DatanodeNamenode::DatanodeRegister* _internal_mutable_registration();
  public:
  void unsafe_arena_set_allocated_registration(
      ::DatanodeNamenode::DatanodeRegister* registration);
  ::DatanodeNamenode::DatanodeRegister* unsafe_arena_release_registration();

  // @@protoc_insertion_point(class_scope:DatanodeNamenode.BlockReceivedAndDeletedRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DatanodeNamenode::ReceivedDeletedBlockInfo > blocks_;
    ::DatanodeNamenode::DatanodeRegister* registration_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_DatanodeNamenode_2eproto;
};
// -------------------------------------------------------------------

class BlockReceivedAndDeletedResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:DatanodeNamenode.BlockReceivedAndDeletedResponse) */ {
 public:
  inline BlockReceivedAndDeletedResponse() : BlockReceivedAndDeletedResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR BlockReceivedAndDeletedResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockReceivedAndDeletedResponse(const BlockReceivedAndDeletedResponse& from);
  BlockReceivedAndDeletedResponse(BlockReceivedAndDeletedResponse&& from) noexcept
    : BlockReceivedAndDeletedResponse() {
    *this = ::std::move(from);
  }

  inline BlockReceivedAndDeletedResponse& operator=(const BlockReceivedAndDeletedResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockReceivedAndDeletedResponse& operator=(BlockReceivedAndDeletedResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockReceivedAndDeletedResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockReceivedAndDeletedResponse* internal_default_instance() {
    return reinterpret_cast<const BlockReceivedAndDeletedResponse*>(
               &_BlockReceivedAndDeletedResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(BlockReceivedAndDeletedResponse& a, BlockReceivedAndDeletedResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockReceivedAndDeletedResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockReceivedAndDeletedResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockReceivedAndDeletedResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockReceivedAndDeletedResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const BlockReceivedAndDeletedResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const BlockReceivedAndDeletedResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DatanodeNamenode.BlockReceivedAndDeletedResponse";
  }
  protected:
  explicit BlockReceivedAndDeletedResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DatanodeNamenode.BlockReceivedAndDeletedResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_DatanodeNamenode_2eproto;
};
// -------------------------------------------------------------------

class ErrorReportRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DatanodeNamenode.ErrorReportRequest) */ {
 public:
  inline ErrorReportRequest() : ErrorReportRequest(nullptr) {}
  ~ErrorReportRequest() override;
  explicit PROTOBUF_CONSTEXPR ErrorReportRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ErrorReportRequest(const ErrorReportRequest& from);
  ErrorReportRequest(ErrorReportRequest&& from) noexcept
    : ErrorReportRequest() {
    *this = ::std::move(from);
  }

  inline ErrorReportRequest& operator=(const ErrorReportRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ErrorReportRequest& operator=(ErrorReportRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ErrorReportRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ErrorReportRequest* internal_default_instance() {
    return reinterpret_cast<const ErrorReportRequest*>(
               &_ErrorReportRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(ErrorReportRequest& a, ErrorReportRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ErrorReportRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ErrorReportRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ErrorReportRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ErrorReportRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ErrorReportRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ErrorReportRequest& from) {
    ErrorReportRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ErrorReportRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DatanodeNamenode.ErrorReportRequest";
  }
  protected:
  explicit ErrorReportRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ErrorReportRequest_ErrorCode ErrorCode;
  static constexpr ErrorCode NOTIFY =
    ErrorReportRequest_ErrorCode_NOTIFY;
  static constexpr ErrorCode DISK_ERROR =
    ErrorReportRequest_ErrorCode_DISK_ERROR;
  static constexpr ErrorCode INVALID_BLOCK =
    ErrorReportRequest_ErrorCode_INVALID_BLOCK;
  static constexpr ErrorCode FATAL_DISK_ERROR =
    ErrorReportRequest_ErrorCode_FATAL_DISK_ERROR;
  static inline bool ErrorCode_IsValid(int value) {
    return ErrorReportRequest_ErrorCode_IsValid(value);
  }
  static constexpr ErrorCode ErrorCode_MIN =
    ErrorReportRequest_ErrorCode_ErrorCode_MIN;
  static constexpr ErrorCode ErrorCode_MAX =
    ErrorReportRequest_ErrorCode_ErrorCode_MAX;
  static constexpr int ErrorCode_ARRAYSIZE =
    ErrorReportRequest_ErrorCode_ErrorCode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ErrorCode_descriptor() {
    return ErrorReportRequest_ErrorCode_descriptor();
  }
  template<typename T>
  static inline const std::string& ErrorCode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ErrorCode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ErrorCode_Name.");
    return ErrorReportRequest_ErrorCode_Name(enum_t_value);
  }
  static inline bool ErrorCode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ErrorCode* value) {
    return ErrorReportRequest_ErrorCode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 3,
    kRegistrationFieldNumber = 1,
    kErrorCodeFieldNumber = 2,
  };
  // string msg = 3;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // .DatanodeNamenode.DatanodeRegister registration = 1;
  bool has_registration() const;
  private:
  bool _internal_has_registration() const;
  public:
  void clear_registration();
  const ::DatanodeNamenode::DatanodeRegister& registration() const;
  PROTOBUF_NODISCARD ::DatanodeNamenode::DatanodeRegister* release_registration();
  ::DatanodeNamenode::DatanodeRegister* mutable_registration();
  void set_allocated_registration(::DatanodeNamenode::DatanodeRegister* registration);
  private:
  const ::DatanodeNamenode::DatanodeRegister& _internal_registration() const;
  ::DatanodeNamenode::DatanodeRegister* _internal_mutable_registration();
  public:
  void unsafe_arena_set_allocated_registration(
      ::DatanodeNamenode::DatanodeRegister* registration);
  ::DatanodeNamenode::DatanodeRegister* unsafe_arena_release_registration();

  // .DatanodeNamenode.ErrorReportRequest.ErrorCode errorCode = 2;
  void clear_errorcode();
  ::DatanodeNamenode::ErrorReportRequest_ErrorCode errorcode() const;
  void set_errorcode(::DatanodeNamenode::ErrorReportRequest_ErrorCode value);
  private:
  ::DatanodeNamenode::ErrorReportRequest_ErrorCode _internal_errorcode() const;
  void _internal_set_errorcode(::DatanodeNamenode::ErrorReportRequest_ErrorCode value);
  public:

  // @@protoc_insertion_point(class_scope:DatanodeNamenode.ErrorReportRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    ::DatanodeNamenode::DatanodeRegister* registration_;
    int errorcode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_DatanodeNamenode_2eproto;
};
// -------------------------------------------------------------------

class ErrorReportResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:DatanodeNamenode.ErrorReportResponse) */ {
 public:
  inline ErrorReportResponse() : ErrorReportResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ErrorReportResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ErrorReportResponse(const ErrorReportResponse& from);
  ErrorReportResponse(ErrorReportResponse&& from) noexcept
    : ErrorReportResponse() {
    *this = ::std::move(from);
  }

  inline ErrorReportResponse& operator=(const ErrorReportResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ErrorReportResponse& operator=(ErrorReportResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ErrorReportResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ErrorReportResponse* internal_default_instance() {
    return reinterpret_cast<const ErrorReportResponse*>(
               &_ErrorReportResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(ErrorReportResponse& a, ErrorReportResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ErrorReportResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ErrorReportResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ErrorReportResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ErrorReportResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ErrorReportResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ErrorReportResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DatanodeNamenode.ErrorReportResponse";
  }
  protected:
  explicit ErrorReportResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DatanodeNamenode.ErrorReportResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_DatanodeNamenode_2eproto;
};
// -------------------------------------------------------------------

class ReportBadBlockRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DatanodeNamenode.ReportBadBlockRequest) */ {
 public:
  inline ReportBadBlockRequest() : ReportBadBlockRequest(nullptr) {}
  ~ReportBadBlockRequest() override;
  explicit PROTOBUF_CONSTEXPR ReportBadBlockRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReportBadBlockRequest(const ReportBadBlockRequest& from);
  ReportBadBlockRequest(ReportBadBlockRequest&& from) noexcept
    : ReportBadBlockRequest() {
    *this = ::std::move(from);
  }

  inline ReportBadBlockRequest& operator=(const ReportBadBlockRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReportBadBlockRequest& operator=(ReportBadBlockRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReportBadBlockRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReportBadBlockRequest* internal_default_instance() {
    return reinterpret_cast<const ReportBadBlockRequest*>(
               &_ReportBadBlockRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(ReportBadBlockRequest& a, ReportBadBlockRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReportBadBlockRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReportBadBlockRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReportBadBlockRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReportBadBlockRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReportBadBlockRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReportBadBlockRequest& from) {
    ReportBadBlockRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReportBadBlockRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DatanodeNamenode.ReportBadBlockRequest";
  }
  protected:
  explicit ReportBadBlockRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlocksFieldNumber = 1,
  };
  // repeated .LocatedBlock blocks = 1;
  int blocks_size() const;
  private:
  int _internal_blocks_size() const;
  public:
  void clear_blocks();
  ::LocatedBlock* mutable_blocks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LocatedBlock >*
      mutable_blocks();
  private:
  const ::LocatedBlock& _internal_blocks(int index) const;
  ::LocatedBlock* _internal_add_blocks();
  public:
  const ::LocatedBlock& blocks(int index) const;
  ::LocatedBlock* add_blocks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LocatedBlock >&
      blocks() const;

  // @@protoc_insertion_point(class_scope:DatanodeNamenode.ReportBadBlockRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LocatedBlock > blocks_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_DatanodeNamenode_2eproto;
};
// -------------------------------------------------------------------

class ReportBadBlockResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:DatanodeNamenode.ReportBadBlockResponse) */ {
 public:
  inline ReportBadBlockResponse() : ReportBadBlockResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ReportBadBlockResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReportBadBlockResponse(const ReportBadBlockResponse& from);
  ReportBadBlockResponse(ReportBadBlockResponse&& from) noexcept
    : ReportBadBlockResponse() {
    *this = ::std::move(from);
  }

  inline ReportBadBlockResponse& operator=(const ReportBadBlockResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReportBadBlockResponse& operator=(ReportBadBlockResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReportBadBlockResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReportBadBlockResponse* internal_default_instance() {
    return reinterpret_cast<const ReportBadBlockResponse*>(
               &_ReportBadBlockResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(ReportBadBlockResponse& a, ReportBadBlockResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ReportBadBlockResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReportBadBlockResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReportBadBlockResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReportBadBlockResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ReportBadBlockResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ReportBadBlockResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DatanodeNamenode.ReportBadBlockResponse";
  }
  protected:
  explicit ReportBadBlockResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DatanodeNamenode.ReportBadBlockResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_DatanodeNamenode_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DatanodeRegister

// .DatanodeID id = 1;
inline bool DatanodeRegister::_internal_has_id() const {
  return this != internal_default_instance() && _impl_.id_ != nullptr;
}
inline bool DatanodeRegister::has_id() const {
  return _internal_has_id();
}
inline const ::DatanodeID& DatanodeRegister::_internal_id() const {
  const ::DatanodeID* p = _impl_.id_;
  return p != nullptr ? *p : reinterpret_cast<const ::DatanodeID&>(
      ::_DatanodeID_default_instance_);
}
inline const ::DatanodeID& DatanodeRegister::id() const {
  // @@protoc_insertion_point(field_get:DatanodeNamenode.DatanodeRegister.id)
  return _internal_id();
}
inline void DatanodeRegister::unsafe_arena_set_allocated_id(
    ::DatanodeID* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.id_);
  }
  _impl_.id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DatanodeNamenode.DatanodeRegister.id)
}
inline ::DatanodeID* DatanodeRegister::release_id() {
  
  ::DatanodeID* temp = _impl_.id_;
  _impl_.id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DatanodeID* DatanodeRegister::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:DatanodeNamenode.DatanodeRegister.id)
  
  ::DatanodeID* temp = _impl_.id_;
  _impl_.id_ = nullptr;
  return temp;
}
inline ::DatanodeID* DatanodeRegister::_internal_mutable_id() {
  
  if (_impl_.id_ == nullptr) {
    auto* p = CreateMaybeMessage<::DatanodeID>(GetArenaForAllocation());
    _impl_.id_ = p;
  }
  return _impl_.id_;
}
inline ::DatanodeID* DatanodeRegister::mutable_id() {
  ::DatanodeID* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:DatanodeNamenode.DatanodeRegister.id)
  return _msg;
}
inline void DatanodeRegister::set_allocated_id(::DatanodeID* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.id_);
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id));
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.id_ = id;
  // @@protoc_insertion_point(field_set_allocated:DatanodeNamenode.DatanodeRegister.id)
}

// .DatanodeInfo info = 2;
inline bool DatanodeRegister::_internal_has_info() const {
  return this != internal_default_instance() && _impl_.info_ != nullptr;
}
inline bool DatanodeRegister::has_info() const {
  return _internal_has_info();
}
inline const ::DatanodeInfo& DatanodeRegister::_internal_info() const {
  const ::DatanodeInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::DatanodeInfo&>(
      ::_DatanodeInfo_default_instance_);
}
inline const ::DatanodeInfo& DatanodeRegister::info() const {
  // @@protoc_insertion_point(field_get:DatanodeNamenode.DatanodeRegister.info)
  return _internal_info();
}
inline void DatanodeRegister::unsafe_arena_set_allocated_info(
    ::DatanodeInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DatanodeNamenode.DatanodeRegister.info)
}
inline ::DatanodeInfo* DatanodeRegister::release_info() {
  
  ::DatanodeInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DatanodeInfo* DatanodeRegister::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:DatanodeNamenode.DatanodeRegister.info)
  
  ::DatanodeInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::DatanodeInfo* DatanodeRegister::_internal_mutable_info() {
  
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::DatanodeInfo>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::DatanodeInfo* DatanodeRegister::mutable_info() {
  ::DatanodeInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:DatanodeNamenode.DatanodeRegister.info)
  return _msg;
}
inline void DatanodeRegister::set_allocated_info(::DatanodeInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info));
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:DatanodeNamenode.DatanodeRegister.info)
}

// string softwareVersion = 3;
inline void DatanodeRegister::clear_softwareversion() {
  _impl_.softwareversion_.ClearToEmpty();
}
inline const std::string& DatanodeRegister::softwareversion() const {
  // @@protoc_insertion_point(field_get:DatanodeNamenode.DatanodeRegister.softwareVersion)
  return _internal_softwareversion();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DatanodeRegister::set_softwareversion(ArgT0&& arg0, ArgT... args) {
 
 _impl_.softwareversion_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DatanodeNamenode.DatanodeRegister.softwareVersion)
}
inline std::string* DatanodeRegister::mutable_softwareversion() {
  std::string* _s = _internal_mutable_softwareversion();
  // @@protoc_insertion_point(field_mutable:DatanodeNamenode.DatanodeRegister.softwareVersion)
  return _s;
}
inline const std::string& DatanodeRegister::_internal_softwareversion() const {
  return _impl_.softwareversion_.Get();
}
inline void DatanodeRegister::_internal_set_softwareversion(const std::string& value) {
  
  _impl_.softwareversion_.Set(value, GetArenaForAllocation());
}
inline std::string* DatanodeRegister::_internal_mutable_softwareversion() {
  
  return _impl_.softwareversion_.Mutable(GetArenaForAllocation());
}
inline std::string* DatanodeRegister::release_softwareversion() {
  // @@protoc_insertion_point(field_release:DatanodeNamenode.DatanodeRegister.softwareVersion)
  return _impl_.softwareversion_.Release();
}
inline void DatanodeRegister::set_allocated_softwareversion(std::string* softwareversion) {
  if (softwareversion != nullptr) {
    
  } else {
    
  }
  _impl_.softwareversion_.SetAllocated(softwareversion, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.softwareversion_.IsDefault()) {
    _impl_.softwareversion_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DatanodeNamenode.DatanodeRegister.softwareVersion)
}

// -------------------------------------------------------------------

// DatanodeCommand

// .DatanodeNamenode.DatanodeCommand.Type commandType = 1;
inline void DatanodeCommand::clear_commandtype() {
  _impl_.commandtype_ = 0;
}
inline ::DatanodeNamenode::DatanodeCommand_Type DatanodeCommand::_internal_commandtype() const {
  return static_cast< ::DatanodeNamenode::DatanodeCommand_Type >(_impl_.commandtype_);
}
inline ::DatanodeNamenode::DatanodeCommand_Type DatanodeCommand::commandtype() const {
  // @@protoc_insertion_point(field_get:DatanodeNamenode.DatanodeCommand.commandType)
  return _internal_commandtype();
}
inline void DatanodeCommand::_internal_set_commandtype(::DatanodeNamenode::DatanodeCommand_Type value) {
  
  _impl_.commandtype_ = value;
}
inline void DatanodeCommand::set_commandtype(::DatanodeNamenode::DatanodeCommand_Type value) {
  _internal_set_commandtype(value);
  // @@protoc_insertion_point(field_set:DatanodeNamenode.DatanodeCommand.commandType)
}

// optional .DatanodeNamenode.BalanceBandwidth balanceCmd = 2;
inline bool DatanodeCommand::_internal_has_balancecmd() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.balancecmd_ != nullptr);
  return value;
}
inline bool DatanodeCommand::has_balancecmd() const {
  return _internal_has_balancecmd();
}
inline void DatanodeCommand::clear_balancecmd() {
  if (_impl_.balancecmd_ != nullptr) _impl_.balancecmd_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::DatanodeNamenode::BalanceBandwidth& DatanodeCommand::_internal_balancecmd() const {
  const ::DatanodeNamenode::BalanceBandwidth* p = _impl_.balancecmd_;
  return p != nullptr ? *p : reinterpret_cast<const ::DatanodeNamenode::BalanceBandwidth&>(
      ::DatanodeNamenode::_BalanceBandwidth_default_instance_);
}
inline const ::DatanodeNamenode::BalanceBandwidth& DatanodeCommand::balancecmd() const {
  // @@protoc_insertion_point(field_get:DatanodeNamenode.DatanodeCommand.balanceCmd)
  return _internal_balancecmd();
}
inline void DatanodeCommand::unsafe_arena_set_allocated_balancecmd(
    ::DatanodeNamenode::BalanceBandwidth* balancecmd) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.balancecmd_);
  }
  _impl_.balancecmd_ = balancecmd;
  if (balancecmd) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DatanodeNamenode.DatanodeCommand.balanceCmd)
}
inline ::DatanodeNamenode::BalanceBandwidth* DatanodeCommand::release_balancecmd() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DatanodeNamenode::BalanceBandwidth* temp = _impl_.balancecmd_;
  _impl_.balancecmd_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DatanodeNamenode::BalanceBandwidth* DatanodeCommand::unsafe_arena_release_balancecmd() {
  // @@protoc_insertion_point(field_release:DatanodeNamenode.DatanodeCommand.balanceCmd)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DatanodeNamenode::BalanceBandwidth* temp = _impl_.balancecmd_;
  _impl_.balancecmd_ = nullptr;
  return temp;
}
inline ::DatanodeNamenode::BalanceBandwidth* DatanodeCommand::_internal_mutable_balancecmd() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.balancecmd_ == nullptr) {
    auto* p = CreateMaybeMessage<::DatanodeNamenode::BalanceBandwidth>(GetArenaForAllocation());
    _impl_.balancecmd_ = p;
  }
  return _impl_.balancecmd_;
}
inline ::DatanodeNamenode::BalanceBandwidth* DatanodeCommand::mutable_balancecmd() {
  ::DatanodeNamenode::BalanceBandwidth* _msg = _internal_mutable_balancecmd();
  // @@protoc_insertion_point(field_mutable:DatanodeNamenode.DatanodeCommand.balanceCmd)
  return _msg;
}
inline void DatanodeCommand::set_allocated_balancecmd(::DatanodeNamenode::BalanceBandwidth* balancecmd) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.balancecmd_;
  }
  if (balancecmd) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(balancecmd);
    if (message_arena != submessage_arena) {
      balancecmd = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, balancecmd, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.balancecmd_ = balancecmd;
  // @@protoc_insertion_point(field_set_allocated:DatanodeNamenode.DatanodeCommand.balanceCmd)
}

// optional .DatanodeNamenode.BlockCommand blkCmd = 3;
inline bool DatanodeCommand::_internal_has_blkcmd() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.blkcmd_ != nullptr);
  return value;
}
inline bool DatanodeCommand::has_blkcmd() const {
  return _internal_has_blkcmd();
}
inline void DatanodeCommand::clear_blkcmd() {
  if (_impl_.blkcmd_ != nullptr) _impl_.blkcmd_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::DatanodeNamenode::BlockCommand& DatanodeCommand::_internal_blkcmd() const {
  const ::DatanodeNamenode::BlockCommand* p = _impl_.blkcmd_;
  return p != nullptr ? *p : reinterpret_cast<const ::DatanodeNamenode::BlockCommand&>(
      ::DatanodeNamenode::_BlockCommand_default_instance_);
}
inline const ::DatanodeNamenode::BlockCommand& DatanodeCommand::blkcmd() const {
  // @@protoc_insertion_point(field_get:DatanodeNamenode.DatanodeCommand.blkCmd)
  return _internal_blkcmd();
}
inline void DatanodeCommand::unsafe_arena_set_allocated_blkcmd(
    ::DatanodeNamenode::BlockCommand* blkcmd) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.blkcmd_);
  }
  _impl_.blkcmd_ = blkcmd;
  if (blkcmd) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DatanodeNamenode.DatanodeCommand.blkCmd)
}
inline ::DatanodeNamenode::BlockCommand* DatanodeCommand::release_blkcmd() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::DatanodeNamenode::BlockCommand* temp = _impl_.blkcmd_;
  _impl_.blkcmd_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DatanodeNamenode::BlockCommand* DatanodeCommand::unsafe_arena_release_blkcmd() {
  // @@protoc_insertion_point(field_release:DatanodeNamenode.DatanodeCommand.blkCmd)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::DatanodeNamenode::BlockCommand* temp = _impl_.blkcmd_;
  _impl_.blkcmd_ = nullptr;
  return temp;
}
inline ::DatanodeNamenode::BlockCommand* DatanodeCommand::_internal_mutable_blkcmd() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.blkcmd_ == nullptr) {
    auto* p = CreateMaybeMessage<::DatanodeNamenode::BlockCommand>(GetArenaForAllocation());
    _impl_.blkcmd_ = p;
  }
  return _impl_.blkcmd_;
}
inline ::DatanodeNamenode::BlockCommand* DatanodeCommand::mutable_blkcmd() {
  ::DatanodeNamenode::BlockCommand* _msg = _internal_mutable_blkcmd();
  // @@protoc_insertion_point(field_mutable:DatanodeNamenode.DatanodeCommand.blkCmd)
  return _msg;
}
inline void DatanodeCommand::set_allocated_blkcmd(::DatanodeNamenode::BlockCommand* blkcmd) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.blkcmd_;
  }
  if (blkcmd) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(blkcmd);
    if (message_arena != submessage_arena) {
      blkcmd = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, blkcmd, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.blkcmd_ = blkcmd;
  // @@protoc_insertion_point(field_set_allocated:DatanodeNamenode.DatanodeCommand.blkCmd)
}

// optional .DatanodeNamenode.BlockRecovery recoveryCmd = 4;
inline bool DatanodeCommand::_internal_has_recoverycmd() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.recoverycmd_ != nullptr);
  return value;
}
inline bool DatanodeCommand::has_recoverycmd() const {
  return _internal_has_recoverycmd();
}
inline void DatanodeCommand::clear_recoverycmd() {
  if (_impl_.recoverycmd_ != nullptr) _impl_.recoverycmd_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::DatanodeNamenode::BlockRecovery& DatanodeCommand::_internal_recoverycmd() const {
  const ::DatanodeNamenode::BlockRecovery* p = _impl_.recoverycmd_;
  return p != nullptr ? *p : reinterpret_cast<const ::DatanodeNamenode::BlockRecovery&>(
      ::DatanodeNamenode::_BlockRecovery_default_instance_);
}
inline const ::DatanodeNamenode::BlockRecovery& DatanodeCommand::recoverycmd() const {
  // @@protoc_insertion_point(field_get:DatanodeNamenode.DatanodeCommand.recoveryCmd)
  return _internal_recoverycmd();
}
inline void DatanodeCommand::unsafe_arena_set_allocated_recoverycmd(
    ::DatanodeNamenode::BlockRecovery* recoverycmd) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.recoverycmd_);
  }
  _impl_.recoverycmd_ = recoverycmd;
  if (recoverycmd) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DatanodeNamenode.DatanodeCommand.recoveryCmd)
}
inline ::DatanodeNamenode::BlockRecovery* DatanodeCommand::release_recoverycmd() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::DatanodeNamenode::BlockRecovery* temp = _impl_.recoverycmd_;
  _impl_.recoverycmd_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DatanodeNamenode::BlockRecovery* DatanodeCommand::unsafe_arena_release_recoverycmd() {
  // @@protoc_insertion_point(field_release:DatanodeNamenode.DatanodeCommand.recoveryCmd)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::DatanodeNamenode::BlockRecovery* temp = _impl_.recoverycmd_;
  _impl_.recoverycmd_ = nullptr;
  return temp;
}
inline ::DatanodeNamenode::BlockRecovery* DatanodeCommand::_internal_mutable_recoverycmd() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.recoverycmd_ == nullptr) {
    auto* p = CreateMaybeMessage<::DatanodeNamenode::BlockRecovery>(GetArenaForAllocation());
    _impl_.recoverycmd_ = p;
  }
  return _impl_.recoverycmd_;
}
inline ::DatanodeNamenode::BlockRecovery* DatanodeCommand::mutable_recoverycmd() {
  ::DatanodeNamenode::BlockRecovery* _msg = _internal_mutable_recoverycmd();
  // @@protoc_insertion_point(field_mutable:DatanodeNamenode.DatanodeCommand.recoveryCmd)
  return _msg;
}
inline void DatanodeCommand::set_allocated_recoverycmd(::DatanodeNamenode::BlockRecovery* recoverycmd) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.recoverycmd_;
  }
  if (recoverycmd) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(recoverycmd);
    if (message_arena != submessage_arena) {
      recoverycmd = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, recoverycmd, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.recoverycmd_ = recoverycmd;
  // @@protoc_insertion_point(field_set_allocated:DatanodeNamenode.DatanodeCommand.recoveryCmd)
}

// optional .DatanodeNamenode.Finalize finalizeCmd = 5;
inline bool DatanodeCommand::_internal_has_finalizecmd() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.finalizecmd_ != nullptr);
  return value;
}
inline bool DatanodeCommand::has_finalizecmd() const {
  return _internal_has_finalizecmd();
}
inline void DatanodeCommand::clear_finalizecmd() {
  if (_impl_.finalizecmd_ != nullptr) _impl_.finalizecmd_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::DatanodeNamenode::Finalize& DatanodeCommand::_internal_finalizecmd() const {
  const ::DatanodeNamenode::Finalize* p = _impl_.finalizecmd_;
  return p != nullptr ? *p : reinterpret_cast<const ::DatanodeNamenode::Finalize&>(
      ::DatanodeNamenode::_Finalize_default_instance_);
}
inline const ::DatanodeNamenode::Finalize& DatanodeCommand::finalizecmd() const {
  // @@protoc_insertion_point(field_get:DatanodeNamenode.DatanodeCommand.finalizeCmd)
  return _internal_finalizecmd();
}
inline void DatanodeCommand::unsafe_arena_set_allocated_finalizecmd(
    ::DatanodeNamenode::Finalize* finalizecmd) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.finalizecmd_);
  }
  _impl_.finalizecmd_ = finalizecmd;
  if (finalizecmd) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DatanodeNamenode.DatanodeCommand.finalizeCmd)
}
inline ::DatanodeNamenode::Finalize* DatanodeCommand::release_finalizecmd() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::DatanodeNamenode::Finalize* temp = _impl_.finalizecmd_;
  _impl_.finalizecmd_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DatanodeNamenode::Finalize* DatanodeCommand::unsafe_arena_release_finalizecmd() {
  // @@protoc_insertion_point(field_release:DatanodeNamenode.DatanodeCommand.finalizeCmd)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::DatanodeNamenode::Finalize* temp = _impl_.finalizecmd_;
  _impl_.finalizecmd_ = nullptr;
  return temp;
}
inline ::DatanodeNamenode::Finalize* DatanodeCommand::_internal_mutable_finalizecmd() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.finalizecmd_ == nullptr) {
    auto* p = CreateMaybeMessage<::DatanodeNamenode::Finalize>(GetArenaForAllocation());
    _impl_.finalizecmd_ = p;
  }
  return _impl_.finalizecmd_;
}
inline ::DatanodeNamenode::Finalize* DatanodeCommand::mutable_finalizecmd() {
  ::DatanodeNamenode::Finalize* _msg = _internal_mutable_finalizecmd();
  // @@protoc_insertion_point(field_mutable:DatanodeNamenode.DatanodeCommand.finalizeCmd)
  return _msg;
}
inline void DatanodeCommand::set_allocated_finalizecmd(::DatanodeNamenode::Finalize* finalizecmd) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.finalizecmd_;
  }
  if (finalizecmd) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(finalizecmd);
    if (message_arena != submessage_arena) {
      finalizecmd = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, finalizecmd, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.finalizecmd_ = finalizecmd;
  // @@protoc_insertion_point(field_set_allocated:DatanodeNamenode.DatanodeCommand.finalizeCmd)
}

// optional .DatanodeNamenode.KeyUpdate keyUpdateCmd = 6;
inline bool DatanodeCommand::_internal_has_keyupdatecmd() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.keyupdatecmd_ != nullptr);
  return value;
}
inline bool DatanodeCommand::has_keyupdatecmd() const {
  return _internal_has_keyupdatecmd();
}
inline void DatanodeCommand::clear_keyupdatecmd() {
  if (_impl_.keyupdatecmd_ != nullptr) _impl_.keyupdatecmd_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::DatanodeNamenode::KeyUpdate& DatanodeCommand::_internal_keyupdatecmd() const {
  const ::DatanodeNamenode::KeyUpdate* p = _impl_.keyupdatecmd_;
  return p != nullptr ? *p : reinterpret_cast<const ::DatanodeNamenode::KeyUpdate&>(
      ::DatanodeNamenode::_KeyUpdate_default_instance_);
}
inline const ::DatanodeNamenode::KeyUpdate& DatanodeCommand::keyupdatecmd() const {
  // @@protoc_insertion_point(field_get:DatanodeNamenode.DatanodeCommand.keyUpdateCmd)
  return _internal_keyupdatecmd();
}
inline void DatanodeCommand::unsafe_arena_set_allocated_keyupdatecmd(
    ::DatanodeNamenode::KeyUpdate* keyupdatecmd) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.keyupdatecmd_);
  }
  _impl_.keyupdatecmd_ = keyupdatecmd;
  if (keyupdatecmd) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DatanodeNamenode.DatanodeCommand.keyUpdateCmd)
}
inline ::DatanodeNamenode::KeyUpdate* DatanodeCommand::release_keyupdatecmd() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::DatanodeNamenode::KeyUpdate* temp = _impl_.keyupdatecmd_;
  _impl_.keyupdatecmd_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DatanodeNamenode::KeyUpdate* DatanodeCommand::unsafe_arena_release_keyupdatecmd() {
  // @@protoc_insertion_point(field_release:DatanodeNamenode.DatanodeCommand.keyUpdateCmd)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::DatanodeNamenode::KeyUpdate* temp = _impl_.keyupdatecmd_;
  _impl_.keyupdatecmd_ = nullptr;
  return temp;
}
inline ::DatanodeNamenode::KeyUpdate* DatanodeCommand::_internal_mutable_keyupdatecmd() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.keyupdatecmd_ == nullptr) {
    auto* p = CreateMaybeMessage<::DatanodeNamenode::KeyUpdate>(GetArenaForAllocation());
    _impl_.keyupdatecmd_ = p;
  }
  return _impl_.keyupdatecmd_;
}
inline ::DatanodeNamenode::KeyUpdate* DatanodeCommand::mutable_keyupdatecmd() {
  ::DatanodeNamenode::KeyUpdate* _msg = _internal_mutable_keyupdatecmd();
  // @@protoc_insertion_point(field_mutable:DatanodeNamenode.DatanodeCommand.keyUpdateCmd)
  return _msg;
}
inline void DatanodeCommand::set_allocated_keyupdatecmd(::DatanodeNamenode::KeyUpdate* keyupdatecmd) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.keyupdatecmd_;
  }
  if (keyupdatecmd) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(keyupdatecmd);
    if (message_arena != submessage_arena) {
      keyupdatecmd = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, keyupdatecmd, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.keyupdatecmd_ = keyupdatecmd;
  // @@protoc_insertion_point(field_set_allocated:DatanodeNamenode.DatanodeCommand.keyUpdateCmd)
}

// optional .DatanodeNamenode.Register registerCmd = 7;
inline bool DatanodeCommand::_internal_has_registercmd() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.registercmd_ != nullptr);
  return value;
}
inline bool DatanodeCommand::has_registercmd() const {
  return _internal_has_registercmd();
}
inline void DatanodeCommand::clear_registercmd() {
  if (_impl_.registercmd_ != nullptr) _impl_.registercmd_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::DatanodeNamenode::Register& DatanodeCommand::_internal_registercmd() const {
  const ::DatanodeNamenode::Register* p = _impl_.registercmd_;
  return p != nullptr ? *p : reinterpret_cast<const ::DatanodeNamenode::Register&>(
      ::DatanodeNamenode::_Register_default_instance_);
}
inline const ::DatanodeNamenode::Register& DatanodeCommand::registercmd() const {
  // @@protoc_insertion_point(field_get:DatanodeNamenode.DatanodeCommand.registerCmd)
  return _internal_registercmd();
}
inline void DatanodeCommand::unsafe_arena_set_allocated_registercmd(
    ::DatanodeNamenode::Register* registercmd) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.registercmd_);
  }
  _impl_.registercmd_ = registercmd;
  if (registercmd) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DatanodeNamenode.DatanodeCommand.registerCmd)
}
inline ::DatanodeNamenode::Register* DatanodeCommand::release_registercmd() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::DatanodeNamenode::Register* temp = _impl_.registercmd_;
  _impl_.registercmd_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DatanodeNamenode::Register* DatanodeCommand::unsafe_arena_release_registercmd() {
  // @@protoc_insertion_point(field_release:DatanodeNamenode.DatanodeCommand.registerCmd)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::DatanodeNamenode::Register* temp = _impl_.registercmd_;
  _impl_.registercmd_ = nullptr;
  return temp;
}
inline ::DatanodeNamenode::Register* DatanodeCommand::_internal_mutable_registercmd() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.registercmd_ == nullptr) {
    auto* p = CreateMaybeMessage<::DatanodeNamenode::Register>(GetArenaForAllocation());
    _impl_.registercmd_ = p;
  }
  return _impl_.registercmd_;
}
inline ::DatanodeNamenode::Register* DatanodeCommand::mutable_registercmd() {
  ::DatanodeNamenode::Register* _msg = _internal_mutable_registercmd();
  // @@protoc_insertion_point(field_mutable:DatanodeNamenode.DatanodeCommand.registerCmd)
  return _msg;
}
inline void DatanodeCommand::set_allocated_registercmd(::DatanodeNamenode::Register* registercmd) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.registercmd_;
  }
  if (registercmd) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(registercmd);
    if (message_arena != submessage_arena) {
      registercmd = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, registercmd, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.registercmd_ = registercmd;
  // @@protoc_insertion_point(field_set_allocated:DatanodeNamenode.DatanodeCommand.registerCmd)
}

// optional .DatanodeNamenode.BlockId blkIdCmd = 8;
inline bool DatanodeCommand::_internal_has_blkidcmd() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.blkidcmd_ != nullptr);
  return value;
}
inline bool DatanodeCommand::has_blkidcmd() const {
  return _internal_has_blkidcmd();
}
inline void DatanodeCommand::clear_blkidcmd() {
  if (_impl_.blkidcmd_ != nullptr) _impl_.blkidcmd_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::DatanodeNamenode::BlockId& DatanodeCommand::_internal_blkidcmd() const {
  const ::DatanodeNamenode::BlockId* p = _impl_.blkidcmd_;
  return p != nullptr ? *p : reinterpret_cast<const ::DatanodeNamenode::BlockId&>(
      ::DatanodeNamenode::_BlockId_default_instance_);
}
inline const ::DatanodeNamenode::BlockId& DatanodeCommand::blkidcmd() const {
  // @@protoc_insertion_point(field_get:DatanodeNamenode.DatanodeCommand.blkIdCmd)
  return _internal_blkidcmd();
}
inline void DatanodeCommand::unsafe_arena_set_allocated_blkidcmd(
    ::DatanodeNamenode::BlockId* blkidcmd) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.blkidcmd_);
  }
  _impl_.blkidcmd_ = blkidcmd;
  if (blkidcmd) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DatanodeNamenode.DatanodeCommand.blkIdCmd)
}
inline ::DatanodeNamenode::BlockId* DatanodeCommand::release_blkidcmd() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::DatanodeNamenode::BlockId* temp = _impl_.blkidcmd_;
  _impl_.blkidcmd_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DatanodeNamenode::BlockId* DatanodeCommand::unsafe_arena_release_blkidcmd() {
  // @@protoc_insertion_point(field_release:DatanodeNamenode.DatanodeCommand.blkIdCmd)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::DatanodeNamenode::BlockId* temp = _impl_.blkidcmd_;
  _impl_.blkidcmd_ = nullptr;
  return temp;
}
inline ::DatanodeNamenode::BlockId* DatanodeCommand::_internal_mutable_blkidcmd() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.blkidcmd_ == nullptr) {
    auto* p = CreateMaybeMessage<::DatanodeNamenode::BlockId>(GetArenaForAllocation());
    _impl_.blkidcmd_ = p;
  }
  return _impl_.blkidcmd_;
}
inline ::DatanodeNamenode::BlockId* DatanodeCommand::mutable_blkidcmd() {
  ::DatanodeNamenode::BlockId* _msg = _internal_mutable_blkidcmd();
  // @@protoc_insertion_point(field_mutable:DatanodeNamenode.DatanodeCommand.blkIdCmd)
  return _msg;
}
inline void DatanodeCommand::set_allocated_blkidcmd(::DatanodeNamenode::BlockId* blkidcmd) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.blkidcmd_;
  }
  if (blkidcmd) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(blkidcmd);
    if (message_arena != submessage_arena) {
      blkidcmd = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, blkidcmd, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.blkidcmd_ = blkidcmd;
  // @@protoc_insertion_point(field_set_allocated:DatanodeNamenode.DatanodeCommand.blkIdCmd)
}

// optional .DatanodeNamenode.CacheCommand cacheCmd = 9;
inline bool DatanodeCommand::_internal_has_cachecmd() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cachecmd_ != nullptr);
  return value;
}
inline bool DatanodeCommand::has_cachecmd() const {
  return _internal_has_cachecmd();
}
inline void DatanodeCommand::clear_cachecmd() {
  if (_impl_.cachecmd_ != nullptr) _impl_.cachecmd_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::DatanodeNamenode::CacheCommand& DatanodeCommand::_internal_cachecmd() const {
  const ::DatanodeNamenode::CacheCommand* p = _impl_.cachecmd_;
  return p != nullptr ? *p : reinterpret_cast<const ::DatanodeNamenode::CacheCommand&>(
      ::DatanodeNamenode::_CacheCommand_default_instance_);
}
inline const ::DatanodeNamenode::CacheCommand& DatanodeCommand::cachecmd() const {
  // @@protoc_insertion_point(field_get:DatanodeNamenode.DatanodeCommand.cacheCmd)
  return _internal_cachecmd();
}
inline void DatanodeCommand::unsafe_arena_set_allocated_cachecmd(
    ::DatanodeNamenode::CacheCommand* cachecmd) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cachecmd_);
  }
  _impl_.cachecmd_ = cachecmd;
  if (cachecmd) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DatanodeNamenode.DatanodeCommand.cacheCmd)
}
inline ::DatanodeNamenode::CacheCommand* DatanodeCommand::release_cachecmd() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::DatanodeNamenode::CacheCommand* temp = _impl_.cachecmd_;
  _impl_.cachecmd_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DatanodeNamenode::CacheCommand* DatanodeCommand::unsafe_arena_release_cachecmd() {
  // @@protoc_insertion_point(field_release:DatanodeNamenode.DatanodeCommand.cacheCmd)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::DatanodeNamenode::CacheCommand* temp = _impl_.cachecmd_;
  _impl_.cachecmd_ = nullptr;
  return temp;
}
inline ::DatanodeNamenode::CacheCommand* DatanodeCommand::_internal_mutable_cachecmd() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.cachecmd_ == nullptr) {
    auto* p = CreateMaybeMessage<::DatanodeNamenode::CacheCommand>(GetArenaForAllocation());
    _impl_.cachecmd_ = p;
  }
  return _impl_.cachecmd_;
}
inline ::DatanodeNamenode::CacheCommand* DatanodeCommand::mutable_cachecmd() {
  ::DatanodeNamenode::CacheCommand* _msg = _internal_mutable_cachecmd();
  // @@protoc_insertion_point(field_mutable:DatanodeNamenode.DatanodeCommand.cacheCmd)
  return _msg;
}
inline void DatanodeCommand::set_allocated_cachecmd(::DatanodeNamenode::CacheCommand* cachecmd) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cachecmd_;
  }
  if (cachecmd) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cachecmd);
    if (message_arena != submessage_arena) {
      cachecmd = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cachecmd, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.cachecmd_ = cachecmd;
  // @@protoc_insertion_point(field_set_allocated:DatanodeNamenode.DatanodeCommand.cacheCmd)
}

// -------------------------------------------------------------------

// BalanceBandwidth

// uint64 bandwidth = 1;
inline void BalanceBandwidth::clear_bandwidth() {
  _impl_.bandwidth_ = uint64_t{0u};
}
inline uint64_t BalanceBandwidth::_internal_bandwidth() const {
  return _impl_.bandwidth_;
}
inline uint64_t BalanceBandwidth::bandwidth() const {
  // @@protoc_insertion_point(field_get:DatanodeNamenode.BalanceBandwidth.bandwidth)
  return _internal_bandwidth();
}
inline void BalanceBandwidth::_internal_set_bandwidth(uint64_t value) {
  
  _impl_.bandwidth_ = value;
}
inline void BalanceBandwidth::set_bandwidth(uint64_t value) {
  _internal_set_bandwidth(value);
  // @@protoc_insertion_point(field_set:DatanodeNamenode.BalanceBandwidth.bandwidth)
}

// -------------------------------------------------------------------

// BlockCommand

// .DatanodeNamenode.BlockCommand.Action action = 1;
inline void BlockCommand::clear_action() {
  _impl_.action_ = 0;
}
inline ::DatanodeNamenode::BlockCommand_Action BlockCommand::_internal_action() const {
  return static_cast< ::DatanodeNamenode::BlockCommand_Action >(_impl_.action_);
}
inline ::DatanodeNamenode::BlockCommand_Action BlockCommand::action() const {
  // @@protoc_insertion_point(field_get:DatanodeNamenode.BlockCommand.action)
  return _internal_action();
}
inline void BlockCommand::_internal_set_action(::DatanodeNamenode::BlockCommand_Action value) {
  
  _impl_.action_ = value;
}
inline void BlockCommand::set_action(::DatanodeNamenode::BlockCommand_Action value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:DatanodeNamenode.BlockCommand.action)
}

// repeated .Block blocks = 2;
inline int BlockCommand::_internal_blocks_size() const {
  return _impl_.blocks_.size();
}
inline int BlockCommand::blocks_size() const {
  return _internal_blocks_size();
}
inline ::Block* BlockCommand::mutable_blocks(int index) {
  // @@protoc_insertion_point(field_mutable:DatanodeNamenode.BlockCommand.blocks)
  return _impl_.blocks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Block >*
BlockCommand::mutable_blocks() {
  // @@protoc_insertion_point(field_mutable_list:DatanodeNamenode.BlockCommand.blocks)
  return &_impl_.blocks_;
}
inline const ::Block& BlockCommand::_internal_blocks(int index) const {
  return _impl_.blocks_.Get(index);
}
inline const ::Block& BlockCommand::blocks(int index) const {
  // @@protoc_insertion_point(field_get:DatanodeNamenode.BlockCommand.blocks)
  return _internal_blocks(index);
}
inline ::Block* BlockCommand::_internal_add_blocks() {
  return _impl_.blocks_.Add();
}
inline ::Block* BlockCommand::add_blocks() {
  ::Block* _add = _internal_add_blocks();
  // @@protoc_insertion_point(field_add:DatanodeNamenode.BlockCommand.blocks)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Block >&
BlockCommand::blocks() const {
  // @@protoc_insertion_point(field_list:DatanodeNamenode.BlockCommand.blocks)
  return _impl_.blocks_;
}

// repeated .DatanodeInfo targets = 3;
inline int BlockCommand::_internal_targets_size() const {
  return _impl_.targets_.size();
}
inline int BlockCommand::targets_size() const {
  return _internal_targets_size();
}
inline ::DatanodeInfo* BlockCommand::mutable_targets(int index) {
  // @@protoc_insertion_point(field_mutable:DatanodeNamenode.BlockCommand.targets)
  return _impl_.targets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DatanodeInfo >*
BlockCommand::mutable_targets() {
  // @@protoc_insertion_point(field_mutable_list:DatanodeNamenode.BlockCommand.targets)
  return &_impl_.targets_;
}
inline const ::DatanodeInfo& BlockCommand::_internal_targets(int index) const {
  return _impl_.targets_.Get(index);
}
inline const ::DatanodeInfo& BlockCommand::targets(int index) const {
  // @@protoc_insertion_point(field_get:DatanodeNamenode.BlockCommand.targets)
  return _internal_targets(index);
}
inline ::DatanodeInfo* BlockCommand::_internal_add_targets() {
  return _impl_.targets_.Add();
}
inline ::DatanodeInfo* BlockCommand::add_targets() {
  ::DatanodeInfo* _add = _internal_add_targets();
  // @@protoc_insertion_point(field_add:DatanodeNamenode.BlockCommand.targets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DatanodeInfo >&
BlockCommand::targets() const {
  // @@protoc_insertion_point(field_list:DatanodeNamenode.BlockCommand.targets)
  return _impl_.targets_;
}

// -------------------------------------------------------------------

// BlockRecovery

// -------------------------------------------------------------------

// Finalize

// -------------------------------------------------------------------

// KeyUpdate

// -------------------------------------------------------------------

// Register

// -------------------------------------------------------------------

// CacheCommand

// repeated uint64 blocks = 1;
inline int CacheCommand::_internal_blocks_size() const {
  return _impl_.blocks_.size();
}
inline int CacheCommand::blocks_size() const {
  return _internal_blocks_size();
}
inline void CacheCommand::clear_blocks() {
  _impl_.blocks_.Clear();
}
inline uint64_t CacheCommand::_internal_blocks(int index) const {
  return _impl_.blocks_.Get(index);
}
inline uint64_t CacheCommand::blocks(int index) const {
  // @@protoc_insertion_point(field_get:DatanodeNamenode.CacheCommand.blocks)
  return _internal_blocks(index);
}
inline void CacheCommand::set_blocks(int index, uint64_t value) {
  _impl_.blocks_.Set(index, value);
  // @@protoc_insertion_point(field_set:DatanodeNamenode.CacheCommand.blocks)
}
inline void CacheCommand::_internal_add_blocks(uint64_t value) {
  _impl_.blocks_.Add(value);
}
inline void CacheCommand::add_blocks(uint64_t value) {
  _internal_add_blocks(value);
  // @@protoc_insertion_point(field_add:DatanodeNamenode.CacheCommand.blocks)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
CacheCommand::_internal_blocks() const {
  return _impl_.blocks_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
CacheCommand::blocks() const {
  // @@protoc_insertion_point(field_list:DatanodeNamenode.CacheCommand.blocks)
  return _internal_blocks();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
CacheCommand::_internal_mutable_blocks() {
  return &_impl_.blocks_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
CacheCommand::mutable_blocks() {
  // @@protoc_insertion_point(field_mutable_list:DatanodeNamenode.CacheCommand.blocks)
  return _internal_mutable_blocks();
}

// -------------------------------------------------------------------

// BlockId

// .DatanodeNamenode.BlockId.Action action = 1;
inline void BlockId::clear_action() {
  _impl_.action_ = 0;
}
inline ::DatanodeNamenode::BlockId_Action BlockId::_internal_action() const {
  return static_cast< ::DatanodeNamenode::BlockId_Action >(_impl_.action_);
}
inline ::DatanodeNamenode::BlockId_Action BlockId::action() const {
  // @@protoc_insertion_point(field_get:DatanodeNamenode.BlockId.action)
  return _internal_action();
}
inline void BlockId::_internal_set_action(::DatanodeNamenode::BlockId_Action value) {
  
  _impl_.action_ = value;
}
inline void BlockId::set_action(::DatanodeNamenode::BlockId_Action value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:DatanodeNamenode.BlockId.action)
}

// repeated uint64 blockIds = 2;
inline int BlockId::_internal_blockids_size() const {
  return _impl_.blockids_.size();
}
inline int BlockId::blockids_size() const {
  return _internal_blockids_size();
}
inline void BlockId::clear_blockids() {
  _impl_.blockids_.Clear();
}
inline uint64_t BlockId::_internal_blockids(int index) const {
  return _impl_.blockids_.Get(index);
}
inline uint64_t BlockId::blockids(int index) const {
  // @@protoc_insertion_point(field_get:DatanodeNamenode.BlockId.blockIds)
  return _internal_blockids(index);
}
inline void BlockId::set_blockids(int index, uint64_t value) {
  _impl_.blockids_.Set(index, value);
  // @@protoc_insertion_point(field_set:DatanodeNamenode.BlockId.blockIds)
}
inline void BlockId::_internal_add_blockids(uint64_t value) {
  _impl_.blockids_.Add(value);
}
inline void BlockId::add_blockids(uint64_t value) {
  _internal_add_blockids(value);
  // @@protoc_insertion_point(field_add:DatanodeNamenode.BlockId.blockIds)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
BlockId::_internal_blockids() const {
  return _impl_.blockids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
BlockId::blockids() const {
  // @@protoc_insertion_point(field_list:DatanodeNamenode.BlockId.blockIds)
  return _internal_blockids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
BlockId::_internal_mutable_blockids() {
  return &_impl_.blockids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
BlockId::mutable_blockids() {
  // @@protoc_insertion_point(field_mutable_list:DatanodeNamenode.BlockId.blockIds)
  return _internal_mutable_blockids();
}

// -------------------------------------------------------------------

// ReceivedDeletedBlockInfo

// .Block block = 1;
inline bool ReceivedDeletedBlockInfo::_internal_has_block() const {
  return this != internal_default_instance() && _impl_.block_ != nullptr;
}
inline bool ReceivedDeletedBlockInfo::has_block() const {
  return _internal_has_block();
}
inline const ::Block& ReceivedDeletedBlockInfo::_internal_block() const {
  const ::Block* p = _impl_.block_;
  return p != nullptr ? *p : reinterpret_cast<const ::Block&>(
      ::_Block_default_instance_);
}
inline const ::Block& ReceivedDeletedBlockInfo::block() const {
  // @@protoc_insertion_point(field_get:DatanodeNamenode.ReceivedDeletedBlockInfo.block)
  return _internal_block();
}
inline void ReceivedDeletedBlockInfo::unsafe_arena_set_allocated_block(
    ::Block* block) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.block_);
  }
  _impl_.block_ = block;
  if (block) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DatanodeNamenode.ReceivedDeletedBlockInfo.block)
}
inline ::Block* ReceivedDeletedBlockInfo::release_block() {
  
  ::Block* temp = _impl_.block_;
  _impl_.block_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Block* ReceivedDeletedBlockInfo::unsafe_arena_release_block() {
  // @@protoc_insertion_point(field_release:DatanodeNamenode.ReceivedDeletedBlockInfo.block)
  
  ::Block* temp = _impl_.block_;
  _impl_.block_ = nullptr;
  return temp;
}
inline ::Block* ReceivedDeletedBlockInfo::_internal_mutable_block() {
  
  if (_impl_.block_ == nullptr) {
    auto* p = CreateMaybeMessage<::Block>(GetArenaForAllocation());
    _impl_.block_ = p;
  }
  return _impl_.block_;
}
inline ::Block* ReceivedDeletedBlockInfo::mutable_block() {
  ::Block* _msg = _internal_mutable_block();
  // @@protoc_insertion_point(field_mutable:DatanodeNamenode.ReceivedDeletedBlockInfo.block)
  return _msg;
}
inline void ReceivedDeletedBlockInfo::set_allocated_block(::Block* block) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.block_);
  }
  if (block) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(block));
    if (message_arena != submessage_arena) {
      block = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, block, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.block_ = block;
  // @@protoc_insertion_point(field_set_allocated:DatanodeNamenode.ReceivedDeletedBlockInfo.block)
}

// .DatanodeNamenode.ReceivedDeletedBlockInfo.BlockStatus status = 2;
inline void ReceivedDeletedBlockInfo::clear_status() {
  _impl_.status_ = 0;
}
inline ::DatanodeNamenode::ReceivedDeletedBlockInfo_BlockStatus ReceivedDeletedBlockInfo::_internal_status() const {
  return static_cast< ::DatanodeNamenode::ReceivedDeletedBlockInfo_BlockStatus >(_impl_.status_);
}
inline ::DatanodeNamenode::ReceivedDeletedBlockInfo_BlockStatus ReceivedDeletedBlockInfo::status() const {
  // @@protoc_insertion_point(field_get:DatanodeNamenode.ReceivedDeletedBlockInfo.status)
  return _internal_status();
}
inline void ReceivedDeletedBlockInfo::_internal_set_status(::DatanodeNamenode::ReceivedDeletedBlockInfo_BlockStatus value) {
  
  _impl_.status_ = value;
}
inline void ReceivedDeletedBlockInfo::set_status(::DatanodeNamenode::ReceivedDeletedBlockInfo_BlockStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:DatanodeNamenode.ReceivedDeletedBlockInfo.status)
}

// -------------------------------------------------------------------

// RegisterDatanodeRequest

// .DatanodeNamenode.DatanodeRegister registration = 1;
inline bool RegisterDatanodeRequest::_internal_has_registration() const {
  return this != internal_default_instance() && _impl_.registration_ != nullptr;
}
inline bool RegisterDatanodeRequest::has_registration() const {
  return _internal_has_registration();
}
inline void RegisterDatanodeRequest::clear_registration() {
  if (GetArenaForAllocation() == nullptr && _impl_.registration_ != nullptr) {
    delete _impl_.registration_;
  }
  _impl_.registration_ = nullptr;
}
inline const ::DatanodeNamenode::DatanodeRegister& RegisterDatanodeRequest::_internal_registration() const {
  const ::DatanodeNamenode::DatanodeRegister* p = _impl_.registration_;
  return p != nullptr ? *p : reinterpret_cast<const ::DatanodeNamenode::DatanodeRegister&>(
      ::DatanodeNamenode::_DatanodeRegister_default_instance_);
}
inline const ::DatanodeNamenode::DatanodeRegister& RegisterDatanodeRequest::registration() const {
  // @@protoc_insertion_point(field_get:DatanodeNamenode.RegisterDatanodeRequest.registration)
  return _internal_registration();
}
inline void RegisterDatanodeRequest::unsafe_arena_set_allocated_registration(
    ::DatanodeNamenode::DatanodeRegister* registration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.registration_);
  }
  _impl_.registration_ = registration;
  if (registration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DatanodeNamenode.RegisterDatanodeRequest.registration)
}
inline ::DatanodeNamenode::DatanodeRegister* RegisterDatanodeRequest::release_registration() {
  
  ::DatanodeNamenode::DatanodeRegister* temp = _impl_.registration_;
  _impl_.registration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DatanodeNamenode::DatanodeRegister* RegisterDatanodeRequest::unsafe_arena_release_registration() {
  // @@protoc_insertion_point(field_release:DatanodeNamenode.RegisterDatanodeRequest.registration)
  
  ::DatanodeNamenode::DatanodeRegister* temp = _impl_.registration_;
  _impl_.registration_ = nullptr;
  return temp;
}
inline ::DatanodeNamenode::DatanodeRegister* RegisterDatanodeRequest::_internal_mutable_registration() {
  
  if (_impl_.registration_ == nullptr) {
    auto* p = CreateMaybeMessage<::DatanodeNamenode::DatanodeRegister>(GetArenaForAllocation());
    _impl_.registration_ = p;
  }
  return _impl_.registration_;
}
inline ::DatanodeNamenode::DatanodeRegister* RegisterDatanodeRequest::mutable_registration() {
  ::DatanodeNamenode::DatanodeRegister* _msg = _internal_mutable_registration();
  // @@protoc_insertion_point(field_mutable:DatanodeNamenode.RegisterDatanodeRequest.registration)
  return _msg;
}
inline void RegisterDatanodeRequest::set_allocated_registration(::DatanodeNamenode::DatanodeRegister* registration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.registration_;
  }
  if (registration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(registration);
    if (message_arena != submessage_arena) {
      registration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, registration, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.registration_ = registration;
  // @@protoc_insertion_point(field_set_allocated:DatanodeNamenode.RegisterDatanodeRequest.registration)
}

// -------------------------------------------------------------------

// RegisterDatanodeResponse

// .DatanodeNamenode.DatanodeRegister registration = 1;
inline bool RegisterDatanodeResponse::_internal_has_registration() const {
  return this != internal_default_instance() && _impl_.registration_ != nullptr;
}
inline bool RegisterDatanodeResponse::has_registration() const {
  return _internal_has_registration();
}
inline void RegisterDatanodeResponse::clear_registration() {
  if (GetArenaForAllocation() == nullptr && _impl_.registration_ != nullptr) {
    delete _impl_.registration_;
  }
  _impl_.registration_ = nullptr;
}
inline const ::DatanodeNamenode::DatanodeRegister& RegisterDatanodeResponse::_internal_registration() const {
  const ::DatanodeNamenode::DatanodeRegister* p = _impl_.registration_;
  return p != nullptr ? *p : reinterpret_cast<const ::DatanodeNamenode::DatanodeRegister&>(
      ::DatanodeNamenode::_DatanodeRegister_default_instance_);
}
inline const ::DatanodeNamenode::DatanodeRegister& RegisterDatanodeResponse::registration() const {
  // @@protoc_insertion_point(field_get:DatanodeNamenode.RegisterDatanodeResponse.registration)
  return _internal_registration();
}
inline void RegisterDatanodeResponse::unsafe_arena_set_allocated_registration(
    ::DatanodeNamenode::DatanodeRegister* registration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.registration_);
  }
  _impl_.registration_ = registration;
  if (registration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DatanodeNamenode.RegisterDatanodeResponse.registration)
}
inline ::DatanodeNamenode::DatanodeRegister* RegisterDatanodeResponse::release_registration() {
  
  ::DatanodeNamenode::DatanodeRegister* temp = _impl_.registration_;
  _impl_.registration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DatanodeNamenode::DatanodeRegister* RegisterDatanodeResponse::unsafe_arena_release_registration() {
  // @@protoc_insertion_point(field_release:DatanodeNamenode.RegisterDatanodeResponse.registration)
  
  ::DatanodeNamenode::DatanodeRegister* temp = _impl_.registration_;
  _impl_.registration_ = nullptr;
  return temp;
}
inline ::DatanodeNamenode::DatanodeRegister* RegisterDatanodeResponse::_internal_mutable_registration() {
  
  if (_impl_.registration_ == nullptr) {
    auto* p = CreateMaybeMessage<::DatanodeNamenode::DatanodeRegister>(GetArenaForAllocation());
    _impl_.registration_ = p;
  }
  return _impl_.registration_;
}
inline ::DatanodeNamenode::DatanodeRegister* RegisterDatanodeResponse::mutable_registration() {
  ::DatanodeNamenode::DatanodeRegister* _msg = _internal_mutable_registration();
  // @@protoc_insertion_point(field_mutable:DatanodeNamenode.RegisterDatanodeResponse.registration)
  return _msg;
}
inline void RegisterDatanodeResponse::set_allocated_registration(::DatanodeNamenode::DatanodeRegister* registration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.registration_;
  }
  if (registration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(registration);
    if (message_arena != submessage_arena) {
      registration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, registration, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.registration_ = registration;
  // @@protoc_insertion_point(field_set_allocated:DatanodeNamenode.RegisterDatanodeResponse.registration)
}

// -------------------------------------------------------------------

// HeartBeatRequest

// .DatanodeNamenode.DatanodeRegister registration = 1;
inline bool HeartBeatRequest::_internal_has_registration() const {
  return this != internal_default_instance() && _impl_.registration_ != nullptr;
}
inline bool HeartBeatRequest::has_registration() const {
  return _internal_has_registration();
}
inline void HeartBeatRequest::clear_registration() {
  if (GetArenaForAllocation() == nullptr && _impl_.registration_ != nullptr) {
    delete _impl_.registration_;
  }
  _impl_.registration_ = nullptr;
}
inline const ::DatanodeNamenode::DatanodeRegister& HeartBeatRequest::_internal_registration() const {
  const ::DatanodeNamenode::DatanodeRegister* p = _impl_.registration_;
  return p != nullptr ? *p : reinterpret_cast<const ::DatanodeNamenode::DatanodeRegister&>(
      ::DatanodeNamenode::_DatanodeRegister_default_instance_);
}
inline const ::DatanodeNamenode::DatanodeRegister& HeartBeatRequest::registration() const {
  // @@protoc_insertion_point(field_get:DatanodeNamenode.HeartBeatRequest.registration)
  return _internal_registration();
}
inline void HeartBeatRequest::unsafe_arena_set_allocated_registration(
    ::DatanodeNamenode::DatanodeRegister* registration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.registration_);
  }
  _impl_.registration_ = registration;
  if (registration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DatanodeNamenode.HeartBeatRequest.registration)
}
inline ::DatanodeNamenode::DatanodeRegister* HeartBeatRequest::release_registration() {
  
  ::DatanodeNamenode::DatanodeRegister* temp = _impl_.registration_;
  _impl_.registration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DatanodeNamenode::DatanodeRegister* HeartBeatRequest::unsafe_arena_release_registration() {
  // @@protoc_insertion_point(field_release:DatanodeNamenode.HeartBeatRequest.registration)
  
  ::DatanodeNamenode::DatanodeRegister* temp = _impl_.registration_;
  _impl_.registration_ = nullptr;
  return temp;
}
inline ::DatanodeNamenode::DatanodeRegister* HeartBeatRequest::_internal_mutable_registration() {
  
  if (_impl_.registration_ == nullptr) {
    auto* p = CreateMaybeMessage<::DatanodeNamenode::DatanodeRegister>(GetArenaForAllocation());
    _impl_.registration_ = p;
  }
  return _impl_.registration_;
}
inline ::DatanodeNamenode::DatanodeRegister* HeartBeatRequest::mutable_registration() {
  ::DatanodeNamenode::DatanodeRegister* _msg = _internal_mutable_registration();
  // @@protoc_insertion_point(field_mutable:DatanodeNamenode.HeartBeatRequest.registration)
  return _msg;
}
inline void HeartBeatRequest::set_allocated_registration(::DatanodeNamenode::DatanodeRegister* registration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.registration_;
  }
  if (registration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(registration);
    if (message_arena != submessage_arena) {
      registration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, registration, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.registration_ = registration;
  // @@protoc_insertion_point(field_set_allocated:DatanodeNamenode.HeartBeatRequest.registration)
}

// optional uint32 xmitsInProgress = 3;
inline bool HeartBeatRequest::_internal_has_xmitsinprogress() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool HeartBeatRequest::has_xmitsinprogress() const {
  return _internal_has_xmitsinprogress();
}
inline void HeartBeatRequest::clear_xmitsinprogress() {
  _impl_.xmitsinprogress_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t HeartBeatRequest::_internal_xmitsinprogress() const {
  return _impl_.xmitsinprogress_;
}
inline uint32_t HeartBeatRequest::xmitsinprogress() const {
  // @@protoc_insertion_point(field_get:DatanodeNamenode.HeartBeatRequest.xmitsInProgress)
  return _internal_xmitsinprogress();
}
inline void HeartBeatRequest::_internal_set_xmitsinprogress(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.xmitsinprogress_ = value;
}
inline void HeartBeatRequest::set_xmitsinprogress(uint32_t value) {
  _internal_set_xmitsinprogress(value);
  // @@protoc_insertion_point(field_set:DatanodeNamenode.HeartBeatRequest.xmitsInProgress)
}

// optional uint32 xceiverCount = 4;
inline bool HeartBeatRequest::_internal_has_xceivercount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool HeartBeatRequest::has_xceivercount() const {
  return _internal_has_xceivercount();
}
inline void HeartBeatRequest::clear_xceivercount() {
  _impl_.xceivercount_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t HeartBeatRequest::_internal_xceivercount() const {
  return _impl_.xceivercount_;
}
inline uint32_t HeartBeatRequest::xceivercount() const {
  // @@protoc_insertion_point(field_get:DatanodeNamenode.HeartBeatRequest.xceiverCount)
  return _internal_xceivercount();
}
inline void HeartBeatRequest::_internal_set_xceivercount(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.xceivercount_ = value;
}
inline void HeartBeatRequest::set_xceivercount(uint32_t value) {
  _internal_set_xceivercount(value);
  // @@protoc_insertion_point(field_set:DatanodeNamenode.HeartBeatRequest.xceiverCount)
}

// optional uint32 failedVolums = 5;
inline bool HeartBeatRequest::_internal_has_failedvolums() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool HeartBeatRequest::has_failedvolums() const {
  return _internal_has_failedvolums();
}
inline void HeartBeatRequest::clear_failedvolums() {
  _impl_.failedvolums_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t HeartBeatRequest::_internal_failedvolums() const {
  return _impl_.failedvolums_;
}
inline uint32_t HeartBeatRequest::failedvolums() const {
  // @@protoc_insertion_point(field_get:DatanodeNamenode.HeartBeatRequest.failedVolums)
  return _internal_failedvolums();
}
inline void HeartBeatRequest::_internal_set_failedvolums(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.failedvolums_ = value;
}
inline void HeartBeatRequest::set_failedvolums(uint32_t value) {
  _internal_set_failedvolums(value);
  // @@protoc_insertion_point(field_set:DatanodeNamenode.HeartBeatRequest.failedVolums)
}

// optional uint64 cacheCapacity = 6;
inline bool HeartBeatRequest::_internal_has_cachecapacity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool HeartBeatRequest::has_cachecapacity() const {
  return _internal_has_cachecapacity();
}
inline void HeartBeatRequest::clear_cachecapacity() {
  _impl_.cachecapacity_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t HeartBeatRequest::_internal_cachecapacity() const {
  return _impl_.cachecapacity_;
}
inline uint64_t HeartBeatRequest::cachecapacity() const {
  // @@protoc_insertion_point(field_get:DatanodeNamenode.HeartBeatRequest.cacheCapacity)
  return _internal_cachecapacity();
}
inline void HeartBeatRequest::_internal_set_cachecapacity(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.cachecapacity_ = value;
}
inline void HeartBeatRequest::set_cachecapacity(uint64_t value) {
  _internal_set_cachecapacity(value);
  // @@protoc_insertion_point(field_set:DatanodeNamenode.HeartBeatRequest.cacheCapacity)
}

// optional uint64 cacheUsed = 7;
inline bool HeartBeatRequest::_internal_has_cacheused() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool HeartBeatRequest::has_cacheused() const {
  return _internal_has_cacheused();
}
inline void HeartBeatRequest::clear_cacheused() {
  _impl_.cacheused_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint64_t HeartBeatRequest::_internal_cacheused() const {
  return _impl_.cacheused_;
}
inline uint64_t HeartBeatRequest::cacheused() const {
  // @@protoc_insertion_point(field_get:DatanodeNamenode.HeartBeatRequest.cacheUsed)
  return _internal_cacheused();
}
inline void HeartBeatRequest::_internal_set_cacheused(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.cacheused_ = value;
}
inline void HeartBeatRequest::set_cacheused(uint64_t value) {
  _internal_set_cacheused(value);
  // @@protoc_insertion_point(field_set:DatanodeNamenode.HeartBeatRequest.cacheUsed)
}

// -------------------------------------------------------------------

// HeartBeatResponse

// repeated .DatanodeNamenode.DatanodeCommand cmds = 1;
inline int HeartBeatResponse::_internal_cmds_size() const {
  return _impl_.cmds_.size();
}
inline int HeartBeatResponse::cmds_size() const {
  return _internal_cmds_size();
}
inline void HeartBeatResponse::clear_cmds() {
  _impl_.cmds_.Clear();
}
inline ::DatanodeNamenode::DatanodeCommand* HeartBeatResponse::mutable_cmds(int index) {
  // @@protoc_insertion_point(field_mutable:DatanodeNamenode.HeartBeatResponse.cmds)
  return _impl_.cmds_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DatanodeNamenode::DatanodeCommand >*
HeartBeatResponse::mutable_cmds() {
  // @@protoc_insertion_point(field_mutable_list:DatanodeNamenode.HeartBeatResponse.cmds)
  return &_impl_.cmds_;
}
inline const ::DatanodeNamenode::DatanodeCommand& HeartBeatResponse::_internal_cmds(int index) const {
  return _impl_.cmds_.Get(index);
}
inline const ::DatanodeNamenode::DatanodeCommand& HeartBeatResponse::cmds(int index) const {
  // @@protoc_insertion_point(field_get:DatanodeNamenode.HeartBeatResponse.cmds)
  return _internal_cmds(index);
}
inline ::DatanodeNamenode::DatanodeCommand* HeartBeatResponse::_internal_add_cmds() {
  return _impl_.cmds_.Add();
}
inline ::DatanodeNamenode::DatanodeCommand* HeartBeatResponse::add_cmds() {
  ::DatanodeNamenode::DatanodeCommand* _add = _internal_add_cmds();
  // @@protoc_insertion_point(field_add:DatanodeNamenode.HeartBeatResponse.cmds)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DatanodeNamenode::DatanodeCommand >&
HeartBeatResponse::cmds() const {
  // @@protoc_insertion_point(field_list:DatanodeNamenode.HeartBeatResponse.cmds)
  return _impl_.cmds_;
}

// -------------------------------------------------------------------

// blockReportRequest

// -------------------------------------------------------------------

// blockReportResponse

// -------------------------------------------------------------------

// cacheReportRequest

// -------------------------------------------------------------------

// cacheReportResponse

// -------------------------------------------------------------------

// BlockReceivedAndDeletedRequest

// .DatanodeNamenode.DatanodeRegister registration = 1;
inline bool BlockReceivedAndDeletedRequest::_internal_has_registration() const {
  return this != internal_default_instance() && _impl_.registration_ != nullptr;
}
inline bool BlockReceivedAndDeletedRequest::has_registration() const {
  return _internal_has_registration();
}
inline void BlockReceivedAndDeletedRequest::clear_registration() {
  if (GetArenaForAllocation() == nullptr && _impl_.registration_ != nullptr) {
    delete _impl_.registration_;
  }
  _impl_.registration_ = nullptr;
}
inline const ::DatanodeNamenode::DatanodeRegister& BlockReceivedAndDeletedRequest::_internal_registration() const {
  const ::DatanodeNamenode::DatanodeRegister* p = _impl_.registration_;
  return p != nullptr ? *p : reinterpret_cast<const ::DatanodeNamenode::DatanodeRegister&>(
      ::DatanodeNamenode::_DatanodeRegister_default_instance_);
}
inline const ::DatanodeNamenode::DatanodeRegister& BlockReceivedAndDeletedRequest::registration() const {
  // @@protoc_insertion_point(field_get:DatanodeNamenode.BlockReceivedAndDeletedRequest.registration)
  return _internal_registration();
}
inline void BlockReceivedAndDeletedRequest::unsafe_arena_set_allocated_registration(
    ::DatanodeNamenode::DatanodeRegister* registration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.registration_);
  }
  _impl_.registration_ = registration;
  if (registration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DatanodeNamenode.BlockReceivedAndDeletedRequest.registration)
}
inline ::DatanodeNamenode::DatanodeRegister* BlockReceivedAndDeletedRequest::release_registration() {
  
  ::DatanodeNamenode::DatanodeRegister* temp = _impl_.registration_;
  _impl_.registration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DatanodeNamenode::DatanodeRegister* BlockReceivedAndDeletedRequest::unsafe_arena_release_registration() {
  // @@protoc_insertion_point(field_release:DatanodeNamenode.BlockReceivedAndDeletedRequest.registration)
  
  ::DatanodeNamenode::DatanodeRegister* temp = _impl_.registration_;
  _impl_.registration_ = nullptr;
  return temp;
}
inline ::DatanodeNamenode::DatanodeRegister* BlockReceivedAndDeletedRequest::_internal_mutable_registration() {
  
  if (_impl_.registration_ == nullptr) {
    auto* p = CreateMaybeMessage<::DatanodeNamenode::DatanodeRegister>(GetArenaForAllocation());
    _impl_.registration_ = p;
  }
  return _impl_.registration_;
}
inline ::DatanodeNamenode::DatanodeRegister* BlockReceivedAndDeletedRequest::mutable_registration() {
  ::DatanodeNamenode::DatanodeRegister* _msg = _internal_mutable_registration();
  // @@protoc_insertion_point(field_mutable:DatanodeNamenode.BlockReceivedAndDeletedRequest.registration)
  return _msg;
}
inline void BlockReceivedAndDeletedRequest::set_allocated_registration(::DatanodeNamenode::DatanodeRegister* registration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.registration_;
  }
  if (registration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(registration);
    if (message_arena != submessage_arena) {
      registration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, registration, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.registration_ = registration;
  // @@protoc_insertion_point(field_set_allocated:DatanodeNamenode.BlockReceivedAndDeletedRequest.registration)
}

// repeated .DatanodeNamenode.ReceivedDeletedBlockInfo blocks = 2;
inline int BlockReceivedAndDeletedRequest::_internal_blocks_size() const {
  return _impl_.blocks_.size();
}
inline int BlockReceivedAndDeletedRequest::blocks_size() const {
  return _internal_blocks_size();
}
inline void BlockReceivedAndDeletedRequest::clear_blocks() {
  _impl_.blocks_.Clear();
}
inline ::DatanodeNamenode::ReceivedDeletedBlockInfo* BlockReceivedAndDeletedRequest::mutable_blocks(int index) {
  // @@protoc_insertion_point(field_mutable:DatanodeNamenode.BlockReceivedAndDeletedRequest.blocks)
  return _impl_.blocks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DatanodeNamenode::ReceivedDeletedBlockInfo >*
BlockReceivedAndDeletedRequest::mutable_blocks() {
  // @@protoc_insertion_point(field_mutable_list:DatanodeNamenode.BlockReceivedAndDeletedRequest.blocks)
  return &_impl_.blocks_;
}
inline const ::DatanodeNamenode::ReceivedDeletedBlockInfo& BlockReceivedAndDeletedRequest::_internal_blocks(int index) const {
  return _impl_.blocks_.Get(index);
}
inline const ::DatanodeNamenode::ReceivedDeletedBlockInfo& BlockReceivedAndDeletedRequest::blocks(int index) const {
  // @@protoc_insertion_point(field_get:DatanodeNamenode.BlockReceivedAndDeletedRequest.blocks)
  return _internal_blocks(index);
}
inline ::DatanodeNamenode::ReceivedDeletedBlockInfo* BlockReceivedAndDeletedRequest::_internal_add_blocks() {
  return _impl_.blocks_.Add();
}
inline ::DatanodeNamenode::ReceivedDeletedBlockInfo* BlockReceivedAndDeletedRequest::add_blocks() {
  ::DatanodeNamenode::ReceivedDeletedBlockInfo* _add = _internal_add_blocks();
  // @@protoc_insertion_point(field_add:DatanodeNamenode.BlockReceivedAndDeletedRequest.blocks)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DatanodeNamenode::ReceivedDeletedBlockInfo >&
BlockReceivedAndDeletedRequest::blocks() const {
  // @@protoc_insertion_point(field_list:DatanodeNamenode.BlockReceivedAndDeletedRequest.blocks)
  return _impl_.blocks_;
}

// -------------------------------------------------------------------

// BlockReceivedAndDeletedResponse

// -------------------------------------------------------------------

// ErrorReportRequest

// .DatanodeNamenode.DatanodeRegister registration = 1;
inline bool ErrorReportRequest::_internal_has_registration() const {
  return this != internal_default_instance() && _impl_.registration_ != nullptr;
}
inline bool ErrorReportRequest::has_registration() const {
  return _internal_has_registration();
}
inline void ErrorReportRequest::clear_registration() {
  if (GetArenaForAllocation() == nullptr && _impl_.registration_ != nullptr) {
    delete _impl_.registration_;
  }
  _impl_.registration_ = nullptr;
}
inline const ::DatanodeNamenode::DatanodeRegister& ErrorReportRequest::_internal_registration() const {
  const ::DatanodeNamenode::DatanodeRegister* p = _impl_.registration_;
  return p != nullptr ? *p : reinterpret_cast<const ::DatanodeNamenode::DatanodeRegister&>(
      ::DatanodeNamenode::_DatanodeRegister_default_instance_);
}
inline const ::DatanodeNamenode::DatanodeRegister& ErrorReportRequest::registration() const {
  // @@protoc_insertion_point(field_get:DatanodeNamenode.ErrorReportRequest.registration)
  return _internal_registration();
}
inline void ErrorReportRequest::unsafe_arena_set_allocated_registration(
    ::DatanodeNamenode::DatanodeRegister* registration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.registration_);
  }
  _impl_.registration_ = registration;
  if (registration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DatanodeNamenode.ErrorReportRequest.registration)
}
inline ::DatanodeNamenode::DatanodeRegister* ErrorReportRequest::release_registration() {
  
  ::DatanodeNamenode::DatanodeRegister* temp = _impl_.registration_;
  _impl_.registration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DatanodeNamenode::DatanodeRegister* ErrorReportRequest::unsafe_arena_release_registration() {
  // @@protoc_insertion_point(field_release:DatanodeNamenode.ErrorReportRequest.registration)
  
  ::DatanodeNamenode::DatanodeRegister* temp = _impl_.registration_;
  _impl_.registration_ = nullptr;
  return temp;
}
inline ::DatanodeNamenode::DatanodeRegister* ErrorReportRequest::_internal_mutable_registration() {
  
  if (_impl_.registration_ == nullptr) {
    auto* p = CreateMaybeMessage<::DatanodeNamenode::DatanodeRegister>(GetArenaForAllocation());
    _impl_.registration_ = p;
  }
  return _impl_.registration_;
}
inline ::DatanodeNamenode::DatanodeRegister* ErrorReportRequest::mutable_registration() {
  ::DatanodeNamenode::DatanodeRegister* _msg = _internal_mutable_registration();
  // @@protoc_insertion_point(field_mutable:DatanodeNamenode.ErrorReportRequest.registration)
  return _msg;
}
inline void ErrorReportRequest::set_allocated_registration(::DatanodeNamenode::DatanodeRegister* registration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.registration_;
  }
  if (registration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(registration);
    if (message_arena != submessage_arena) {
      registration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, registration, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.registration_ = registration;
  // @@protoc_insertion_point(field_set_allocated:DatanodeNamenode.ErrorReportRequest.registration)
}

// .DatanodeNamenode.ErrorReportRequest.ErrorCode errorCode = 2;
inline void ErrorReportRequest::clear_errorcode() {
  _impl_.errorcode_ = 0;
}
inline ::DatanodeNamenode::ErrorReportRequest_ErrorCode ErrorReportRequest::_internal_errorcode() const {
  return static_cast< ::DatanodeNamenode::ErrorReportRequest_ErrorCode >(_impl_.errorcode_);
}
inline ::DatanodeNamenode::ErrorReportRequest_ErrorCode ErrorReportRequest::errorcode() const {
  // @@protoc_insertion_point(field_get:DatanodeNamenode.ErrorReportRequest.errorCode)
  return _internal_errorcode();
}
inline void ErrorReportRequest::_internal_set_errorcode(::DatanodeNamenode::ErrorReportRequest_ErrorCode value) {
  
  _impl_.errorcode_ = value;
}
inline void ErrorReportRequest::set_errorcode(::DatanodeNamenode::ErrorReportRequest_ErrorCode value) {
  _internal_set_errorcode(value);
  // @@protoc_insertion_point(field_set:DatanodeNamenode.ErrorReportRequest.errorCode)
}

// string msg = 3;
inline void ErrorReportRequest::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& ErrorReportRequest::msg() const {
  // @@protoc_insertion_point(field_get:DatanodeNamenode.ErrorReportRequest.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ErrorReportRequest::set_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DatanodeNamenode.ErrorReportRequest.msg)
}
inline std::string* ErrorReportRequest::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:DatanodeNamenode.ErrorReportRequest.msg)
  return _s;
}
inline const std::string& ErrorReportRequest::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void ErrorReportRequest::_internal_set_msg(const std::string& value) {
  
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* ErrorReportRequest::_internal_mutable_msg() {
  
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* ErrorReportRequest::release_msg() {
  // @@protoc_insertion_point(field_release:DatanodeNamenode.ErrorReportRequest.msg)
  return _impl_.msg_.Release();
}
inline void ErrorReportRequest::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DatanodeNamenode.ErrorReportRequest.msg)
}

// -------------------------------------------------------------------

// ErrorReportResponse

// -------------------------------------------------------------------

// ReportBadBlockRequest

// repeated .LocatedBlock blocks = 1;
inline int ReportBadBlockRequest::_internal_blocks_size() const {
  return _impl_.blocks_.size();
}
inline int ReportBadBlockRequest::blocks_size() const {
  return _internal_blocks_size();
}
inline ::LocatedBlock* ReportBadBlockRequest::mutable_blocks(int index) {
  // @@protoc_insertion_point(field_mutable:DatanodeNamenode.ReportBadBlockRequest.blocks)
  return _impl_.blocks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LocatedBlock >*
ReportBadBlockRequest::mutable_blocks() {
  // @@protoc_insertion_point(field_mutable_list:DatanodeNamenode.ReportBadBlockRequest.blocks)
  return &_impl_.blocks_;
}
inline const ::LocatedBlock& ReportBadBlockRequest::_internal_blocks(int index) const {
  return _impl_.blocks_.Get(index);
}
inline const ::LocatedBlock& ReportBadBlockRequest::blocks(int index) const {
  // @@protoc_insertion_point(field_get:DatanodeNamenode.ReportBadBlockRequest.blocks)
  return _internal_blocks(index);
}
inline ::LocatedBlock* ReportBadBlockRequest::_internal_add_blocks() {
  return _impl_.blocks_.Add();
}
inline ::LocatedBlock* ReportBadBlockRequest::add_blocks() {
  ::LocatedBlock* _add = _internal_add_blocks();
  // @@protoc_insertion_point(field_add:DatanodeNamenode.ReportBadBlockRequest.blocks)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LocatedBlock >&
ReportBadBlockRequest::blocks() const {
  // @@protoc_insertion_point(field_list:DatanodeNamenode.ReportBadBlockRequest.blocks)
  return _impl_.blocks_;
}

// -------------------------------------------------------------------

// ReportBadBlockResponse

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace DatanodeNamenode

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::DatanodeNamenode::DatanodeCommand_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DatanodeNamenode::DatanodeCommand_Type>() {
  return ::DatanodeNamenode::DatanodeCommand_Type_descriptor();
}
template <> struct is_proto_enum< ::DatanodeNamenode::BlockCommand_Action> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DatanodeNamenode::BlockCommand_Action>() {
  return ::DatanodeNamenode::BlockCommand_Action_descriptor();
}
template <> struct is_proto_enum< ::DatanodeNamenode::BlockId_Action> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DatanodeNamenode::BlockId_Action>() {
  return ::DatanodeNamenode::BlockId_Action_descriptor();
}
template <> struct is_proto_enum< ::DatanodeNamenode::ReceivedDeletedBlockInfo_BlockStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DatanodeNamenode::ReceivedDeletedBlockInfo_BlockStatus>() {
  return ::DatanodeNamenode::ReceivedDeletedBlockInfo_BlockStatus_descriptor();
}
template <> struct is_proto_enum< ::DatanodeNamenode::ErrorReportRequest_ErrorCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DatanodeNamenode::ErrorReportRequest_ErrorCode>() {
  return ::DatanodeNamenode::ErrorReportRequest_ErrorCode_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_DatanodeNamenode_2eproto
