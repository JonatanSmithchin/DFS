// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ClientDatanode.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_ClientDatanode_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_ClientDatanode_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "dfs.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_ClientDatanode_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_ClientDatanode_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_ClientDatanode_2eproto;
namespace ClientDatanode {
class downloadBlockRequest;
struct downloadBlockRequestDefaultTypeInternal;
extern downloadBlockRequestDefaultTypeInternal _downloadBlockRequest_default_instance_;
class downloadBlockResponse;
struct downloadBlockResponseDefaultTypeInternal;
extern downloadBlockResponseDefaultTypeInternal _downloadBlockResponse_default_instance_;
class shutdownDatanodeRequest;
struct shutdownDatanodeRequestDefaultTypeInternal;
extern shutdownDatanodeRequestDefaultTypeInternal _shutdownDatanodeRequest_default_instance_;
class shutdownDatanodeResponse;
struct shutdownDatanodeResponseDefaultTypeInternal;
extern shutdownDatanodeResponseDefaultTypeInternal _shutdownDatanodeResponse_default_instance_;
class transferBlockRequest;
struct transferBlockRequestDefaultTypeInternal;
extern transferBlockRequestDefaultTypeInternal _transferBlockRequest_default_instance_;
class transferBlockResponse;
struct transferBlockResponseDefaultTypeInternal;
extern transferBlockResponseDefaultTypeInternal _transferBlockResponse_default_instance_;
}  // namespace ClientDatanode
PROTOBUF_NAMESPACE_OPEN
template<> ::ClientDatanode::downloadBlockRequest* Arena::CreateMaybeMessage<::ClientDatanode::downloadBlockRequest>(Arena*);
template<> ::ClientDatanode::downloadBlockResponse* Arena::CreateMaybeMessage<::ClientDatanode::downloadBlockResponse>(Arena*);
template<> ::ClientDatanode::shutdownDatanodeRequest* Arena::CreateMaybeMessage<::ClientDatanode::shutdownDatanodeRequest>(Arena*);
template<> ::ClientDatanode::shutdownDatanodeResponse* Arena::CreateMaybeMessage<::ClientDatanode::shutdownDatanodeResponse>(Arena*);
template<> ::ClientDatanode::transferBlockRequest* Arena::CreateMaybeMessage<::ClientDatanode::transferBlockRequest>(Arena*);
template<> ::ClientDatanode::transferBlockResponse* Arena::CreateMaybeMessage<::ClientDatanode::transferBlockResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace ClientDatanode {

enum transferStatus : int {
  Unknown = 0,
  OK = 1,
  Failed = 2,
  transferStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  transferStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool transferStatus_IsValid(int value);
constexpr transferStatus transferStatus_MIN = Unknown;
constexpr transferStatus transferStatus_MAX = Failed;
constexpr int transferStatus_ARRAYSIZE = transferStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* transferStatus_descriptor();
template<typename T>
inline const std::string& transferStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, transferStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function transferStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    transferStatus_descriptor(), enum_t_value);
}
inline bool transferStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, transferStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<transferStatus>(
    transferStatus_descriptor(), name, value);
}
// ===================================================================

class shutdownDatanodeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:ClientDatanode.shutdownDatanodeRequest) */ {
 public:
  inline shutdownDatanodeRequest() : shutdownDatanodeRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR shutdownDatanodeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  shutdownDatanodeRequest(const shutdownDatanodeRequest& from);
  shutdownDatanodeRequest(shutdownDatanodeRequest&& from) noexcept
    : shutdownDatanodeRequest() {
    *this = ::std::move(from);
  }

  inline shutdownDatanodeRequest& operator=(const shutdownDatanodeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline shutdownDatanodeRequest& operator=(shutdownDatanodeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const shutdownDatanodeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const shutdownDatanodeRequest* internal_default_instance() {
    return reinterpret_cast<const shutdownDatanodeRequest*>(
               &_shutdownDatanodeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(shutdownDatanodeRequest& a, shutdownDatanodeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(shutdownDatanodeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(shutdownDatanodeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  shutdownDatanodeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<shutdownDatanodeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const shutdownDatanodeRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const shutdownDatanodeRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ClientDatanode.shutdownDatanodeRequest";
  }
  protected:
  explicit shutdownDatanodeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ClientDatanode.shutdownDatanodeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_ClientDatanode_2eproto;
};
// -------------------------------------------------------------------

class shutdownDatanodeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:ClientDatanode.shutdownDatanodeResponse) */ {
 public:
  inline shutdownDatanodeResponse() : shutdownDatanodeResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR shutdownDatanodeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  shutdownDatanodeResponse(const shutdownDatanodeResponse& from);
  shutdownDatanodeResponse(shutdownDatanodeResponse&& from) noexcept
    : shutdownDatanodeResponse() {
    *this = ::std::move(from);
  }

  inline shutdownDatanodeResponse& operator=(const shutdownDatanodeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline shutdownDatanodeResponse& operator=(shutdownDatanodeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const shutdownDatanodeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const shutdownDatanodeResponse* internal_default_instance() {
    return reinterpret_cast<const shutdownDatanodeResponse*>(
               &_shutdownDatanodeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(shutdownDatanodeResponse& a, shutdownDatanodeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(shutdownDatanodeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(shutdownDatanodeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  shutdownDatanodeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<shutdownDatanodeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const shutdownDatanodeResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const shutdownDatanodeResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ClientDatanode.shutdownDatanodeResponse";
  }
  protected:
  explicit shutdownDatanodeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ClientDatanode.shutdownDatanodeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_ClientDatanode_2eproto;
};
// -------------------------------------------------------------------

class transferBlockRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ClientDatanode.transferBlockRequest) */ {
 public:
  inline transferBlockRequest() : transferBlockRequest(nullptr) {}
  ~transferBlockRequest() override;
  explicit PROTOBUF_CONSTEXPR transferBlockRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  transferBlockRequest(const transferBlockRequest& from);
  transferBlockRequest(transferBlockRequest&& from) noexcept
    : transferBlockRequest() {
    *this = ::std::move(from);
  }

  inline transferBlockRequest& operator=(const transferBlockRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline transferBlockRequest& operator=(transferBlockRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const transferBlockRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const transferBlockRequest* internal_default_instance() {
    return reinterpret_cast<const transferBlockRequest*>(
               &_transferBlockRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(transferBlockRequest& a, transferBlockRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(transferBlockRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(transferBlockRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  transferBlockRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<transferBlockRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const transferBlockRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const transferBlockRequest& from) {
    transferBlockRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(transferBlockRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ClientDatanode.transferBlockRequest";
  }
  protected:
  explicit transferBlockRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpAddrsFieldNumber = 5,
    kContentFieldNumber = 3,
    kBlockIdFieldNumber = 1,
    kSizeFieldNumber = 2,
    kCheckSumFieldNumber = 4,
  };
  // repeated string ipAddrs = 5;
  int ipaddrs_size() const;
  private:
  int _internal_ipaddrs_size() const;
  public:
  void clear_ipaddrs();
  const std::string& ipaddrs(int index) const;
  std::string* mutable_ipaddrs(int index);
  void set_ipaddrs(int index, const std::string& value);
  void set_ipaddrs(int index, std::string&& value);
  void set_ipaddrs(int index, const char* value);
  void set_ipaddrs(int index, const char* value, size_t size);
  std::string* add_ipaddrs();
  void add_ipaddrs(const std::string& value);
  void add_ipaddrs(std::string&& value);
  void add_ipaddrs(const char* value);
  void add_ipaddrs(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& ipaddrs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_ipaddrs();
  private:
  const std::string& _internal_ipaddrs(int index) const;
  std::string* _internal_add_ipaddrs();
  public:

  // bytes Content = 3;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // uint64 blockId = 1;
  void clear_blockid();
  uint64_t blockid() const;
  void set_blockid(uint64_t value);
  private:
  uint64_t _internal_blockid() const;
  void _internal_set_blockid(uint64_t value);
  public:

  // uint64 size = 2;
  void clear_size();
  uint64_t size() const;
  void set_size(uint64_t value);
  private:
  uint64_t _internal_size() const;
  void _internal_set_size(uint64_t value);
  public:

  // uint32 checkSum = 4;
  void clear_checksum();
  uint32_t checksum() const;
  void set_checksum(uint32_t value);
  private:
  uint32_t _internal_checksum() const;
  void _internal_set_checksum(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ClientDatanode.transferBlockRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> ipaddrs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    uint64_t blockid_;
    uint64_t size_;
    uint32_t checksum_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ClientDatanode_2eproto;
};
// -------------------------------------------------------------------

class transferBlockResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ClientDatanode.transferBlockResponse) */ {
 public:
  inline transferBlockResponse() : transferBlockResponse(nullptr) {}
  ~transferBlockResponse() override;
  explicit PROTOBUF_CONSTEXPR transferBlockResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  transferBlockResponse(const transferBlockResponse& from);
  transferBlockResponse(transferBlockResponse&& from) noexcept
    : transferBlockResponse() {
    *this = ::std::move(from);
  }

  inline transferBlockResponse& operator=(const transferBlockResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline transferBlockResponse& operator=(transferBlockResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const transferBlockResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const transferBlockResponse* internal_default_instance() {
    return reinterpret_cast<const transferBlockResponse*>(
               &_transferBlockResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(transferBlockResponse& a, transferBlockResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(transferBlockResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(transferBlockResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  transferBlockResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<transferBlockResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const transferBlockResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const transferBlockResponse& from) {
    transferBlockResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(transferBlockResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ClientDatanode.transferBlockResponse";
  }
  protected:
  explicit transferBlockResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // .ClientDatanode.transferStatus status = 1;
  void clear_status();
  ::ClientDatanode::transferStatus status() const;
  void set_status(::ClientDatanode::transferStatus value);
  private:
  ::ClientDatanode::transferStatus _internal_status() const;
  void _internal_set_status(::ClientDatanode::transferStatus value);
  public:

  // @@protoc_insertion_point(class_scope:ClientDatanode.transferBlockResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ClientDatanode_2eproto;
};
// -------------------------------------------------------------------

class downloadBlockRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ClientDatanode.downloadBlockRequest) */ {
 public:
  inline downloadBlockRequest() : downloadBlockRequest(nullptr) {}
  ~downloadBlockRequest() override;
  explicit PROTOBUF_CONSTEXPR downloadBlockRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  downloadBlockRequest(const downloadBlockRequest& from);
  downloadBlockRequest(downloadBlockRequest&& from) noexcept
    : downloadBlockRequest() {
    *this = ::std::move(from);
  }

  inline downloadBlockRequest& operator=(const downloadBlockRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline downloadBlockRequest& operator=(downloadBlockRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const downloadBlockRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const downloadBlockRequest* internal_default_instance() {
    return reinterpret_cast<const downloadBlockRequest*>(
               &_downloadBlockRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(downloadBlockRequest& a, downloadBlockRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(downloadBlockRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(downloadBlockRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  downloadBlockRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<downloadBlockRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const downloadBlockRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const downloadBlockRequest& from) {
    downloadBlockRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(downloadBlockRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ClientDatanode.downloadBlockRequest";
  }
  protected:
  explicit downloadBlockRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockIdFieldNumber = 1,
  };
  // repeated uint64 blockId = 1;
  int blockid_size() const;
  private:
  int _internal_blockid_size() const;
  public:
  void clear_blockid();
  private:
  uint64_t _internal_blockid(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_blockid() const;
  void _internal_add_blockid(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_blockid();
  public:
  uint64_t blockid(int index) const;
  void set_blockid(int index, uint64_t value);
  void add_blockid(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      blockid() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_blockid();

  // @@protoc_insertion_point(class_scope:ClientDatanode.downloadBlockRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > blockid_;
    mutable std::atomic<int> _blockid_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ClientDatanode_2eproto;
};
// -------------------------------------------------------------------

class downloadBlockResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ClientDatanode.downloadBlockResponse) */ {
 public:
  inline downloadBlockResponse() : downloadBlockResponse(nullptr) {}
  ~downloadBlockResponse() override;
  explicit PROTOBUF_CONSTEXPR downloadBlockResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  downloadBlockResponse(const downloadBlockResponse& from);
  downloadBlockResponse(downloadBlockResponse&& from) noexcept
    : downloadBlockResponse() {
    *this = ::std::move(from);
  }

  inline downloadBlockResponse& operator=(const downloadBlockResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline downloadBlockResponse& operator=(downloadBlockResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const downloadBlockResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const downloadBlockResponse* internal_default_instance() {
    return reinterpret_cast<const downloadBlockResponse*>(
               &_downloadBlockResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(downloadBlockResponse& a, downloadBlockResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(downloadBlockResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(downloadBlockResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  downloadBlockResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<downloadBlockResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const downloadBlockResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const downloadBlockResponse& from) {
    downloadBlockResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(downloadBlockResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ClientDatanode.downloadBlockResponse";
  }
  protected:
  explicit downloadBlockResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentFieldNumber = 1,
    kCheckSumFieldNumber = 2,
    kStatusFieldNumber = 3,
  };
  // bytes Content = 1;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // uint32 checkSum = 2;
  void clear_checksum();
  uint32_t checksum() const;
  void set_checksum(uint32_t value);
  private:
  uint32_t _internal_checksum() const;
  void _internal_set_checksum(uint32_t value);
  public:

  // .ClientDatanode.transferStatus status = 3;
  void clear_status();
  ::ClientDatanode::transferStatus status() const;
  void set_status(::ClientDatanode::transferStatus value);
  private:
  ::ClientDatanode::transferStatus _internal_status() const;
  void _internal_set_status(::ClientDatanode::transferStatus value);
  public:

  // @@protoc_insertion_point(class_scope:ClientDatanode.downloadBlockResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    uint32_t checksum_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ClientDatanode_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// shutdownDatanodeRequest

// -------------------------------------------------------------------

// shutdownDatanodeResponse

// -------------------------------------------------------------------

// transferBlockRequest

// uint64 blockId = 1;
inline void transferBlockRequest::clear_blockid() {
  _impl_.blockid_ = uint64_t{0u};
}
inline uint64_t transferBlockRequest::_internal_blockid() const {
  return _impl_.blockid_;
}
inline uint64_t transferBlockRequest::blockid() const {
  // @@protoc_insertion_point(field_get:ClientDatanode.transferBlockRequest.blockId)
  return _internal_blockid();
}
inline void transferBlockRequest::_internal_set_blockid(uint64_t value) {
  
  _impl_.blockid_ = value;
}
inline void transferBlockRequest::set_blockid(uint64_t value) {
  _internal_set_blockid(value);
  // @@protoc_insertion_point(field_set:ClientDatanode.transferBlockRequest.blockId)
}

// uint64 size = 2;
inline void transferBlockRequest::clear_size() {
  _impl_.size_ = uint64_t{0u};
}
inline uint64_t transferBlockRequest::_internal_size() const {
  return _impl_.size_;
}
inline uint64_t transferBlockRequest::size() const {
  // @@protoc_insertion_point(field_get:ClientDatanode.transferBlockRequest.size)
  return _internal_size();
}
inline void transferBlockRequest::_internal_set_size(uint64_t value) {
  
  _impl_.size_ = value;
}
inline void transferBlockRequest::set_size(uint64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:ClientDatanode.transferBlockRequest.size)
}

// bytes Content = 3;
inline void transferBlockRequest::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& transferBlockRequest::content() const {
  // @@protoc_insertion_point(field_get:ClientDatanode.transferBlockRequest.Content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void transferBlockRequest::set_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ClientDatanode.transferBlockRequest.Content)
}
inline std::string* transferBlockRequest::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:ClientDatanode.transferBlockRequest.Content)
  return _s;
}
inline const std::string& transferBlockRequest::_internal_content() const {
  return _impl_.content_.Get();
}
inline void transferBlockRequest::_internal_set_content(const std::string& value) {
  
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* transferBlockRequest::_internal_mutable_content() {
  
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* transferBlockRequest::release_content() {
  // @@protoc_insertion_point(field_release:ClientDatanode.transferBlockRequest.Content)
  return _impl_.content_.Release();
}
inline void transferBlockRequest::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ClientDatanode.transferBlockRequest.Content)
}

// uint32 checkSum = 4;
inline void transferBlockRequest::clear_checksum() {
  _impl_.checksum_ = 0u;
}
inline uint32_t transferBlockRequest::_internal_checksum() const {
  return _impl_.checksum_;
}
inline uint32_t transferBlockRequest::checksum() const {
  // @@protoc_insertion_point(field_get:ClientDatanode.transferBlockRequest.checkSum)
  return _internal_checksum();
}
inline void transferBlockRequest::_internal_set_checksum(uint32_t value) {
  
  _impl_.checksum_ = value;
}
inline void transferBlockRequest::set_checksum(uint32_t value) {
  _internal_set_checksum(value);
  // @@protoc_insertion_point(field_set:ClientDatanode.transferBlockRequest.checkSum)
}

// repeated string ipAddrs = 5;
inline int transferBlockRequest::_internal_ipaddrs_size() const {
  return _impl_.ipaddrs_.size();
}
inline int transferBlockRequest::ipaddrs_size() const {
  return _internal_ipaddrs_size();
}
inline void transferBlockRequest::clear_ipaddrs() {
  _impl_.ipaddrs_.Clear();
}
inline std::string* transferBlockRequest::add_ipaddrs() {
  std::string* _s = _internal_add_ipaddrs();
  // @@protoc_insertion_point(field_add_mutable:ClientDatanode.transferBlockRequest.ipAddrs)
  return _s;
}
inline const std::string& transferBlockRequest::_internal_ipaddrs(int index) const {
  return _impl_.ipaddrs_.Get(index);
}
inline const std::string& transferBlockRequest::ipaddrs(int index) const {
  // @@protoc_insertion_point(field_get:ClientDatanode.transferBlockRequest.ipAddrs)
  return _internal_ipaddrs(index);
}
inline std::string* transferBlockRequest::mutable_ipaddrs(int index) {
  // @@protoc_insertion_point(field_mutable:ClientDatanode.transferBlockRequest.ipAddrs)
  return _impl_.ipaddrs_.Mutable(index);
}
inline void transferBlockRequest::set_ipaddrs(int index, const std::string& value) {
  _impl_.ipaddrs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ClientDatanode.transferBlockRequest.ipAddrs)
}
inline void transferBlockRequest::set_ipaddrs(int index, std::string&& value) {
  _impl_.ipaddrs_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ClientDatanode.transferBlockRequest.ipAddrs)
}
inline void transferBlockRequest::set_ipaddrs(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.ipaddrs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ClientDatanode.transferBlockRequest.ipAddrs)
}
inline void transferBlockRequest::set_ipaddrs(int index, const char* value, size_t size) {
  _impl_.ipaddrs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ClientDatanode.transferBlockRequest.ipAddrs)
}
inline std::string* transferBlockRequest::_internal_add_ipaddrs() {
  return _impl_.ipaddrs_.Add();
}
inline void transferBlockRequest::add_ipaddrs(const std::string& value) {
  _impl_.ipaddrs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ClientDatanode.transferBlockRequest.ipAddrs)
}
inline void transferBlockRequest::add_ipaddrs(std::string&& value) {
  _impl_.ipaddrs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ClientDatanode.transferBlockRequest.ipAddrs)
}
inline void transferBlockRequest::add_ipaddrs(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.ipaddrs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ClientDatanode.transferBlockRequest.ipAddrs)
}
inline void transferBlockRequest::add_ipaddrs(const char* value, size_t size) {
  _impl_.ipaddrs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ClientDatanode.transferBlockRequest.ipAddrs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
transferBlockRequest::ipaddrs() const {
  // @@protoc_insertion_point(field_list:ClientDatanode.transferBlockRequest.ipAddrs)
  return _impl_.ipaddrs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
transferBlockRequest::mutable_ipaddrs() {
  // @@protoc_insertion_point(field_mutable_list:ClientDatanode.transferBlockRequest.ipAddrs)
  return &_impl_.ipaddrs_;
}

// -------------------------------------------------------------------

// transferBlockResponse

// .ClientDatanode.transferStatus status = 1;
inline void transferBlockResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::ClientDatanode::transferStatus transferBlockResponse::_internal_status() const {
  return static_cast< ::ClientDatanode::transferStatus >(_impl_.status_);
}
inline ::ClientDatanode::transferStatus transferBlockResponse::status() const {
  // @@protoc_insertion_point(field_get:ClientDatanode.transferBlockResponse.status)
  return _internal_status();
}
inline void transferBlockResponse::_internal_set_status(::ClientDatanode::transferStatus value) {
  
  _impl_.status_ = value;
}
inline void transferBlockResponse::set_status(::ClientDatanode::transferStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:ClientDatanode.transferBlockResponse.status)
}

// -------------------------------------------------------------------

// downloadBlockRequest

// repeated uint64 blockId = 1;
inline int downloadBlockRequest::_internal_blockid_size() const {
  return _impl_.blockid_.size();
}
inline int downloadBlockRequest::blockid_size() const {
  return _internal_blockid_size();
}
inline void downloadBlockRequest::clear_blockid() {
  _impl_.blockid_.Clear();
}
inline uint64_t downloadBlockRequest::_internal_blockid(int index) const {
  return _impl_.blockid_.Get(index);
}
inline uint64_t downloadBlockRequest::blockid(int index) const {
  // @@protoc_insertion_point(field_get:ClientDatanode.downloadBlockRequest.blockId)
  return _internal_blockid(index);
}
inline void downloadBlockRequest::set_blockid(int index, uint64_t value) {
  _impl_.blockid_.Set(index, value);
  // @@protoc_insertion_point(field_set:ClientDatanode.downloadBlockRequest.blockId)
}
inline void downloadBlockRequest::_internal_add_blockid(uint64_t value) {
  _impl_.blockid_.Add(value);
}
inline void downloadBlockRequest::add_blockid(uint64_t value) {
  _internal_add_blockid(value);
  // @@protoc_insertion_point(field_add:ClientDatanode.downloadBlockRequest.blockId)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
downloadBlockRequest::_internal_blockid() const {
  return _impl_.blockid_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
downloadBlockRequest::blockid() const {
  // @@protoc_insertion_point(field_list:ClientDatanode.downloadBlockRequest.blockId)
  return _internal_blockid();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
downloadBlockRequest::_internal_mutable_blockid() {
  return &_impl_.blockid_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
downloadBlockRequest::mutable_blockid() {
  // @@protoc_insertion_point(field_mutable_list:ClientDatanode.downloadBlockRequest.blockId)
  return _internal_mutable_blockid();
}

// -------------------------------------------------------------------

// downloadBlockResponse

// bytes Content = 1;
inline void downloadBlockResponse::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& downloadBlockResponse::content() const {
  // @@protoc_insertion_point(field_get:ClientDatanode.downloadBlockResponse.Content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void downloadBlockResponse::set_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ClientDatanode.downloadBlockResponse.Content)
}
inline std::string* downloadBlockResponse::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:ClientDatanode.downloadBlockResponse.Content)
  return _s;
}
inline const std::string& downloadBlockResponse::_internal_content() const {
  return _impl_.content_.Get();
}
inline void downloadBlockResponse::_internal_set_content(const std::string& value) {
  
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* downloadBlockResponse::_internal_mutable_content() {
  
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* downloadBlockResponse::release_content() {
  // @@protoc_insertion_point(field_release:ClientDatanode.downloadBlockResponse.Content)
  return _impl_.content_.Release();
}
inline void downloadBlockResponse::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ClientDatanode.downloadBlockResponse.Content)
}

// uint32 checkSum = 2;
inline void downloadBlockResponse::clear_checksum() {
  _impl_.checksum_ = 0u;
}
inline uint32_t downloadBlockResponse::_internal_checksum() const {
  return _impl_.checksum_;
}
inline uint32_t downloadBlockResponse::checksum() const {
  // @@protoc_insertion_point(field_get:ClientDatanode.downloadBlockResponse.checkSum)
  return _internal_checksum();
}
inline void downloadBlockResponse::_internal_set_checksum(uint32_t value) {
  
  _impl_.checksum_ = value;
}
inline void downloadBlockResponse::set_checksum(uint32_t value) {
  _internal_set_checksum(value);
  // @@protoc_insertion_point(field_set:ClientDatanode.downloadBlockResponse.checkSum)
}

// .ClientDatanode.transferStatus status = 3;
inline void downloadBlockResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::ClientDatanode::transferStatus downloadBlockResponse::_internal_status() const {
  return static_cast< ::ClientDatanode::transferStatus >(_impl_.status_);
}
inline ::ClientDatanode::transferStatus downloadBlockResponse::status() const {
  // @@protoc_insertion_point(field_get:ClientDatanode.downloadBlockResponse.status)
  return _internal_status();
}
inline void downloadBlockResponse::_internal_set_status(::ClientDatanode::transferStatus value) {
  
  _impl_.status_ = value;
}
inline void downloadBlockResponse::set_status(::ClientDatanode::transferStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:ClientDatanode.downloadBlockResponse.status)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ClientDatanode

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::ClientDatanode::transferStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ClientDatanode::transferStatus>() {
  return ::ClientDatanode::transferStatus_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_ClientDatanode_2eproto
