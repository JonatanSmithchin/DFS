// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dfs.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_dfs_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_dfs_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_dfs_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_dfs_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_dfs_2eproto;
class Block;
struct BlockDefaultTypeInternal;
extern BlockDefaultTypeInternal _Block_default_instance_;
class BlockKey;
struct BlockKeyDefaultTypeInternal;
extern BlockKeyDefaultTypeInternal _BlockKey_default_instance_;
class BlockWithLocation;
struct BlockWithLocationDefaultTypeInternal;
extern BlockWithLocationDefaultTypeInternal _BlockWithLocation_default_instance_;
class BlocksWithLocation;
struct BlocksWithLocationDefaultTypeInternal;
extern BlocksWithLocationDefaultTypeInternal _BlocksWithLocation_default_instance_;
class DatanodeID;
struct DatanodeIDDefaultTypeInternal;
extern DatanodeIDDefaultTypeInternal _DatanodeID_default_instance_;
class DatanodeInfo;
struct DatanodeInfoDefaultTypeInternal;
extern DatanodeInfoDefaultTypeInternal _DatanodeInfo_default_instance_;
class DirectoryListing;
struct DirectoryListingDefaultTypeInternal;
extern DirectoryListingDefaultTypeInternal _DirectoryListing_default_instance_;
class FileStatus;
struct FileStatusDefaultTypeInternal;
extern FileStatusDefaultTypeInternal _FileStatus_default_instance_;
class LocatedBlock;
struct LocatedBlockDefaultTypeInternal;
extern LocatedBlockDefaultTypeInternal _LocatedBlock_default_instance_;
class LocatedBlocks;
struct LocatedBlocksDefaultTypeInternal;
extern LocatedBlocksDefaultTypeInternal _LocatedBlocks_default_instance_;
class Permission;
struct PermissionDefaultTypeInternal;
extern PermissionDefaultTypeInternal _Permission_default_instance_;
class ServerDefaults;
struct ServerDefaultsDefaultTypeInternal;
extern ServerDefaultsDefaultTypeInternal _ServerDefaults_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::Block* Arena::CreateMaybeMessage<::Block>(Arena*);
template<> ::BlockKey* Arena::CreateMaybeMessage<::BlockKey>(Arena*);
template<> ::BlockWithLocation* Arena::CreateMaybeMessage<::BlockWithLocation>(Arena*);
template<> ::BlocksWithLocation* Arena::CreateMaybeMessage<::BlocksWithLocation>(Arena*);
template<> ::DatanodeID* Arena::CreateMaybeMessage<::DatanodeID>(Arena*);
template<> ::DatanodeInfo* Arena::CreateMaybeMessage<::DatanodeInfo>(Arena*);
template<> ::DirectoryListing* Arena::CreateMaybeMessage<::DirectoryListing>(Arena*);
template<> ::FileStatus* Arena::CreateMaybeMessage<::FileStatus>(Arena*);
template<> ::LocatedBlock* Arena::CreateMaybeMessage<::LocatedBlock>(Arena*);
template<> ::LocatedBlocks* Arena::CreateMaybeMessage<::LocatedBlocks>(Arena*);
template<> ::Permission* Arena::CreateMaybeMessage<::Permission>(Arena*);
template<> ::ServerDefaults* Arena::CreateMaybeMessage<::ServerDefaults>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum DatanodeInfo_AdminState : int {
  DatanodeInfo_AdminState_NORMAL = 0,
  DatanodeInfo_AdminState_DECOMMISSION_INPROGRESS = 1,
  DatanodeInfo_AdminState_DECOMMISSIONED = 2,
  DatanodeInfo_AdminState_DatanodeInfo_AdminState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DatanodeInfo_AdminState_DatanodeInfo_AdminState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DatanodeInfo_AdminState_IsValid(int value);
constexpr DatanodeInfo_AdminState DatanodeInfo_AdminState_AdminState_MIN = DatanodeInfo_AdminState_NORMAL;
constexpr DatanodeInfo_AdminState DatanodeInfo_AdminState_AdminState_MAX = DatanodeInfo_AdminState_DECOMMISSIONED;
constexpr int DatanodeInfo_AdminState_AdminState_ARRAYSIZE = DatanodeInfo_AdminState_AdminState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DatanodeInfo_AdminState_descriptor();
template<typename T>
inline const std::string& DatanodeInfo_AdminState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DatanodeInfo_AdminState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DatanodeInfo_AdminState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DatanodeInfo_AdminState_descriptor(), enum_t_value);
}
inline bool DatanodeInfo_AdminState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DatanodeInfo_AdminState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DatanodeInfo_AdminState>(
    DatanodeInfo_AdminState_descriptor(), name, value);
}
enum FileStatus_FileType : int {
  FileStatus_FileType_IS_DIR = 0,
  FileStatus_FileType_IS_FILE = 1,
  FileStatus_FileType_IS_SYMLINK = 2,
  FileStatus_FileType_FileStatus_FileType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FileStatus_FileType_FileStatus_FileType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool FileStatus_FileType_IsValid(int value);
constexpr FileStatus_FileType FileStatus_FileType_FileType_MIN = FileStatus_FileType_IS_DIR;
constexpr FileStatus_FileType FileStatus_FileType_FileType_MAX = FileStatus_FileType_IS_SYMLINK;
constexpr int FileStatus_FileType_FileType_ARRAYSIZE = FileStatus_FileType_FileType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FileStatus_FileType_descriptor();
template<typename T>
inline const std::string& FileStatus_FileType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FileStatus_FileType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FileStatus_FileType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FileStatus_FileType_descriptor(), enum_t_value);
}
inline bool FileStatus_FileType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FileStatus_FileType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FileStatus_FileType>(
    FileStatus_FileType_descriptor(), name, value);
}
enum ChecksumType : int {
  CHECKSUM_CRC32 = 0,
  CHECKSUM_NULL = 1,
  CHECKSUM_CRC32C = 2,
  ChecksumType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ChecksumType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ChecksumType_IsValid(int value);
constexpr ChecksumType ChecksumType_MIN = CHECKSUM_CRC32;
constexpr ChecksumType ChecksumType_MAX = CHECKSUM_CRC32C;
constexpr int ChecksumType_ARRAYSIZE = ChecksumType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ChecksumType_descriptor();
template<typename T>
inline const std::string& ChecksumType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ChecksumType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ChecksumType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ChecksumType_descriptor(), enum_t_value);
}
inline bool ChecksumType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ChecksumType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ChecksumType>(
    ChecksumType_descriptor(), name, value);
}
// ===================================================================

class DatanodeID final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DatanodeID) */ {
 public:
  inline DatanodeID() : DatanodeID(nullptr) {}
  ~DatanodeID() override;
  explicit PROTOBUF_CONSTEXPR DatanodeID(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DatanodeID(const DatanodeID& from);
  DatanodeID(DatanodeID&& from) noexcept
    : DatanodeID() {
    *this = ::std::move(from);
  }

  inline DatanodeID& operator=(const DatanodeID& from) {
    CopyFrom(from);
    return *this;
  }
  inline DatanodeID& operator=(DatanodeID&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DatanodeID& default_instance() {
    return *internal_default_instance();
  }
  static inline const DatanodeID* internal_default_instance() {
    return reinterpret_cast<const DatanodeID*>(
               &_DatanodeID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DatanodeID& a, DatanodeID& b) {
    a.Swap(&b);
  }
  inline void Swap(DatanodeID* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DatanodeID* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DatanodeID* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DatanodeID>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DatanodeID& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DatanodeID& from) {
    DatanodeID::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DatanodeID* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DatanodeID";
  }
  protected:
  explicit DatanodeID(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpAddrFieldNumber = 1,
    kHostNameFieldNumber = 2,
    kDatanodeUuidFieldNumber = 3,
    kXferPortFieldNumber = 4,
    kInfoPortFieldNumber = 5,
    kIpcPortFieldNumber = 6,
    kInfoSecurePortFieldNumber = 7,
  };
  // string ipAddr = 1;
  void clear_ipaddr();
  const std::string& ipaddr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ipaddr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ipaddr();
  PROTOBUF_NODISCARD std::string* release_ipaddr();
  void set_allocated_ipaddr(std::string* ipaddr);
  private:
  const std::string& _internal_ipaddr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ipaddr(const std::string& value);
  std::string* _internal_mutable_ipaddr();
  public:

  // string hostName = 2;
  void clear_hostname();
  const std::string& hostname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hostname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hostname();
  PROTOBUF_NODISCARD std::string* release_hostname();
  void set_allocated_hostname(std::string* hostname);
  private:
  const std::string& _internal_hostname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hostname(const std::string& value);
  std::string* _internal_mutable_hostname();
  public:

  // string datanodeUuid = 3;
  void clear_datanodeuuid();
  const std::string& datanodeuuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_datanodeuuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_datanodeuuid();
  PROTOBUF_NODISCARD std::string* release_datanodeuuid();
  void set_allocated_datanodeuuid(std::string* datanodeuuid);
  private:
  const std::string& _internal_datanodeuuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_datanodeuuid(const std::string& value);
  std::string* _internal_mutable_datanodeuuid();
  public:

  // uint32 xferPort = 4;
  void clear_xferport();
  uint32_t xferport() const;
  void set_xferport(uint32_t value);
  private:
  uint32_t _internal_xferport() const;
  void _internal_set_xferport(uint32_t value);
  public:

  // uint32 infoPort = 5;
  void clear_infoport();
  uint32_t infoport() const;
  void set_infoport(uint32_t value);
  private:
  uint32_t _internal_infoport() const;
  void _internal_set_infoport(uint32_t value);
  public:

  // uint32 ipcPort = 6;
  void clear_ipcport();
  uint32_t ipcport() const;
  void set_ipcport(uint32_t value);
  private:
  uint32_t _internal_ipcport() const;
  void _internal_set_ipcport(uint32_t value);
  public:

  // uint32 infoSecurePort = 7;
  void clear_infosecureport();
  uint32_t infosecureport() const;
  void set_infosecureport(uint32_t value);
  private:
  uint32_t _internal_infosecureport() const;
  void _internal_set_infosecureport(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:DatanodeID)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ipaddr_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hostname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr datanodeuuid_;
    uint32_t xferport_;
    uint32_t infoport_;
    uint32_t ipcport_;
    uint32_t infosecureport_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dfs_2eproto;
};
// -------------------------------------------------------------------

class DatanodeInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DatanodeInfo) */ {
 public:
  inline DatanodeInfo() : DatanodeInfo(nullptr) {}
  ~DatanodeInfo() override;
  explicit PROTOBUF_CONSTEXPR DatanodeInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DatanodeInfo(const DatanodeInfo& from);
  DatanodeInfo(DatanodeInfo&& from) noexcept
    : DatanodeInfo() {
    *this = ::std::move(from);
  }

  inline DatanodeInfo& operator=(const DatanodeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DatanodeInfo& operator=(DatanodeInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DatanodeInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const DatanodeInfo* internal_default_instance() {
    return reinterpret_cast<const DatanodeInfo*>(
               &_DatanodeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DatanodeInfo& a, DatanodeInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(DatanodeInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DatanodeInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DatanodeInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DatanodeInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DatanodeInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DatanodeInfo& from) {
    DatanodeInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DatanodeInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DatanodeInfo";
  }
  protected:
  explicit DatanodeInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DatanodeInfo_AdminState AdminState;
  static constexpr AdminState NORMAL =
    DatanodeInfo_AdminState_NORMAL;
  static constexpr AdminState DECOMMISSION_INPROGRESS =
    DatanodeInfo_AdminState_DECOMMISSION_INPROGRESS;
  static constexpr AdminState DECOMMISSIONED =
    DatanodeInfo_AdminState_DECOMMISSIONED;
  static inline bool AdminState_IsValid(int value) {
    return DatanodeInfo_AdminState_IsValid(value);
  }
  static constexpr AdminState AdminState_MIN =
    DatanodeInfo_AdminState_AdminState_MIN;
  static constexpr AdminState AdminState_MAX =
    DatanodeInfo_AdminState_AdminState_MAX;
  static constexpr int AdminState_ARRAYSIZE =
    DatanodeInfo_AdminState_AdminState_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  AdminState_descriptor() {
    return DatanodeInfo_AdminState_descriptor();
  }
  template<typename T>
  static inline const std::string& AdminState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AdminState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AdminState_Name.");
    return DatanodeInfo_AdminState_Name(enum_t_value);
  }
  static inline bool AdminState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      AdminState* value) {
    return DatanodeInfo_AdminState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLocationFieldNumber = 8,
    kIdFieldNumber = 1,
    kCapacityFieldNumber = 2,
    kUsedFieldNumber = 3,
    kRemainingFieldNumber = 4,
    kLastUpdateFieldNumber = 5,
    kXceiverCountFieldNumber = 6,
    kAdminStateFieldNumber = 9,
  };
  // string location = 8;
  void clear_location();
  const std::string& location() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location();
  PROTOBUF_NODISCARD std::string* release_location();
  void set_allocated_location(std::string* location);
  private:
  const std::string& _internal_location() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location(const std::string& value);
  std::string* _internal_mutable_location();
  public:

  // .DatanodeID id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::DatanodeID& id() const;
  PROTOBUF_NODISCARD ::DatanodeID* release_id();
  ::DatanodeID* mutable_id();
  void set_allocated_id(::DatanodeID* id);
  private:
  const ::DatanodeID& _internal_id() const;
  ::DatanodeID* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::DatanodeID* id);
  ::DatanodeID* unsafe_arena_release_id();

  // uint64 capacity = 2;
  void clear_capacity();
  uint64_t capacity() const;
  void set_capacity(uint64_t value);
  private:
  uint64_t _internal_capacity() const;
  void _internal_set_capacity(uint64_t value);
  public:

  // uint64 used = 3;
  void clear_used();
  uint64_t used() const;
  void set_used(uint64_t value);
  private:
  uint64_t _internal_used() const;
  void _internal_set_used(uint64_t value);
  public:

  // uint64 remaining = 4;
  void clear_remaining();
  uint64_t remaining() const;
  void set_remaining(uint64_t value);
  private:
  uint64_t _internal_remaining() const;
  void _internal_set_remaining(uint64_t value);
  public:

  // uint64 lastUpdate = 5;
  void clear_lastupdate();
  uint64_t lastupdate() const;
  void set_lastupdate(uint64_t value);
  private:
  uint64_t _internal_lastupdate() const;
  void _internal_set_lastupdate(uint64_t value);
  public:

  // uint32 xceiverCount = 6;
  void clear_xceivercount();
  uint32_t xceivercount() const;
  void set_xceivercount(uint32_t value);
  private:
  uint32_t _internal_xceivercount() const;
  void _internal_set_xceivercount(uint32_t value);
  public:

  // .DatanodeInfo.AdminState adminState = 9;
  void clear_adminstate();
  ::DatanodeInfo_AdminState adminstate() const;
  void set_adminstate(::DatanodeInfo_AdminState value);
  private:
  ::DatanodeInfo_AdminState _internal_adminstate() const;
  void _internal_set_adminstate(::DatanodeInfo_AdminState value);
  public:

  // @@protoc_insertion_point(class_scope:DatanodeInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_;
    ::DatanodeID* id_;
    uint64_t capacity_;
    uint64_t used_;
    uint64_t remaining_;
    uint64_t lastupdate_;
    uint32_t xceivercount_;
    int adminstate_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dfs_2eproto;
};
// -------------------------------------------------------------------

class Permission final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Permission) */ {
 public:
  inline Permission() : Permission(nullptr) {}
  ~Permission() override;
  explicit PROTOBUF_CONSTEXPR Permission(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Permission(const Permission& from);
  Permission(Permission&& from) noexcept
    : Permission() {
    *this = ::std::move(from);
  }

  inline Permission& operator=(const Permission& from) {
    CopyFrom(from);
    return *this;
  }
  inline Permission& operator=(Permission&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Permission& default_instance() {
    return *internal_default_instance();
  }
  static inline const Permission* internal_default_instance() {
    return reinterpret_cast<const Permission*>(
               &_Permission_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Permission& a, Permission& b) {
    a.Swap(&b);
  }
  inline void Swap(Permission* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Permission* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Permission* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Permission>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Permission& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Permission& from) {
    Permission::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Permission* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Permission";
  }
  protected:
  explicit Permission(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPsermissionFieldNumber = 1,
  };
  // uint32 psermission = 1;
  void clear_psermission();
  uint32_t psermission() const;
  void set_psermission(uint32_t value);
  private:
  uint32_t _internal_psermission() const;
  void _internal_set_psermission(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Permission)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t psermission_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dfs_2eproto;
};
// -------------------------------------------------------------------

class FileStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:FileStatus) */ {
 public:
  inline FileStatus() : FileStatus(nullptr) {}
  ~FileStatus() override;
  explicit PROTOBUF_CONSTEXPR FileStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileStatus(const FileStatus& from);
  FileStatus(FileStatus&& from) noexcept
    : FileStatus() {
    *this = ::std::move(from);
  }

  inline FileStatus& operator=(const FileStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileStatus& operator=(FileStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileStatus* internal_default_instance() {
    return reinterpret_cast<const FileStatus*>(
               &_FileStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(FileStatus& a, FileStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(FileStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FileStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FileStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FileStatus& from) {
    FileStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "FileStatus";
  }
  protected:
  explicit FileStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef FileStatus_FileType FileType;
  static constexpr FileType IS_DIR =
    FileStatus_FileType_IS_DIR;
  static constexpr FileType IS_FILE =
    FileStatus_FileType_IS_FILE;
  static constexpr FileType IS_SYMLINK =
    FileStatus_FileType_IS_SYMLINK;
  static inline bool FileType_IsValid(int value) {
    return FileStatus_FileType_IsValid(value);
  }
  static constexpr FileType FileType_MIN =
    FileStatus_FileType_FileType_MIN;
  static constexpr FileType FileType_MAX =
    FileStatus_FileType_FileType_MAX;
  static constexpr int FileType_ARRAYSIZE =
    FileStatus_FileType_FileType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  FileType_descriptor() {
    return FileStatus_FileType_descriptor();
  }
  template<typename T>
  static inline const std::string& FileType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, FileType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function FileType_Name.");
    return FileStatus_FileType_Name(enum_t_value);
  }
  static inline bool FileType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      FileType* value) {
    return FileStatus_FileType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 2,
    kOwnerFieldNumber = 5,
    kGroupFieldNumber = 6,
    kPermissionFieldNumber = 4,
    kLengthFieldNumber = 3,
    kModificationTimeFieldNumber = 7,
    kAccessTimeFieldNumber = 8,
    kFileTypeFieldNumber = 1,
  };
  // string path = 2;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // string owner = 5;
  void clear_owner();
  const std::string& owner() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner();
  PROTOBUF_NODISCARD std::string* release_owner();
  void set_allocated_owner(std::string* owner);
  private:
  const std::string& _internal_owner() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner(const std::string& value);
  std::string* _internal_mutable_owner();
  public:

  // string group = 6;
  void clear_group();
  const std::string& group() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_group(ArgT0&& arg0, ArgT... args);
  std::string* mutable_group();
  PROTOBUF_NODISCARD std::string* release_group();
  void set_allocated_group(std::string* group);
  private:
  const std::string& _internal_group() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_group(const std::string& value);
  std::string* _internal_mutable_group();
  public:

  // .Permission permission = 4;
  bool has_permission() const;
  private:
  bool _internal_has_permission() const;
  public:
  void clear_permission();
  const ::Permission& permission() const;
  PROTOBUF_NODISCARD ::Permission* release_permission();
  ::Permission* mutable_permission();
  void set_allocated_permission(::Permission* permission);
  private:
  const ::Permission& _internal_permission() const;
  ::Permission* _internal_mutable_permission();
  public:
  void unsafe_arena_set_allocated_permission(
      ::Permission* permission);
  ::Permission* unsafe_arena_release_permission();

  // uint64 length = 3;
  void clear_length();
  uint64_t length() const;
  void set_length(uint64_t value);
  private:
  uint64_t _internal_length() const;
  void _internal_set_length(uint64_t value);
  public:

  // uint64 modification_time = 7;
  void clear_modification_time();
  uint64_t modification_time() const;
  void set_modification_time(uint64_t value);
  private:
  uint64_t _internal_modification_time() const;
  void _internal_set_modification_time(uint64_t value);
  public:

  // uint64 access_time = 8;
  void clear_access_time();
  uint64_t access_time() const;
  void set_access_time(uint64_t value);
  private:
  uint64_t _internal_access_time() const;
  void _internal_set_access_time(uint64_t value);
  public:

  // .FileStatus.FileType fileType = 1;
  void clear_filetype();
  ::FileStatus_FileType filetype() const;
  void set_filetype(::FileStatus_FileType value);
  private:
  ::FileStatus_FileType _internal_filetype() const;
  void _internal_set_filetype(::FileStatus_FileType value);
  public:

  // @@protoc_insertion_point(class_scope:FileStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_;
    ::Permission* permission_;
    uint64_t length_;
    uint64_t modification_time_;
    uint64_t access_time_;
    int filetype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dfs_2eproto;
};
// -------------------------------------------------------------------

class ServerDefaults final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerDefaults) */ {
 public:
  inline ServerDefaults() : ServerDefaults(nullptr) {}
  ~ServerDefaults() override;
  explicit PROTOBUF_CONSTEXPR ServerDefaults(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServerDefaults(const ServerDefaults& from);
  ServerDefaults(ServerDefaults&& from) noexcept
    : ServerDefaults() {
    *this = ::std::move(from);
  }

  inline ServerDefaults& operator=(const ServerDefaults& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerDefaults& operator=(ServerDefaults&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerDefaults& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServerDefaults* internal_default_instance() {
    return reinterpret_cast<const ServerDefaults*>(
               &_ServerDefaults_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ServerDefaults& a, ServerDefaults& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerDefaults* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerDefaults* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerDefaults* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServerDefaults>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServerDefaults& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ServerDefaults& from) {
    ServerDefaults::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerDefaults* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerDefaults";
  }
  protected:
  explicit ServerDefaults(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockSizeFieldNumber = 1,
    kBytesPerChecksumFieldNumber = 2,
    kWritePacketSizeFieldNumber = 3,
    kReplicationFieldNumber = 4,
    kFileBufferSizeFieldNumber = 5,
    kChecksumTypeFieldNumber = 6,
  };
  // uint64 blockSize = 1;
  void clear_blocksize();
  uint64_t blocksize() const;
  void set_blocksize(uint64_t value);
  private:
  uint64_t _internal_blocksize() const;
  void _internal_set_blocksize(uint64_t value);
  public:

  // uint32 bytesPerChecksum = 2;
  void clear_bytesperchecksum();
  uint32_t bytesperchecksum() const;
  void set_bytesperchecksum(uint32_t value);
  private:
  uint32_t _internal_bytesperchecksum() const;
  void _internal_set_bytesperchecksum(uint32_t value);
  public:

  // uint32 writePacketSize = 3;
  void clear_writepacketsize();
  uint32_t writepacketsize() const;
  void set_writepacketsize(uint32_t value);
  private:
  uint32_t _internal_writepacketsize() const;
  void _internal_set_writepacketsize(uint32_t value);
  public:

  // uint32 replication = 4;
  void clear_replication();
  uint32_t replication() const;
  void set_replication(uint32_t value);
  private:
  uint32_t _internal_replication() const;
  void _internal_set_replication(uint32_t value);
  public:

  // uint32 fileBufferSize = 5;
  void clear_filebuffersize();
  uint32_t filebuffersize() const;
  void set_filebuffersize(uint32_t value);
  private:
  uint32_t _internal_filebuffersize() const;
  void _internal_set_filebuffersize(uint32_t value);
  public:

  // .ChecksumType checksumType = 6;
  void clear_checksumtype();
  ::ChecksumType checksumtype() const;
  void set_checksumtype(::ChecksumType value);
  private:
  ::ChecksumType _internal_checksumtype() const;
  void _internal_set_checksumtype(::ChecksumType value);
  public:

  // @@protoc_insertion_point(class_scope:ServerDefaults)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t blocksize_;
    uint32_t bytesperchecksum_;
    uint32_t writepacketsize_;
    uint32_t replication_;
    uint32_t filebuffersize_;
    int checksumtype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dfs_2eproto;
};
// -------------------------------------------------------------------

class DirectoryListing final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DirectoryListing) */ {
 public:
  inline DirectoryListing() : DirectoryListing(nullptr) {}
  ~DirectoryListing() override;
  explicit PROTOBUF_CONSTEXPR DirectoryListing(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DirectoryListing(const DirectoryListing& from);
  DirectoryListing(DirectoryListing&& from) noexcept
    : DirectoryListing() {
    *this = ::std::move(from);
  }

  inline DirectoryListing& operator=(const DirectoryListing& from) {
    CopyFrom(from);
    return *this;
  }
  inline DirectoryListing& operator=(DirectoryListing&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DirectoryListing& default_instance() {
    return *internal_default_instance();
  }
  static inline const DirectoryListing* internal_default_instance() {
    return reinterpret_cast<const DirectoryListing*>(
               &_DirectoryListing_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(DirectoryListing& a, DirectoryListing& b) {
    a.Swap(&b);
  }
  inline void Swap(DirectoryListing* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DirectoryListing* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DirectoryListing* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DirectoryListing>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DirectoryListing& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DirectoryListing& from) {
    DirectoryListing::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DirectoryListing* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DirectoryListing";
  }
  protected:
  explicit DirectoryListing(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartialListingFieldNumber = 1,
    kRemainingEntriesFieldNumber = 2,
  };
  // repeated .FileStatus partialListing = 1;
  int partiallisting_size() const;
  private:
  int _internal_partiallisting_size() const;
  public:
  void clear_partiallisting();
  ::FileStatus* mutable_partiallisting(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::FileStatus >*
      mutable_partiallisting();
  private:
  const ::FileStatus& _internal_partiallisting(int index) const;
  ::FileStatus* _internal_add_partiallisting();
  public:
  const ::FileStatus& partiallisting(int index) const;
  ::FileStatus* add_partiallisting();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::FileStatus >&
      partiallisting() const;

  // uint32 remainingEntries = 2;
  void clear_remainingentries();
  uint32_t remainingentries() const;
  void set_remainingentries(uint32_t value);
  private:
  uint32_t _internal_remainingentries() const;
  void _internal_set_remainingentries(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:DirectoryListing)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::FileStatus > partiallisting_;
    uint32_t remainingentries_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dfs_2eproto;
};
// -------------------------------------------------------------------

class Block final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Block) */ {
 public:
  inline Block() : Block(nullptr) {}
  ~Block() override;
  explicit PROTOBUF_CONSTEXPR Block(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Block(const Block& from);
  Block(Block&& from) noexcept
    : Block() {
    *this = ::std::move(from);
  }

  inline Block& operator=(const Block& from) {
    CopyFrom(from);
    return *this;
  }
  inline Block& operator=(Block&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Block& default_instance() {
    return *internal_default_instance();
  }
  static inline const Block* internal_default_instance() {
    return reinterpret_cast<const Block*>(
               &_Block_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Block& a, Block& b) {
    a.Swap(&b);
  }
  inline void Swap(Block* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Block* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Block* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Block>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Block& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Block& from) {
    Block::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Block* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Block";
  }
  protected:
  explicit Block(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockIdFieldNumber = 1,
    kGenerationStampFieldNumber = 2,
    kSizeFieldNumber = 3,
  };
  // uint64 blockId = 1;
  void clear_blockid();
  uint64_t blockid() const;
  void set_blockid(uint64_t value);
  private:
  uint64_t _internal_blockid() const;
  void _internal_set_blockid(uint64_t value);
  public:

  // uint64 generationStamp = 2;
  void clear_generationstamp();
  uint64_t generationstamp() const;
  void set_generationstamp(uint64_t value);
  private:
  uint64_t _internal_generationstamp() const;
  void _internal_set_generationstamp(uint64_t value);
  public:

  // uint64 size = 3;
  void clear_size();
  uint64_t size() const;
  void set_size(uint64_t value);
  private:
  uint64_t _internal_size() const;
  void _internal_set_size(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Block)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t blockid_;
    uint64_t generationstamp_;
    uint64_t size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dfs_2eproto;
};
// -------------------------------------------------------------------

class BlockWithLocation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:BlockWithLocation) */ {
 public:
  inline BlockWithLocation() : BlockWithLocation(nullptr) {}
  ~BlockWithLocation() override;
  explicit PROTOBUF_CONSTEXPR BlockWithLocation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockWithLocation(const BlockWithLocation& from);
  BlockWithLocation(BlockWithLocation&& from) noexcept
    : BlockWithLocation() {
    *this = ::std::move(from);
  }

  inline BlockWithLocation& operator=(const BlockWithLocation& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockWithLocation& operator=(BlockWithLocation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockWithLocation& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockWithLocation* internal_default_instance() {
    return reinterpret_cast<const BlockWithLocation*>(
               &_BlockWithLocation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(BlockWithLocation& a, BlockWithLocation& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockWithLocation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockWithLocation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockWithLocation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockWithLocation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockWithLocation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BlockWithLocation& from) {
    BlockWithLocation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockWithLocation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "BlockWithLocation";
  }
  protected:
  explicit BlockWithLocation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDatanodeUuidsFieldNumber = 2,
    kBlockFieldNumber = 1,
  };
  // repeated string datanodeUuids = 2;
  int datanodeuuids_size() const;
  private:
  int _internal_datanodeuuids_size() const;
  public:
  void clear_datanodeuuids();
  const std::string& datanodeuuids(int index) const;
  std::string* mutable_datanodeuuids(int index);
  void set_datanodeuuids(int index, const std::string& value);
  void set_datanodeuuids(int index, std::string&& value);
  void set_datanodeuuids(int index, const char* value);
  void set_datanodeuuids(int index, const char* value, size_t size);
  std::string* add_datanodeuuids();
  void add_datanodeuuids(const std::string& value);
  void add_datanodeuuids(std::string&& value);
  void add_datanodeuuids(const char* value);
  void add_datanodeuuids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& datanodeuuids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_datanodeuuids();
  private:
  const std::string& _internal_datanodeuuids(int index) const;
  std::string* _internal_add_datanodeuuids();
  public:

  // .Block block = 1;
  bool has_block() const;
  private:
  bool _internal_has_block() const;
  public:
  void clear_block();
  const ::Block& block() const;
  PROTOBUF_NODISCARD ::Block* release_block();
  ::Block* mutable_block();
  void set_allocated_block(::Block* block);
  private:
  const ::Block& _internal_block() const;
  ::Block* _internal_mutable_block();
  public:
  void unsafe_arena_set_allocated_block(
      ::Block* block);
  ::Block* unsafe_arena_release_block();

  // @@protoc_insertion_point(class_scope:BlockWithLocation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> datanodeuuids_;
    ::Block* block_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dfs_2eproto;
};
// -------------------------------------------------------------------

class LocatedBlock final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LocatedBlock) */ {
 public:
  inline LocatedBlock() : LocatedBlock(nullptr) {}
  ~LocatedBlock() override;
  explicit PROTOBUF_CONSTEXPR LocatedBlock(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LocatedBlock(const LocatedBlock& from);
  LocatedBlock(LocatedBlock&& from) noexcept
    : LocatedBlock() {
    *this = ::std::move(from);
  }

  inline LocatedBlock& operator=(const LocatedBlock& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocatedBlock& operator=(LocatedBlock&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LocatedBlock& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocatedBlock* internal_default_instance() {
    return reinterpret_cast<const LocatedBlock*>(
               &_LocatedBlock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(LocatedBlock& a, LocatedBlock& b) {
    a.Swap(&b);
  }
  inline void Swap(LocatedBlock* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocatedBlock* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocatedBlock* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LocatedBlock>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LocatedBlock& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LocatedBlock& from) {
    LocatedBlock::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocatedBlock* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LocatedBlock";
  }
  protected:
  explicit LocatedBlock(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocsFieldNumber = 3,
    kBlockFieldNumber = 1,
    kOffsetFieldNumber = 2,
    kCorruptFieldNumber = 4,
  };
  // repeated .DatanodeInfo locs = 3;
  int locs_size() const;
  private:
  int _internal_locs_size() const;
  public:
  void clear_locs();
  ::DatanodeInfo* mutable_locs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DatanodeInfo >*
      mutable_locs();
  private:
  const ::DatanodeInfo& _internal_locs(int index) const;
  ::DatanodeInfo* _internal_add_locs();
  public:
  const ::DatanodeInfo& locs(int index) const;
  ::DatanodeInfo* add_locs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DatanodeInfo >&
      locs() const;

  // .Block block = 1;
  bool has_block() const;
  private:
  bool _internal_has_block() const;
  public:
  void clear_block();
  const ::Block& block() const;
  PROTOBUF_NODISCARD ::Block* release_block();
  ::Block* mutable_block();
  void set_allocated_block(::Block* block);
  private:
  const ::Block& _internal_block() const;
  ::Block* _internal_mutable_block();
  public:
  void unsafe_arena_set_allocated_block(
      ::Block* block);
  ::Block* unsafe_arena_release_block();

  // uint64 offset = 2;
  void clear_offset();
  uint64_t offset() const;
  void set_offset(uint64_t value);
  private:
  uint64_t _internal_offset() const;
  void _internal_set_offset(uint64_t value);
  public:

  // bool corrupt = 4;
  void clear_corrupt();
  bool corrupt() const;
  void set_corrupt(bool value);
  private:
  bool _internal_corrupt() const;
  void _internal_set_corrupt(bool value);
  public:

  // @@protoc_insertion_point(class_scope:LocatedBlock)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DatanodeInfo > locs_;
    ::Block* block_;
    uint64_t offset_;
    bool corrupt_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dfs_2eproto;
};
// -------------------------------------------------------------------

class LocatedBlocks final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LocatedBlocks) */ {
 public:
  inline LocatedBlocks() : LocatedBlocks(nullptr) {}
  ~LocatedBlocks() override;
  explicit PROTOBUF_CONSTEXPR LocatedBlocks(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LocatedBlocks(const LocatedBlocks& from);
  LocatedBlocks(LocatedBlocks&& from) noexcept
    : LocatedBlocks() {
    *this = ::std::move(from);
  }

  inline LocatedBlocks& operator=(const LocatedBlocks& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocatedBlocks& operator=(LocatedBlocks&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LocatedBlocks& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocatedBlocks* internal_default_instance() {
    return reinterpret_cast<const LocatedBlocks*>(
               &_LocatedBlocks_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(LocatedBlocks& a, LocatedBlocks& b) {
    a.Swap(&b);
  }
  inline void Swap(LocatedBlocks* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocatedBlocks* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocatedBlocks* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LocatedBlocks>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LocatedBlocks& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LocatedBlocks& from) {
    LocatedBlocks::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocatedBlocks* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LocatedBlocks";
  }
  protected:
  explicit LocatedBlocks(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlocksFieldNumber = 2,
    kLastFieldNumber = 3,
    kFileLengthFieldNumber = 1,
    kIsLastBlockcompleteFieldNumber = 5,
  };
  // repeated .LocatedBlock blocks = 2;
  int blocks_size() const;
  private:
  int _internal_blocks_size() const;
  public:
  void clear_blocks();
  ::LocatedBlock* mutable_blocks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LocatedBlock >*
      mutable_blocks();
  private:
  const ::LocatedBlock& _internal_blocks(int index) const;
  ::LocatedBlock* _internal_add_blocks();
  public:
  const ::LocatedBlock& blocks(int index) const;
  ::LocatedBlock* add_blocks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LocatedBlock >&
      blocks() const;

  // .LocatedBlock last = 3;
  bool has_last() const;
  private:
  bool _internal_has_last() const;
  public:
  void clear_last();
  const ::LocatedBlock& last() const;
  PROTOBUF_NODISCARD ::LocatedBlock* release_last();
  ::LocatedBlock* mutable_last();
  void set_allocated_last(::LocatedBlock* last);
  private:
  const ::LocatedBlock& _internal_last() const;
  ::LocatedBlock* _internal_mutable_last();
  public:
  void unsafe_arena_set_allocated_last(
      ::LocatedBlock* last);
  ::LocatedBlock* unsafe_arena_release_last();

  // uint64 fileLength = 1;
  void clear_filelength();
  uint64_t filelength() const;
  void set_filelength(uint64_t value);
  private:
  uint64_t _internal_filelength() const;
  void _internal_set_filelength(uint64_t value);
  public:

  // bool isLastBlockcomplete = 5;
  void clear_islastblockcomplete();
  bool islastblockcomplete() const;
  void set_islastblockcomplete(bool value);
  private:
  bool _internal_islastblockcomplete() const;
  void _internal_set_islastblockcomplete(bool value);
  public:

  // @@protoc_insertion_point(class_scope:LocatedBlocks)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LocatedBlock > blocks_;
    ::LocatedBlock* last_;
    uint64_t filelength_;
    bool islastblockcomplete_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dfs_2eproto;
};
// -------------------------------------------------------------------

class BlocksWithLocation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:BlocksWithLocation) */ {
 public:
  inline BlocksWithLocation() : BlocksWithLocation(nullptr) {}
  ~BlocksWithLocation() override;
  explicit PROTOBUF_CONSTEXPR BlocksWithLocation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlocksWithLocation(const BlocksWithLocation& from);
  BlocksWithLocation(BlocksWithLocation&& from) noexcept
    : BlocksWithLocation() {
    *this = ::std::move(from);
  }

  inline BlocksWithLocation& operator=(const BlocksWithLocation& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlocksWithLocation& operator=(BlocksWithLocation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlocksWithLocation& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlocksWithLocation* internal_default_instance() {
    return reinterpret_cast<const BlocksWithLocation*>(
               &_BlocksWithLocation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(BlocksWithLocation& a, BlocksWithLocation& b) {
    a.Swap(&b);
  }
  inline void Swap(BlocksWithLocation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlocksWithLocation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlocksWithLocation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlocksWithLocation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlocksWithLocation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BlocksWithLocation& from) {
    BlocksWithLocation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlocksWithLocation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "BlocksWithLocation";
  }
  protected:
  explicit BlocksWithLocation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlocksFieldNumber = 1,
  };
  // repeated .Block blocks = 1;
  int blocks_size() const;
  private:
  int _internal_blocks_size() const;
  public:
  void clear_blocks();
  ::Block* mutable_blocks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Block >*
      mutable_blocks();
  private:
  const ::Block& _internal_blocks(int index) const;
  ::Block* _internal_add_blocks();
  public:
  const ::Block& blocks(int index) const;
  ::Block* add_blocks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Block >&
      blocks() const;

  // @@protoc_insertion_point(class_scope:BlocksWithLocation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Block > blocks_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dfs_2eproto;
};
// -------------------------------------------------------------------

class BlockKey final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:BlockKey) */ {
 public:
  inline BlockKey() : BlockKey(nullptr) {}
  ~BlockKey() override;
  explicit PROTOBUF_CONSTEXPR BlockKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockKey(const BlockKey& from);
  BlockKey(BlockKey&& from) noexcept
    : BlockKey() {
    *this = ::std::move(from);
  }

  inline BlockKey& operator=(const BlockKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockKey& operator=(BlockKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockKey* internal_default_instance() {
    return reinterpret_cast<const BlockKey*>(
               &_BlockKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(BlockKey& a, BlockKey& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockKey>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockKey& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BlockKey& from) {
    BlockKey::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockKey* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "BlockKey";
  }
  protected:
  explicit BlockKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyBytesFieldNumber = 3,
    kExpiryDateFieldNumber = 2,
    kKeyIdFieldNumber = 1,
  };
  // bytes keyBytes = 3;
  void clear_keybytes();
  const std::string& keybytes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_keybytes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_keybytes();
  PROTOBUF_NODISCARD std::string* release_keybytes();
  void set_allocated_keybytes(std::string* keybytes);
  private:
  const std::string& _internal_keybytes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_keybytes(const std::string& value);
  std::string* _internal_mutable_keybytes();
  public:

  // uint64 expiryDate = 2;
  void clear_expirydate();
  uint64_t expirydate() const;
  void set_expirydate(uint64_t value);
  private:
  uint64_t _internal_expirydate() const;
  void _internal_set_expirydate(uint64_t value);
  public:

  // uint32 keyId = 1;
  void clear_keyid();
  uint32_t keyid() const;
  void set_keyid(uint32_t value);
  private:
  uint32_t _internal_keyid() const;
  void _internal_set_keyid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:BlockKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr keybytes_;
    uint64_t expirydate_;
    uint32_t keyid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dfs_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DatanodeID

// string ipAddr = 1;
inline void DatanodeID::clear_ipaddr() {
  _impl_.ipaddr_.ClearToEmpty();
}
inline const std::string& DatanodeID::ipaddr() const {
  // @@protoc_insertion_point(field_get:DatanodeID.ipAddr)
  return _internal_ipaddr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DatanodeID::set_ipaddr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ipaddr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DatanodeID.ipAddr)
}
inline std::string* DatanodeID::mutable_ipaddr() {
  std::string* _s = _internal_mutable_ipaddr();
  // @@protoc_insertion_point(field_mutable:DatanodeID.ipAddr)
  return _s;
}
inline const std::string& DatanodeID::_internal_ipaddr() const {
  return _impl_.ipaddr_.Get();
}
inline void DatanodeID::_internal_set_ipaddr(const std::string& value) {
  
  _impl_.ipaddr_.Set(value, GetArenaForAllocation());
}
inline std::string* DatanodeID::_internal_mutable_ipaddr() {
  
  return _impl_.ipaddr_.Mutable(GetArenaForAllocation());
}
inline std::string* DatanodeID::release_ipaddr() {
  // @@protoc_insertion_point(field_release:DatanodeID.ipAddr)
  return _impl_.ipaddr_.Release();
}
inline void DatanodeID::set_allocated_ipaddr(std::string* ipaddr) {
  if (ipaddr != nullptr) {
    
  } else {
    
  }
  _impl_.ipaddr_.SetAllocated(ipaddr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ipaddr_.IsDefault()) {
    _impl_.ipaddr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DatanodeID.ipAddr)
}

// string hostName = 2;
inline void DatanodeID::clear_hostname() {
  _impl_.hostname_.ClearToEmpty();
}
inline const std::string& DatanodeID::hostname() const {
  // @@protoc_insertion_point(field_get:DatanodeID.hostName)
  return _internal_hostname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DatanodeID::set_hostname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hostname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DatanodeID.hostName)
}
inline std::string* DatanodeID::mutable_hostname() {
  std::string* _s = _internal_mutable_hostname();
  // @@protoc_insertion_point(field_mutable:DatanodeID.hostName)
  return _s;
}
inline const std::string& DatanodeID::_internal_hostname() const {
  return _impl_.hostname_.Get();
}
inline void DatanodeID::_internal_set_hostname(const std::string& value) {
  
  _impl_.hostname_.Set(value, GetArenaForAllocation());
}
inline std::string* DatanodeID::_internal_mutable_hostname() {
  
  return _impl_.hostname_.Mutable(GetArenaForAllocation());
}
inline std::string* DatanodeID::release_hostname() {
  // @@protoc_insertion_point(field_release:DatanodeID.hostName)
  return _impl_.hostname_.Release();
}
inline void DatanodeID::set_allocated_hostname(std::string* hostname) {
  if (hostname != nullptr) {
    
  } else {
    
  }
  _impl_.hostname_.SetAllocated(hostname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hostname_.IsDefault()) {
    _impl_.hostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DatanodeID.hostName)
}

// string datanodeUuid = 3;
inline void DatanodeID::clear_datanodeuuid() {
  _impl_.datanodeuuid_.ClearToEmpty();
}
inline const std::string& DatanodeID::datanodeuuid() const {
  // @@protoc_insertion_point(field_get:DatanodeID.datanodeUuid)
  return _internal_datanodeuuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DatanodeID::set_datanodeuuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.datanodeuuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DatanodeID.datanodeUuid)
}
inline std::string* DatanodeID::mutable_datanodeuuid() {
  std::string* _s = _internal_mutable_datanodeuuid();
  // @@protoc_insertion_point(field_mutable:DatanodeID.datanodeUuid)
  return _s;
}
inline const std::string& DatanodeID::_internal_datanodeuuid() const {
  return _impl_.datanodeuuid_.Get();
}
inline void DatanodeID::_internal_set_datanodeuuid(const std::string& value) {
  
  _impl_.datanodeuuid_.Set(value, GetArenaForAllocation());
}
inline std::string* DatanodeID::_internal_mutable_datanodeuuid() {
  
  return _impl_.datanodeuuid_.Mutable(GetArenaForAllocation());
}
inline std::string* DatanodeID::release_datanodeuuid() {
  // @@protoc_insertion_point(field_release:DatanodeID.datanodeUuid)
  return _impl_.datanodeuuid_.Release();
}
inline void DatanodeID::set_allocated_datanodeuuid(std::string* datanodeuuid) {
  if (datanodeuuid != nullptr) {
    
  } else {
    
  }
  _impl_.datanodeuuid_.SetAllocated(datanodeuuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.datanodeuuid_.IsDefault()) {
    _impl_.datanodeuuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DatanodeID.datanodeUuid)
}

// uint32 xferPort = 4;
inline void DatanodeID::clear_xferport() {
  _impl_.xferport_ = 0u;
}
inline uint32_t DatanodeID::_internal_xferport() const {
  return _impl_.xferport_;
}
inline uint32_t DatanodeID::xferport() const {
  // @@protoc_insertion_point(field_get:DatanodeID.xferPort)
  return _internal_xferport();
}
inline void DatanodeID::_internal_set_xferport(uint32_t value) {
  
  _impl_.xferport_ = value;
}
inline void DatanodeID::set_xferport(uint32_t value) {
  _internal_set_xferport(value);
  // @@protoc_insertion_point(field_set:DatanodeID.xferPort)
}

// uint32 infoPort = 5;
inline void DatanodeID::clear_infoport() {
  _impl_.infoport_ = 0u;
}
inline uint32_t DatanodeID::_internal_infoport() const {
  return _impl_.infoport_;
}
inline uint32_t DatanodeID::infoport() const {
  // @@protoc_insertion_point(field_get:DatanodeID.infoPort)
  return _internal_infoport();
}
inline void DatanodeID::_internal_set_infoport(uint32_t value) {
  
  _impl_.infoport_ = value;
}
inline void DatanodeID::set_infoport(uint32_t value) {
  _internal_set_infoport(value);
  // @@protoc_insertion_point(field_set:DatanodeID.infoPort)
}

// uint32 ipcPort = 6;
inline void DatanodeID::clear_ipcport() {
  _impl_.ipcport_ = 0u;
}
inline uint32_t DatanodeID::_internal_ipcport() const {
  return _impl_.ipcport_;
}
inline uint32_t DatanodeID::ipcport() const {
  // @@protoc_insertion_point(field_get:DatanodeID.ipcPort)
  return _internal_ipcport();
}
inline void DatanodeID::_internal_set_ipcport(uint32_t value) {
  
  _impl_.ipcport_ = value;
}
inline void DatanodeID::set_ipcport(uint32_t value) {
  _internal_set_ipcport(value);
  // @@protoc_insertion_point(field_set:DatanodeID.ipcPort)
}

// uint32 infoSecurePort = 7;
inline void DatanodeID::clear_infosecureport() {
  _impl_.infosecureport_ = 0u;
}
inline uint32_t DatanodeID::_internal_infosecureport() const {
  return _impl_.infosecureport_;
}
inline uint32_t DatanodeID::infosecureport() const {
  // @@protoc_insertion_point(field_get:DatanodeID.infoSecurePort)
  return _internal_infosecureport();
}
inline void DatanodeID::_internal_set_infosecureport(uint32_t value) {
  
  _impl_.infosecureport_ = value;
}
inline void DatanodeID::set_infosecureport(uint32_t value) {
  _internal_set_infosecureport(value);
  // @@protoc_insertion_point(field_set:DatanodeID.infoSecurePort)
}

// -------------------------------------------------------------------

// DatanodeInfo

// .DatanodeID id = 1;
inline bool DatanodeInfo::_internal_has_id() const {
  return this != internal_default_instance() && _impl_.id_ != nullptr;
}
inline bool DatanodeInfo::has_id() const {
  return _internal_has_id();
}
inline void DatanodeInfo::clear_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.id_ != nullptr) {
    delete _impl_.id_;
  }
  _impl_.id_ = nullptr;
}
inline const ::DatanodeID& DatanodeInfo::_internal_id() const {
  const ::DatanodeID* p = _impl_.id_;
  return p != nullptr ? *p : reinterpret_cast<const ::DatanodeID&>(
      ::_DatanodeID_default_instance_);
}
inline const ::DatanodeID& DatanodeInfo::id() const {
  // @@protoc_insertion_point(field_get:DatanodeInfo.id)
  return _internal_id();
}
inline void DatanodeInfo::unsafe_arena_set_allocated_id(
    ::DatanodeID* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.id_);
  }
  _impl_.id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DatanodeInfo.id)
}
inline ::DatanodeID* DatanodeInfo::release_id() {
  
  ::DatanodeID* temp = _impl_.id_;
  _impl_.id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DatanodeID* DatanodeInfo::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:DatanodeInfo.id)
  
  ::DatanodeID* temp = _impl_.id_;
  _impl_.id_ = nullptr;
  return temp;
}
inline ::DatanodeID* DatanodeInfo::_internal_mutable_id() {
  
  if (_impl_.id_ == nullptr) {
    auto* p = CreateMaybeMessage<::DatanodeID>(GetArenaForAllocation());
    _impl_.id_ = p;
  }
  return _impl_.id_;
}
inline ::DatanodeID* DatanodeInfo::mutable_id() {
  ::DatanodeID* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:DatanodeInfo.id)
  return _msg;
}
inline void DatanodeInfo::set_allocated_id(::DatanodeID* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.id_;
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(id);
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.id_ = id;
  // @@protoc_insertion_point(field_set_allocated:DatanodeInfo.id)
}

// uint64 capacity = 2;
inline void DatanodeInfo::clear_capacity() {
  _impl_.capacity_ = uint64_t{0u};
}
inline uint64_t DatanodeInfo::_internal_capacity() const {
  return _impl_.capacity_;
}
inline uint64_t DatanodeInfo::capacity() const {
  // @@protoc_insertion_point(field_get:DatanodeInfo.capacity)
  return _internal_capacity();
}
inline void DatanodeInfo::_internal_set_capacity(uint64_t value) {
  
  _impl_.capacity_ = value;
}
inline void DatanodeInfo::set_capacity(uint64_t value) {
  _internal_set_capacity(value);
  // @@protoc_insertion_point(field_set:DatanodeInfo.capacity)
}

// uint64 used = 3;
inline void DatanodeInfo::clear_used() {
  _impl_.used_ = uint64_t{0u};
}
inline uint64_t DatanodeInfo::_internal_used() const {
  return _impl_.used_;
}
inline uint64_t DatanodeInfo::used() const {
  // @@protoc_insertion_point(field_get:DatanodeInfo.used)
  return _internal_used();
}
inline void DatanodeInfo::_internal_set_used(uint64_t value) {
  
  _impl_.used_ = value;
}
inline void DatanodeInfo::set_used(uint64_t value) {
  _internal_set_used(value);
  // @@protoc_insertion_point(field_set:DatanodeInfo.used)
}

// uint64 remaining = 4;
inline void DatanodeInfo::clear_remaining() {
  _impl_.remaining_ = uint64_t{0u};
}
inline uint64_t DatanodeInfo::_internal_remaining() const {
  return _impl_.remaining_;
}
inline uint64_t DatanodeInfo::remaining() const {
  // @@protoc_insertion_point(field_get:DatanodeInfo.remaining)
  return _internal_remaining();
}
inline void DatanodeInfo::_internal_set_remaining(uint64_t value) {
  
  _impl_.remaining_ = value;
}
inline void DatanodeInfo::set_remaining(uint64_t value) {
  _internal_set_remaining(value);
  // @@protoc_insertion_point(field_set:DatanodeInfo.remaining)
}

// uint64 lastUpdate = 5;
inline void DatanodeInfo::clear_lastupdate() {
  _impl_.lastupdate_ = uint64_t{0u};
}
inline uint64_t DatanodeInfo::_internal_lastupdate() const {
  return _impl_.lastupdate_;
}
inline uint64_t DatanodeInfo::lastupdate() const {
  // @@protoc_insertion_point(field_get:DatanodeInfo.lastUpdate)
  return _internal_lastupdate();
}
inline void DatanodeInfo::_internal_set_lastupdate(uint64_t value) {
  
  _impl_.lastupdate_ = value;
}
inline void DatanodeInfo::set_lastupdate(uint64_t value) {
  _internal_set_lastupdate(value);
  // @@protoc_insertion_point(field_set:DatanodeInfo.lastUpdate)
}

// uint32 xceiverCount = 6;
inline void DatanodeInfo::clear_xceivercount() {
  _impl_.xceivercount_ = 0u;
}
inline uint32_t DatanodeInfo::_internal_xceivercount() const {
  return _impl_.xceivercount_;
}
inline uint32_t DatanodeInfo::xceivercount() const {
  // @@protoc_insertion_point(field_get:DatanodeInfo.xceiverCount)
  return _internal_xceivercount();
}
inline void DatanodeInfo::_internal_set_xceivercount(uint32_t value) {
  
  _impl_.xceivercount_ = value;
}
inline void DatanodeInfo::set_xceivercount(uint32_t value) {
  _internal_set_xceivercount(value);
  // @@protoc_insertion_point(field_set:DatanodeInfo.xceiverCount)
}

// string location = 8;
inline void DatanodeInfo::clear_location() {
  _impl_.location_.ClearToEmpty();
}
inline const std::string& DatanodeInfo::location() const {
  // @@protoc_insertion_point(field_get:DatanodeInfo.location)
  return _internal_location();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DatanodeInfo::set_location(ArgT0&& arg0, ArgT... args) {
 
 _impl_.location_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DatanodeInfo.location)
}
inline std::string* DatanodeInfo::mutable_location() {
  std::string* _s = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:DatanodeInfo.location)
  return _s;
}
inline const std::string& DatanodeInfo::_internal_location() const {
  return _impl_.location_.Get();
}
inline void DatanodeInfo::_internal_set_location(const std::string& value) {
  
  _impl_.location_.Set(value, GetArenaForAllocation());
}
inline std::string* DatanodeInfo::_internal_mutable_location() {
  
  return _impl_.location_.Mutable(GetArenaForAllocation());
}
inline std::string* DatanodeInfo::release_location() {
  // @@protoc_insertion_point(field_release:DatanodeInfo.location)
  return _impl_.location_.Release();
}
inline void DatanodeInfo::set_allocated_location(std::string* location) {
  if (location != nullptr) {
    
  } else {
    
  }
  _impl_.location_.SetAllocated(location, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.location_.IsDefault()) {
    _impl_.location_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DatanodeInfo.location)
}

// .DatanodeInfo.AdminState adminState = 9;
inline void DatanodeInfo::clear_adminstate() {
  _impl_.adminstate_ = 0;
}
inline ::DatanodeInfo_AdminState DatanodeInfo::_internal_adminstate() const {
  return static_cast< ::DatanodeInfo_AdminState >(_impl_.adminstate_);
}
inline ::DatanodeInfo_AdminState DatanodeInfo::adminstate() const {
  // @@protoc_insertion_point(field_get:DatanodeInfo.adminState)
  return _internal_adminstate();
}
inline void DatanodeInfo::_internal_set_adminstate(::DatanodeInfo_AdminState value) {
  
  _impl_.adminstate_ = value;
}
inline void DatanodeInfo::set_adminstate(::DatanodeInfo_AdminState value) {
  _internal_set_adminstate(value);
  // @@protoc_insertion_point(field_set:DatanodeInfo.adminState)
}

// -------------------------------------------------------------------

// Permission

// uint32 psermission = 1;
inline void Permission::clear_psermission() {
  _impl_.psermission_ = 0u;
}
inline uint32_t Permission::_internal_psermission() const {
  return _impl_.psermission_;
}
inline uint32_t Permission::psermission() const {
  // @@protoc_insertion_point(field_get:Permission.psermission)
  return _internal_psermission();
}
inline void Permission::_internal_set_psermission(uint32_t value) {
  
  _impl_.psermission_ = value;
}
inline void Permission::set_psermission(uint32_t value) {
  _internal_set_psermission(value);
  // @@protoc_insertion_point(field_set:Permission.psermission)
}

// -------------------------------------------------------------------

// FileStatus

// .FileStatus.FileType fileType = 1;
inline void FileStatus::clear_filetype() {
  _impl_.filetype_ = 0;
}
inline ::FileStatus_FileType FileStatus::_internal_filetype() const {
  return static_cast< ::FileStatus_FileType >(_impl_.filetype_);
}
inline ::FileStatus_FileType FileStatus::filetype() const {
  // @@protoc_insertion_point(field_get:FileStatus.fileType)
  return _internal_filetype();
}
inline void FileStatus::_internal_set_filetype(::FileStatus_FileType value) {
  
  _impl_.filetype_ = value;
}
inline void FileStatus::set_filetype(::FileStatus_FileType value) {
  _internal_set_filetype(value);
  // @@protoc_insertion_point(field_set:FileStatus.fileType)
}

// string path = 2;
inline void FileStatus::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& FileStatus::path() const {
  // @@protoc_insertion_point(field_get:FileStatus.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileStatus::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FileStatus.path)
}
inline std::string* FileStatus::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:FileStatus.path)
  return _s;
}
inline const std::string& FileStatus::_internal_path() const {
  return _impl_.path_.Get();
}
inline void FileStatus::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* FileStatus::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* FileStatus::release_path() {
  // @@protoc_insertion_point(field_release:FileStatus.path)
  return _impl_.path_.Release();
}
inline void FileStatus::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:FileStatus.path)
}

// uint64 length = 3;
inline void FileStatus::clear_length() {
  _impl_.length_ = uint64_t{0u};
}
inline uint64_t FileStatus::_internal_length() const {
  return _impl_.length_;
}
inline uint64_t FileStatus::length() const {
  // @@protoc_insertion_point(field_get:FileStatus.length)
  return _internal_length();
}
inline void FileStatus::_internal_set_length(uint64_t value) {
  
  _impl_.length_ = value;
}
inline void FileStatus::set_length(uint64_t value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:FileStatus.length)
}

// .Permission permission = 4;
inline bool FileStatus::_internal_has_permission() const {
  return this != internal_default_instance() && _impl_.permission_ != nullptr;
}
inline bool FileStatus::has_permission() const {
  return _internal_has_permission();
}
inline void FileStatus::clear_permission() {
  if (GetArenaForAllocation() == nullptr && _impl_.permission_ != nullptr) {
    delete _impl_.permission_;
  }
  _impl_.permission_ = nullptr;
}
inline const ::Permission& FileStatus::_internal_permission() const {
  const ::Permission* p = _impl_.permission_;
  return p != nullptr ? *p : reinterpret_cast<const ::Permission&>(
      ::_Permission_default_instance_);
}
inline const ::Permission& FileStatus::permission() const {
  // @@protoc_insertion_point(field_get:FileStatus.permission)
  return _internal_permission();
}
inline void FileStatus::unsafe_arena_set_allocated_permission(
    ::Permission* permission) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.permission_);
  }
  _impl_.permission_ = permission;
  if (permission) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:FileStatus.permission)
}
inline ::Permission* FileStatus::release_permission() {
  
  ::Permission* temp = _impl_.permission_;
  _impl_.permission_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Permission* FileStatus::unsafe_arena_release_permission() {
  // @@protoc_insertion_point(field_release:FileStatus.permission)
  
  ::Permission* temp = _impl_.permission_;
  _impl_.permission_ = nullptr;
  return temp;
}
inline ::Permission* FileStatus::_internal_mutable_permission() {
  
  if (_impl_.permission_ == nullptr) {
    auto* p = CreateMaybeMessage<::Permission>(GetArenaForAllocation());
    _impl_.permission_ = p;
  }
  return _impl_.permission_;
}
inline ::Permission* FileStatus::mutable_permission() {
  ::Permission* _msg = _internal_mutable_permission();
  // @@protoc_insertion_point(field_mutable:FileStatus.permission)
  return _msg;
}
inline void FileStatus::set_allocated_permission(::Permission* permission) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.permission_;
  }
  if (permission) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(permission);
    if (message_arena != submessage_arena) {
      permission = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, permission, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.permission_ = permission;
  // @@protoc_insertion_point(field_set_allocated:FileStatus.permission)
}

// string owner = 5;
inline void FileStatus::clear_owner() {
  _impl_.owner_.ClearToEmpty();
}
inline const std::string& FileStatus::owner() const {
  // @@protoc_insertion_point(field_get:FileStatus.owner)
  return _internal_owner();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileStatus::set_owner(ArgT0&& arg0, ArgT... args) {
 
 _impl_.owner_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FileStatus.owner)
}
inline std::string* FileStatus::mutable_owner() {
  std::string* _s = _internal_mutable_owner();
  // @@protoc_insertion_point(field_mutable:FileStatus.owner)
  return _s;
}
inline const std::string& FileStatus::_internal_owner() const {
  return _impl_.owner_.Get();
}
inline void FileStatus::_internal_set_owner(const std::string& value) {
  
  _impl_.owner_.Set(value, GetArenaForAllocation());
}
inline std::string* FileStatus::_internal_mutable_owner() {
  
  return _impl_.owner_.Mutable(GetArenaForAllocation());
}
inline std::string* FileStatus::release_owner() {
  // @@protoc_insertion_point(field_release:FileStatus.owner)
  return _impl_.owner_.Release();
}
inline void FileStatus::set_allocated_owner(std::string* owner) {
  if (owner != nullptr) {
    
  } else {
    
  }
  _impl_.owner_.SetAllocated(owner, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.owner_.IsDefault()) {
    _impl_.owner_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:FileStatus.owner)
}

// string group = 6;
inline void FileStatus::clear_group() {
  _impl_.group_.ClearToEmpty();
}
inline const std::string& FileStatus::group() const {
  // @@protoc_insertion_point(field_get:FileStatus.group)
  return _internal_group();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileStatus::set_group(ArgT0&& arg0, ArgT... args) {
 
 _impl_.group_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FileStatus.group)
}
inline std::string* FileStatus::mutable_group() {
  std::string* _s = _internal_mutable_group();
  // @@protoc_insertion_point(field_mutable:FileStatus.group)
  return _s;
}
inline const std::string& FileStatus::_internal_group() const {
  return _impl_.group_.Get();
}
inline void FileStatus::_internal_set_group(const std::string& value) {
  
  _impl_.group_.Set(value, GetArenaForAllocation());
}
inline std::string* FileStatus::_internal_mutable_group() {
  
  return _impl_.group_.Mutable(GetArenaForAllocation());
}
inline std::string* FileStatus::release_group() {
  // @@protoc_insertion_point(field_release:FileStatus.group)
  return _impl_.group_.Release();
}
inline void FileStatus::set_allocated_group(std::string* group) {
  if (group != nullptr) {
    
  } else {
    
  }
  _impl_.group_.SetAllocated(group, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.group_.IsDefault()) {
    _impl_.group_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:FileStatus.group)
}

// uint64 modification_time = 7;
inline void FileStatus::clear_modification_time() {
  _impl_.modification_time_ = uint64_t{0u};
}
inline uint64_t FileStatus::_internal_modification_time() const {
  return _impl_.modification_time_;
}
inline uint64_t FileStatus::modification_time() const {
  // @@protoc_insertion_point(field_get:FileStatus.modification_time)
  return _internal_modification_time();
}
inline void FileStatus::_internal_set_modification_time(uint64_t value) {
  
  _impl_.modification_time_ = value;
}
inline void FileStatus::set_modification_time(uint64_t value) {
  _internal_set_modification_time(value);
  // @@protoc_insertion_point(field_set:FileStatus.modification_time)
}

// uint64 access_time = 8;
inline void FileStatus::clear_access_time() {
  _impl_.access_time_ = uint64_t{0u};
}
inline uint64_t FileStatus::_internal_access_time() const {
  return _impl_.access_time_;
}
inline uint64_t FileStatus::access_time() const {
  // @@protoc_insertion_point(field_get:FileStatus.access_time)
  return _internal_access_time();
}
inline void FileStatus::_internal_set_access_time(uint64_t value) {
  
  _impl_.access_time_ = value;
}
inline void FileStatus::set_access_time(uint64_t value) {
  _internal_set_access_time(value);
  // @@protoc_insertion_point(field_set:FileStatus.access_time)
}

// -------------------------------------------------------------------

// ServerDefaults

// uint64 blockSize = 1;
inline void ServerDefaults::clear_blocksize() {
  _impl_.blocksize_ = uint64_t{0u};
}
inline uint64_t ServerDefaults::_internal_blocksize() const {
  return _impl_.blocksize_;
}
inline uint64_t ServerDefaults::blocksize() const {
  // @@protoc_insertion_point(field_get:ServerDefaults.blockSize)
  return _internal_blocksize();
}
inline void ServerDefaults::_internal_set_blocksize(uint64_t value) {
  
  _impl_.blocksize_ = value;
}
inline void ServerDefaults::set_blocksize(uint64_t value) {
  _internal_set_blocksize(value);
  // @@protoc_insertion_point(field_set:ServerDefaults.blockSize)
}

// uint32 bytesPerChecksum = 2;
inline void ServerDefaults::clear_bytesperchecksum() {
  _impl_.bytesperchecksum_ = 0u;
}
inline uint32_t ServerDefaults::_internal_bytesperchecksum() const {
  return _impl_.bytesperchecksum_;
}
inline uint32_t ServerDefaults::bytesperchecksum() const {
  // @@protoc_insertion_point(field_get:ServerDefaults.bytesPerChecksum)
  return _internal_bytesperchecksum();
}
inline void ServerDefaults::_internal_set_bytesperchecksum(uint32_t value) {
  
  _impl_.bytesperchecksum_ = value;
}
inline void ServerDefaults::set_bytesperchecksum(uint32_t value) {
  _internal_set_bytesperchecksum(value);
  // @@protoc_insertion_point(field_set:ServerDefaults.bytesPerChecksum)
}

// uint32 writePacketSize = 3;
inline void ServerDefaults::clear_writepacketsize() {
  _impl_.writepacketsize_ = 0u;
}
inline uint32_t ServerDefaults::_internal_writepacketsize() const {
  return _impl_.writepacketsize_;
}
inline uint32_t ServerDefaults::writepacketsize() const {
  // @@protoc_insertion_point(field_get:ServerDefaults.writePacketSize)
  return _internal_writepacketsize();
}
inline void ServerDefaults::_internal_set_writepacketsize(uint32_t value) {
  
  _impl_.writepacketsize_ = value;
}
inline void ServerDefaults::set_writepacketsize(uint32_t value) {
  _internal_set_writepacketsize(value);
  // @@protoc_insertion_point(field_set:ServerDefaults.writePacketSize)
}

// uint32 replication = 4;
inline void ServerDefaults::clear_replication() {
  _impl_.replication_ = 0u;
}
inline uint32_t ServerDefaults::_internal_replication() const {
  return _impl_.replication_;
}
inline uint32_t ServerDefaults::replication() const {
  // @@protoc_insertion_point(field_get:ServerDefaults.replication)
  return _internal_replication();
}
inline void ServerDefaults::_internal_set_replication(uint32_t value) {
  
  _impl_.replication_ = value;
}
inline void ServerDefaults::set_replication(uint32_t value) {
  _internal_set_replication(value);
  // @@protoc_insertion_point(field_set:ServerDefaults.replication)
}

// uint32 fileBufferSize = 5;
inline void ServerDefaults::clear_filebuffersize() {
  _impl_.filebuffersize_ = 0u;
}
inline uint32_t ServerDefaults::_internal_filebuffersize() const {
  return _impl_.filebuffersize_;
}
inline uint32_t ServerDefaults::filebuffersize() const {
  // @@protoc_insertion_point(field_get:ServerDefaults.fileBufferSize)
  return _internal_filebuffersize();
}
inline void ServerDefaults::_internal_set_filebuffersize(uint32_t value) {
  
  _impl_.filebuffersize_ = value;
}
inline void ServerDefaults::set_filebuffersize(uint32_t value) {
  _internal_set_filebuffersize(value);
  // @@protoc_insertion_point(field_set:ServerDefaults.fileBufferSize)
}

// .ChecksumType checksumType = 6;
inline void ServerDefaults::clear_checksumtype() {
  _impl_.checksumtype_ = 0;
}
inline ::ChecksumType ServerDefaults::_internal_checksumtype() const {
  return static_cast< ::ChecksumType >(_impl_.checksumtype_);
}
inline ::ChecksumType ServerDefaults::checksumtype() const {
  // @@protoc_insertion_point(field_get:ServerDefaults.checksumType)
  return _internal_checksumtype();
}
inline void ServerDefaults::_internal_set_checksumtype(::ChecksumType value) {
  
  _impl_.checksumtype_ = value;
}
inline void ServerDefaults::set_checksumtype(::ChecksumType value) {
  _internal_set_checksumtype(value);
  // @@protoc_insertion_point(field_set:ServerDefaults.checksumType)
}

// -------------------------------------------------------------------

// DirectoryListing

// repeated .FileStatus partialListing = 1;
inline int DirectoryListing::_internal_partiallisting_size() const {
  return _impl_.partiallisting_.size();
}
inline int DirectoryListing::partiallisting_size() const {
  return _internal_partiallisting_size();
}
inline void DirectoryListing::clear_partiallisting() {
  _impl_.partiallisting_.Clear();
}
inline ::FileStatus* DirectoryListing::mutable_partiallisting(int index) {
  // @@protoc_insertion_point(field_mutable:DirectoryListing.partialListing)
  return _impl_.partiallisting_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::FileStatus >*
DirectoryListing::mutable_partiallisting() {
  // @@protoc_insertion_point(field_mutable_list:DirectoryListing.partialListing)
  return &_impl_.partiallisting_;
}
inline const ::FileStatus& DirectoryListing::_internal_partiallisting(int index) const {
  return _impl_.partiallisting_.Get(index);
}
inline const ::FileStatus& DirectoryListing::partiallisting(int index) const {
  // @@protoc_insertion_point(field_get:DirectoryListing.partialListing)
  return _internal_partiallisting(index);
}
inline ::FileStatus* DirectoryListing::_internal_add_partiallisting() {
  return _impl_.partiallisting_.Add();
}
inline ::FileStatus* DirectoryListing::add_partiallisting() {
  ::FileStatus* _add = _internal_add_partiallisting();
  // @@protoc_insertion_point(field_add:DirectoryListing.partialListing)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::FileStatus >&
DirectoryListing::partiallisting() const {
  // @@protoc_insertion_point(field_list:DirectoryListing.partialListing)
  return _impl_.partiallisting_;
}

// uint32 remainingEntries = 2;
inline void DirectoryListing::clear_remainingentries() {
  _impl_.remainingentries_ = 0u;
}
inline uint32_t DirectoryListing::_internal_remainingentries() const {
  return _impl_.remainingentries_;
}
inline uint32_t DirectoryListing::remainingentries() const {
  // @@protoc_insertion_point(field_get:DirectoryListing.remainingEntries)
  return _internal_remainingentries();
}
inline void DirectoryListing::_internal_set_remainingentries(uint32_t value) {
  
  _impl_.remainingentries_ = value;
}
inline void DirectoryListing::set_remainingentries(uint32_t value) {
  _internal_set_remainingentries(value);
  // @@protoc_insertion_point(field_set:DirectoryListing.remainingEntries)
}

// -------------------------------------------------------------------

// Block

// uint64 blockId = 1;
inline void Block::clear_blockid() {
  _impl_.blockid_ = uint64_t{0u};
}
inline uint64_t Block::_internal_blockid() const {
  return _impl_.blockid_;
}
inline uint64_t Block::blockid() const {
  // @@protoc_insertion_point(field_get:Block.blockId)
  return _internal_blockid();
}
inline void Block::_internal_set_blockid(uint64_t value) {
  
  _impl_.blockid_ = value;
}
inline void Block::set_blockid(uint64_t value) {
  _internal_set_blockid(value);
  // @@protoc_insertion_point(field_set:Block.blockId)
}

// uint64 generationStamp = 2;
inline void Block::clear_generationstamp() {
  _impl_.generationstamp_ = uint64_t{0u};
}
inline uint64_t Block::_internal_generationstamp() const {
  return _impl_.generationstamp_;
}
inline uint64_t Block::generationstamp() const {
  // @@protoc_insertion_point(field_get:Block.generationStamp)
  return _internal_generationstamp();
}
inline void Block::_internal_set_generationstamp(uint64_t value) {
  
  _impl_.generationstamp_ = value;
}
inline void Block::set_generationstamp(uint64_t value) {
  _internal_set_generationstamp(value);
  // @@protoc_insertion_point(field_set:Block.generationStamp)
}

// uint64 size = 3;
inline void Block::clear_size() {
  _impl_.size_ = uint64_t{0u};
}
inline uint64_t Block::_internal_size() const {
  return _impl_.size_;
}
inline uint64_t Block::size() const {
  // @@protoc_insertion_point(field_get:Block.size)
  return _internal_size();
}
inline void Block::_internal_set_size(uint64_t value) {
  
  _impl_.size_ = value;
}
inline void Block::set_size(uint64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:Block.size)
}

// -------------------------------------------------------------------

// BlockWithLocation

// .Block block = 1;
inline bool BlockWithLocation::_internal_has_block() const {
  return this != internal_default_instance() && _impl_.block_ != nullptr;
}
inline bool BlockWithLocation::has_block() const {
  return _internal_has_block();
}
inline void BlockWithLocation::clear_block() {
  if (GetArenaForAllocation() == nullptr && _impl_.block_ != nullptr) {
    delete _impl_.block_;
  }
  _impl_.block_ = nullptr;
}
inline const ::Block& BlockWithLocation::_internal_block() const {
  const ::Block* p = _impl_.block_;
  return p != nullptr ? *p : reinterpret_cast<const ::Block&>(
      ::_Block_default_instance_);
}
inline const ::Block& BlockWithLocation::block() const {
  // @@protoc_insertion_point(field_get:BlockWithLocation.block)
  return _internal_block();
}
inline void BlockWithLocation::unsafe_arena_set_allocated_block(
    ::Block* block) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.block_);
  }
  _impl_.block_ = block;
  if (block) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:BlockWithLocation.block)
}
inline ::Block* BlockWithLocation::release_block() {
  
  ::Block* temp = _impl_.block_;
  _impl_.block_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Block* BlockWithLocation::unsafe_arena_release_block() {
  // @@protoc_insertion_point(field_release:BlockWithLocation.block)
  
  ::Block* temp = _impl_.block_;
  _impl_.block_ = nullptr;
  return temp;
}
inline ::Block* BlockWithLocation::_internal_mutable_block() {
  
  if (_impl_.block_ == nullptr) {
    auto* p = CreateMaybeMessage<::Block>(GetArenaForAllocation());
    _impl_.block_ = p;
  }
  return _impl_.block_;
}
inline ::Block* BlockWithLocation::mutable_block() {
  ::Block* _msg = _internal_mutable_block();
  // @@protoc_insertion_point(field_mutable:BlockWithLocation.block)
  return _msg;
}
inline void BlockWithLocation::set_allocated_block(::Block* block) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.block_;
  }
  if (block) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(block);
    if (message_arena != submessage_arena) {
      block = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, block, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.block_ = block;
  // @@protoc_insertion_point(field_set_allocated:BlockWithLocation.block)
}

// repeated string datanodeUuids = 2;
inline int BlockWithLocation::_internal_datanodeuuids_size() const {
  return _impl_.datanodeuuids_.size();
}
inline int BlockWithLocation::datanodeuuids_size() const {
  return _internal_datanodeuuids_size();
}
inline void BlockWithLocation::clear_datanodeuuids() {
  _impl_.datanodeuuids_.Clear();
}
inline std::string* BlockWithLocation::add_datanodeuuids() {
  std::string* _s = _internal_add_datanodeuuids();
  // @@protoc_insertion_point(field_add_mutable:BlockWithLocation.datanodeUuids)
  return _s;
}
inline const std::string& BlockWithLocation::_internal_datanodeuuids(int index) const {
  return _impl_.datanodeuuids_.Get(index);
}
inline const std::string& BlockWithLocation::datanodeuuids(int index) const {
  // @@protoc_insertion_point(field_get:BlockWithLocation.datanodeUuids)
  return _internal_datanodeuuids(index);
}
inline std::string* BlockWithLocation::mutable_datanodeuuids(int index) {
  // @@protoc_insertion_point(field_mutable:BlockWithLocation.datanodeUuids)
  return _impl_.datanodeuuids_.Mutable(index);
}
inline void BlockWithLocation::set_datanodeuuids(int index, const std::string& value) {
  _impl_.datanodeuuids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:BlockWithLocation.datanodeUuids)
}
inline void BlockWithLocation::set_datanodeuuids(int index, std::string&& value) {
  _impl_.datanodeuuids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:BlockWithLocation.datanodeUuids)
}
inline void BlockWithLocation::set_datanodeuuids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.datanodeuuids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:BlockWithLocation.datanodeUuids)
}
inline void BlockWithLocation::set_datanodeuuids(int index, const char* value, size_t size) {
  _impl_.datanodeuuids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:BlockWithLocation.datanodeUuids)
}
inline std::string* BlockWithLocation::_internal_add_datanodeuuids() {
  return _impl_.datanodeuuids_.Add();
}
inline void BlockWithLocation::add_datanodeuuids(const std::string& value) {
  _impl_.datanodeuuids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:BlockWithLocation.datanodeUuids)
}
inline void BlockWithLocation::add_datanodeuuids(std::string&& value) {
  _impl_.datanodeuuids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:BlockWithLocation.datanodeUuids)
}
inline void BlockWithLocation::add_datanodeuuids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.datanodeuuids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:BlockWithLocation.datanodeUuids)
}
inline void BlockWithLocation::add_datanodeuuids(const char* value, size_t size) {
  _impl_.datanodeuuids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:BlockWithLocation.datanodeUuids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BlockWithLocation::datanodeuuids() const {
  // @@protoc_insertion_point(field_list:BlockWithLocation.datanodeUuids)
  return _impl_.datanodeuuids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BlockWithLocation::mutable_datanodeuuids() {
  // @@protoc_insertion_point(field_mutable_list:BlockWithLocation.datanodeUuids)
  return &_impl_.datanodeuuids_;
}

// -------------------------------------------------------------------

// LocatedBlock

// .Block block = 1;
inline bool LocatedBlock::_internal_has_block() const {
  return this != internal_default_instance() && _impl_.block_ != nullptr;
}
inline bool LocatedBlock::has_block() const {
  return _internal_has_block();
}
inline void LocatedBlock::clear_block() {
  if (GetArenaForAllocation() == nullptr && _impl_.block_ != nullptr) {
    delete _impl_.block_;
  }
  _impl_.block_ = nullptr;
}
inline const ::Block& LocatedBlock::_internal_block() const {
  const ::Block* p = _impl_.block_;
  return p != nullptr ? *p : reinterpret_cast<const ::Block&>(
      ::_Block_default_instance_);
}
inline const ::Block& LocatedBlock::block() const {
  // @@protoc_insertion_point(field_get:LocatedBlock.block)
  return _internal_block();
}
inline void LocatedBlock::unsafe_arena_set_allocated_block(
    ::Block* block) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.block_);
  }
  _impl_.block_ = block;
  if (block) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:LocatedBlock.block)
}
inline ::Block* LocatedBlock::release_block() {
  
  ::Block* temp = _impl_.block_;
  _impl_.block_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Block* LocatedBlock::unsafe_arena_release_block() {
  // @@protoc_insertion_point(field_release:LocatedBlock.block)
  
  ::Block* temp = _impl_.block_;
  _impl_.block_ = nullptr;
  return temp;
}
inline ::Block* LocatedBlock::_internal_mutable_block() {
  
  if (_impl_.block_ == nullptr) {
    auto* p = CreateMaybeMessage<::Block>(GetArenaForAllocation());
    _impl_.block_ = p;
  }
  return _impl_.block_;
}
inline ::Block* LocatedBlock::mutable_block() {
  ::Block* _msg = _internal_mutable_block();
  // @@protoc_insertion_point(field_mutable:LocatedBlock.block)
  return _msg;
}
inline void LocatedBlock::set_allocated_block(::Block* block) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.block_;
  }
  if (block) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(block);
    if (message_arena != submessage_arena) {
      block = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, block, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.block_ = block;
  // @@protoc_insertion_point(field_set_allocated:LocatedBlock.block)
}

// uint64 offset = 2;
inline void LocatedBlock::clear_offset() {
  _impl_.offset_ = uint64_t{0u};
}
inline uint64_t LocatedBlock::_internal_offset() const {
  return _impl_.offset_;
}
inline uint64_t LocatedBlock::offset() const {
  // @@protoc_insertion_point(field_get:LocatedBlock.offset)
  return _internal_offset();
}
inline void LocatedBlock::_internal_set_offset(uint64_t value) {
  
  _impl_.offset_ = value;
}
inline void LocatedBlock::set_offset(uint64_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:LocatedBlock.offset)
}

// repeated .DatanodeInfo locs = 3;
inline int LocatedBlock::_internal_locs_size() const {
  return _impl_.locs_.size();
}
inline int LocatedBlock::locs_size() const {
  return _internal_locs_size();
}
inline void LocatedBlock::clear_locs() {
  _impl_.locs_.Clear();
}
inline ::DatanodeInfo* LocatedBlock::mutable_locs(int index) {
  // @@protoc_insertion_point(field_mutable:LocatedBlock.locs)
  return _impl_.locs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DatanodeInfo >*
LocatedBlock::mutable_locs() {
  // @@protoc_insertion_point(field_mutable_list:LocatedBlock.locs)
  return &_impl_.locs_;
}
inline const ::DatanodeInfo& LocatedBlock::_internal_locs(int index) const {
  return _impl_.locs_.Get(index);
}
inline const ::DatanodeInfo& LocatedBlock::locs(int index) const {
  // @@protoc_insertion_point(field_get:LocatedBlock.locs)
  return _internal_locs(index);
}
inline ::DatanodeInfo* LocatedBlock::_internal_add_locs() {
  return _impl_.locs_.Add();
}
inline ::DatanodeInfo* LocatedBlock::add_locs() {
  ::DatanodeInfo* _add = _internal_add_locs();
  // @@protoc_insertion_point(field_add:LocatedBlock.locs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DatanodeInfo >&
LocatedBlock::locs() const {
  // @@protoc_insertion_point(field_list:LocatedBlock.locs)
  return _impl_.locs_;
}

// bool corrupt = 4;
inline void LocatedBlock::clear_corrupt() {
  _impl_.corrupt_ = false;
}
inline bool LocatedBlock::_internal_corrupt() const {
  return _impl_.corrupt_;
}
inline bool LocatedBlock::corrupt() const {
  // @@protoc_insertion_point(field_get:LocatedBlock.corrupt)
  return _internal_corrupt();
}
inline void LocatedBlock::_internal_set_corrupt(bool value) {
  
  _impl_.corrupt_ = value;
}
inline void LocatedBlock::set_corrupt(bool value) {
  _internal_set_corrupt(value);
  // @@protoc_insertion_point(field_set:LocatedBlock.corrupt)
}

// -------------------------------------------------------------------

// LocatedBlocks

// uint64 fileLength = 1;
inline void LocatedBlocks::clear_filelength() {
  _impl_.filelength_ = uint64_t{0u};
}
inline uint64_t LocatedBlocks::_internal_filelength() const {
  return _impl_.filelength_;
}
inline uint64_t LocatedBlocks::filelength() const {
  // @@protoc_insertion_point(field_get:LocatedBlocks.fileLength)
  return _internal_filelength();
}
inline void LocatedBlocks::_internal_set_filelength(uint64_t value) {
  
  _impl_.filelength_ = value;
}
inline void LocatedBlocks::set_filelength(uint64_t value) {
  _internal_set_filelength(value);
  // @@protoc_insertion_point(field_set:LocatedBlocks.fileLength)
}

// repeated .LocatedBlock blocks = 2;
inline int LocatedBlocks::_internal_blocks_size() const {
  return _impl_.blocks_.size();
}
inline int LocatedBlocks::blocks_size() const {
  return _internal_blocks_size();
}
inline void LocatedBlocks::clear_blocks() {
  _impl_.blocks_.Clear();
}
inline ::LocatedBlock* LocatedBlocks::mutable_blocks(int index) {
  // @@protoc_insertion_point(field_mutable:LocatedBlocks.blocks)
  return _impl_.blocks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LocatedBlock >*
LocatedBlocks::mutable_blocks() {
  // @@protoc_insertion_point(field_mutable_list:LocatedBlocks.blocks)
  return &_impl_.blocks_;
}
inline const ::LocatedBlock& LocatedBlocks::_internal_blocks(int index) const {
  return _impl_.blocks_.Get(index);
}
inline const ::LocatedBlock& LocatedBlocks::blocks(int index) const {
  // @@protoc_insertion_point(field_get:LocatedBlocks.blocks)
  return _internal_blocks(index);
}
inline ::LocatedBlock* LocatedBlocks::_internal_add_blocks() {
  return _impl_.blocks_.Add();
}
inline ::LocatedBlock* LocatedBlocks::add_blocks() {
  ::LocatedBlock* _add = _internal_add_blocks();
  // @@protoc_insertion_point(field_add:LocatedBlocks.blocks)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LocatedBlock >&
LocatedBlocks::blocks() const {
  // @@protoc_insertion_point(field_list:LocatedBlocks.blocks)
  return _impl_.blocks_;
}

// .LocatedBlock last = 3;
inline bool LocatedBlocks::_internal_has_last() const {
  return this != internal_default_instance() && _impl_.last_ != nullptr;
}
inline bool LocatedBlocks::has_last() const {
  return _internal_has_last();
}
inline void LocatedBlocks::clear_last() {
  if (GetArenaForAllocation() == nullptr && _impl_.last_ != nullptr) {
    delete _impl_.last_;
  }
  _impl_.last_ = nullptr;
}
inline const ::LocatedBlock& LocatedBlocks::_internal_last() const {
  const ::LocatedBlock* p = _impl_.last_;
  return p != nullptr ? *p : reinterpret_cast<const ::LocatedBlock&>(
      ::_LocatedBlock_default_instance_);
}
inline const ::LocatedBlock& LocatedBlocks::last() const {
  // @@protoc_insertion_point(field_get:LocatedBlocks.last)
  return _internal_last();
}
inline void LocatedBlocks::unsafe_arena_set_allocated_last(
    ::LocatedBlock* last) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_);
  }
  _impl_.last_ = last;
  if (last) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:LocatedBlocks.last)
}
inline ::LocatedBlock* LocatedBlocks::release_last() {
  
  ::LocatedBlock* temp = _impl_.last_;
  _impl_.last_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::LocatedBlock* LocatedBlocks::unsafe_arena_release_last() {
  // @@protoc_insertion_point(field_release:LocatedBlocks.last)
  
  ::LocatedBlock* temp = _impl_.last_;
  _impl_.last_ = nullptr;
  return temp;
}
inline ::LocatedBlock* LocatedBlocks::_internal_mutable_last() {
  
  if (_impl_.last_ == nullptr) {
    auto* p = CreateMaybeMessage<::LocatedBlock>(GetArenaForAllocation());
    _impl_.last_ = p;
  }
  return _impl_.last_;
}
inline ::LocatedBlock* LocatedBlocks::mutable_last() {
  ::LocatedBlock* _msg = _internal_mutable_last();
  // @@protoc_insertion_point(field_mutable:LocatedBlocks.last)
  return _msg;
}
inline void LocatedBlocks::set_allocated_last(::LocatedBlock* last) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.last_;
  }
  if (last) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(last);
    if (message_arena != submessage_arena) {
      last = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.last_ = last;
  // @@protoc_insertion_point(field_set_allocated:LocatedBlocks.last)
}

// bool isLastBlockcomplete = 5;
inline void LocatedBlocks::clear_islastblockcomplete() {
  _impl_.islastblockcomplete_ = false;
}
inline bool LocatedBlocks::_internal_islastblockcomplete() const {
  return _impl_.islastblockcomplete_;
}
inline bool LocatedBlocks::islastblockcomplete() const {
  // @@protoc_insertion_point(field_get:LocatedBlocks.isLastBlockcomplete)
  return _internal_islastblockcomplete();
}
inline void LocatedBlocks::_internal_set_islastblockcomplete(bool value) {
  
  _impl_.islastblockcomplete_ = value;
}
inline void LocatedBlocks::set_islastblockcomplete(bool value) {
  _internal_set_islastblockcomplete(value);
  // @@protoc_insertion_point(field_set:LocatedBlocks.isLastBlockcomplete)
}

// -------------------------------------------------------------------

// BlocksWithLocation

// repeated .Block blocks = 1;
inline int BlocksWithLocation::_internal_blocks_size() const {
  return _impl_.blocks_.size();
}
inline int BlocksWithLocation::blocks_size() const {
  return _internal_blocks_size();
}
inline void BlocksWithLocation::clear_blocks() {
  _impl_.blocks_.Clear();
}
inline ::Block* BlocksWithLocation::mutable_blocks(int index) {
  // @@protoc_insertion_point(field_mutable:BlocksWithLocation.blocks)
  return _impl_.blocks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Block >*
BlocksWithLocation::mutable_blocks() {
  // @@protoc_insertion_point(field_mutable_list:BlocksWithLocation.blocks)
  return &_impl_.blocks_;
}
inline const ::Block& BlocksWithLocation::_internal_blocks(int index) const {
  return _impl_.blocks_.Get(index);
}
inline const ::Block& BlocksWithLocation::blocks(int index) const {
  // @@protoc_insertion_point(field_get:BlocksWithLocation.blocks)
  return _internal_blocks(index);
}
inline ::Block* BlocksWithLocation::_internal_add_blocks() {
  return _impl_.blocks_.Add();
}
inline ::Block* BlocksWithLocation::add_blocks() {
  ::Block* _add = _internal_add_blocks();
  // @@protoc_insertion_point(field_add:BlocksWithLocation.blocks)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Block >&
BlocksWithLocation::blocks() const {
  // @@protoc_insertion_point(field_list:BlocksWithLocation.blocks)
  return _impl_.blocks_;
}

// -------------------------------------------------------------------

// BlockKey

// uint32 keyId = 1;
inline void BlockKey::clear_keyid() {
  _impl_.keyid_ = 0u;
}
inline uint32_t BlockKey::_internal_keyid() const {
  return _impl_.keyid_;
}
inline uint32_t BlockKey::keyid() const {
  // @@protoc_insertion_point(field_get:BlockKey.keyId)
  return _internal_keyid();
}
inline void BlockKey::_internal_set_keyid(uint32_t value) {
  
  _impl_.keyid_ = value;
}
inline void BlockKey::set_keyid(uint32_t value) {
  _internal_set_keyid(value);
  // @@protoc_insertion_point(field_set:BlockKey.keyId)
}

// uint64 expiryDate = 2;
inline void BlockKey::clear_expirydate() {
  _impl_.expirydate_ = uint64_t{0u};
}
inline uint64_t BlockKey::_internal_expirydate() const {
  return _impl_.expirydate_;
}
inline uint64_t BlockKey::expirydate() const {
  // @@protoc_insertion_point(field_get:BlockKey.expiryDate)
  return _internal_expirydate();
}
inline void BlockKey::_internal_set_expirydate(uint64_t value) {
  
  _impl_.expirydate_ = value;
}
inline void BlockKey::set_expirydate(uint64_t value) {
  _internal_set_expirydate(value);
  // @@protoc_insertion_point(field_set:BlockKey.expiryDate)
}

// bytes keyBytes = 3;
inline void BlockKey::clear_keybytes() {
  _impl_.keybytes_.ClearToEmpty();
}
inline const std::string& BlockKey::keybytes() const {
  // @@protoc_insertion_point(field_get:BlockKey.keyBytes)
  return _internal_keybytes();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlockKey::set_keybytes(ArgT0&& arg0, ArgT... args) {
 
 _impl_.keybytes_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:BlockKey.keyBytes)
}
inline std::string* BlockKey::mutable_keybytes() {
  std::string* _s = _internal_mutable_keybytes();
  // @@protoc_insertion_point(field_mutable:BlockKey.keyBytes)
  return _s;
}
inline const std::string& BlockKey::_internal_keybytes() const {
  return _impl_.keybytes_.Get();
}
inline void BlockKey::_internal_set_keybytes(const std::string& value) {
  
  _impl_.keybytes_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockKey::_internal_mutable_keybytes() {
  
  return _impl_.keybytes_.Mutable(GetArenaForAllocation());
}
inline std::string* BlockKey::release_keybytes() {
  // @@protoc_insertion_point(field_release:BlockKey.keyBytes)
  return _impl_.keybytes_.Release();
}
inline void BlockKey::set_allocated_keybytes(std::string* keybytes) {
  if (keybytes != nullptr) {
    
  } else {
    
  }
  _impl_.keybytes_.SetAllocated(keybytes, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.keybytes_.IsDefault()) {
    _impl_.keybytes_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:BlockKey.keyBytes)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::DatanodeInfo_AdminState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DatanodeInfo_AdminState>() {
  return ::DatanodeInfo_AdminState_descriptor();
}
template <> struct is_proto_enum< ::FileStatus_FileType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::FileStatus_FileType>() {
  return ::FileStatus_FileType_descriptor();
}
template <> struct is_proto_enum< ::ChecksumType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ChecksumType>() {
  return ::ChecksumType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_dfs_2eproto
